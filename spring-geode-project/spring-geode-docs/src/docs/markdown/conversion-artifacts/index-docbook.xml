<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="1"?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en" xml:id="spring-boot-data-geode">
<info>
<title>Spring Boot for Apache Geode Reference Guide</title>
<date>2022-10-07</date>
<author>
<personname>
<firstname>John</firstname>
<surname>Blum</surname>
</personname>
</author>
<authorinitials>JB</authorinitials>
<revhistory>
<revision>
<revnumber>{version}</revnumber>
<date>2022-10-07</date>
<authorinitials>JB</authorinitials>
</revision>
</revhistory>
</info>
<preface>
<title></title>
<simpara xml:id="abstract">Spring Boot for Apache Geode provides the convenience of Spring Boot&#8217;s <emphasis>convention over configuration</emphasis> approach
by using <emphasis>auto-configuration</emphasis> with Spring Framework&#8217;s powerful abstractions and highly consistent programming model to
simplify the development of Apache Geode applications in a Spring context.</simpara>
<simpara>Secondarily, Spring Boot for Apache Geode provides developers with a consistent experience whether building
and running Spring Boot, Apache Geode applications locally or in a managed environment, such as with
<link xl:href="https://tanzu.vmware.com/tanzu">VMware Tanzu Application Service</link> (TAS).</simpara>
<simpara>This project is a continuation and a logical extension to Spring Data for Apache Geode&#8217;s
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config">Annotation-based configuration model</link>, and the goals
set forth in that model: <emphasis>To enable application developers to <emphasis role="strong">get up and running</emphasis> as <emphasis role="strong">quickly</emphasis>, <emphasis role="strong">reliably</emphasis>, and as
<emphasis role="strong">easily</emphasis> as possible</emphasis>. In fact, Spring Boot for Apache Geode builds on this very
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config">foundation</link> cemented in Spring Data for Apache Geode
since the Spring Data Kay (2.0) Release Train.</simpara>
</preface>
<chapter xml:id="introduction">
<title>Introduction</title>
<simpara>Spring Boot for Apache Geode automatically applies <emphasis>auto-configuration</emphasis> to several key application concerns
(<emphasis>use cases</emphasis>) including, but not limited to:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>Look-Aside, [Async] Inline, Near</emphasis> and <emphasis>Multi-Site Caching</emphasis>, by using Apache Geode as a caching provider
in <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache">Spring&#8217;s Cache Abstraction</link>.
For more information, see <xref linkend="geode-caching-provider"/>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://en.wikipedia.org/wiki/System_of_record"><emphasis>System of Record</emphasis> (SOR)</link>, persisting application state in Apache Geode
by using <link xl:href="https://docs.spring.io/spring-data/commons/docs/current/reference/html/#repositories">Spring Data Repositories</link>.
For more information, see <xref linkend="geode-repositories"/>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Transactions</emphasis>, managing application state consistently with <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction">Spring Transaction Management</link>
with support for both <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#apis:transaction-management">Local Cache</link>
and <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#apis:global-transaction-management">Global JTA</link> Transactions.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Distributed Computations</emphasis>, run with Apache Geode&#8217;s <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/function_exec/chapter_overview.html">Function Execution</link>
framework and conveniently implemented and executed with <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#function-annotations">POJO-based, annotation support for Functions</link>.
For more information, see <xref linkend="geode-functions"/>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Continuous Queries</emphasis>, expressing interests in a stream of events and letting applications react to and process changes
to data in near real-time with Apache Geode&#8217;s <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/continuous_querying/chapter_overview.html">Continuous Query (CQ)</link>.
Listeners/Handlers are defined as simple Message-Driven POJOs (MDP) with Spring&#8217;s <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#jms-mdp">Message Listener Container</link>,
which has been <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#apis:continuous-query">extended</link> with its <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-continuous-queries">configurable</link>
CQ support.
For more information, see <xref linkend="geode-continuous-query"/>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Data Serialization</emphasis> using Apache Geode <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/data_serialization/gemfire_pdx_serialization.html">PDX</link>
with first-class <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-pdx">configuration</link>
and <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#mapping.pdx-serializer">support</link>.
For more information, see <xref linkend="geode-data-serialization"/>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Data Initialization</emphasis> to quickly load (import) data to hydrate the cache during application startup or write (export)
data on application shutdown to move data between environments (for example, TEST to DEV).
For more information, see <xref linkend="geode-data-using"/>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Actuator</emphasis>, to gain insight into the runtime behavior and operation of your cache, whether a client or a peer.
For more information, see <xref linkend="actuator"/>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Logging</emphasis>, to quickly and conveniently enable or adjust Apache Geode log levels in your Spring Boot application
to gain insight into the runtime operations of the application as they occur.
For more information, see <xref linkend="geode-logging"/>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Security</emphasis>, including <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/managing/security/authentication_overview.html">Authentication</link>
&amp; <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/managing/security/authorization_overview.html">Authorization</link>, and Transport Layer Security (TLS)
with Apache Geode <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/managing/security/ssl_overview.html">Secure Socket Layer (SSL)</link>. Once more,
Spring Data for Apache Geode includes first-class support for configuring <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-security">Auth</link>
and <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-ssl">SSL</link>.
For more information, see <xref linkend="geode-security"/>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>HTTP Session state management</emphasis>, by including Spring Session for Apache Geode on your application&#8217;s classpath.
For more information, see <xref linkend="geode-session"/>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Testing</emphasis>. Whether you write Unit or Integration Tests for Apache Geode in a Spring context, SBDG covers all
your testing needs with the help of <link xl:href="https://github.com/spring-projects/spring-test-data-geode#spring-test-framework-for-apache-geode&#8212;&#8203;vmware-tanzu-gemfire">STDG</link>.</simpara>
</listitem>
</itemizedlist>
<simpara>While Spring Data for Apache Geode offers a simple, consistent, convenient and declarative approach to configure
all these powerful Apache Geode features, Spring Boot for Apache Geode makes it even easier to do, as we
will explore throughout this reference documentation.</simpara>
<section xml:id="introduction-goals">
<title>Goals</title>
<simpara>While the SBDG project has many goals and objectives, the primary goals of this project center around three key
principles:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>From <emphasis role="strong"><emphasis>Open Source</emphasis></emphasis> (Apache Geode) to <emphasis role="strong"><emphasis>Commercial</emphasis></emphasis> (VMware Tanzu GemFire).</simpara>
</listitem>
<listitem>
<simpara>From <emphasis role="strong"><emphasis>Non-Managed</emphasis></emphasis> (self-managed/self-hosted or on-premise installations) to <emphasis role="strong"><emphasis>Managed</emphasis></emphasis>
(VMware Tanzu GemFire for VMs, VMware Tanzu GemFire for K8S) environments.</simpara>
</listitem>
<listitem>
<simpara>With <emphasis role="strong">little to no code or configuration changes</emphasis> necessary.</simpara>
</listitem>
</orderedlist>
<simpara>It is also possible to go in the reverse direction, from <emphasis>Managed</emphasis> back to a <emphasis>Non-Managed</emphasis> environment
and even from <emphasis>Commercial</emphasis> back to the <emphasis>Open Source</emphasis> offering, again, with <emphasis>little to no code or configuration</emphasis> changes.</simpara>
<note>
<simpara>SBDG&#8217;s promise is to deliver on these principles as much as is technically possible and as is technically allowed
by Apache Geode.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="getting-started">
<title>Getting Started</title>
<simpara>To be immediately productive and as effective as possible when you use Spring Boot for Apache Geode, it helps
to understand the foundation on which this project is built.</simpara>
<simpara>The story begins with the Spring Framework and the <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#spring-core">core technologies and concepts</link>
built into the Spring container.</simpara>
<simpara>Then our journey continues with the extensions built into Spring Data for Apache Geode to simplify the development
of Apache Geode applications in a Spring context, using Spring&#8217;s powerful abstractions and highly consistent
programming model. This part of the story was greatly enhanced in Spring Data Kay,
with the <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config">Annotation-based configuration model</link>.
Though this new configuration approach uses annotations and provides sensible defaults, its use is also very explicit
and assumes nothing. If any part of the configuration is ambiguous, SDG will fail fast. SDG gives you choice, so you
still must tell SDG what you want.</simpara>
<simpara>Next, we venture into Spring Boot and all of its wonderfully expressive and highly opinionated <quote>convention over configuration</quote>
approach for getting the most out of your Spring Apache Geode applications in the easiest, quickest, and most
reliable way possible. We accomplish this by combining Spring Data for Apache Geode&#8217;s <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config">annotation-based configuration</link>
with Spring Boot&#8217;s <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/#using-boot-auto-configuration">auto-configuration</link> to get you up and running
even faster and more reliably so that you are productive from the start.</simpara>
<simpara>As a result, it would be pertinent to begin your Spring Boot education
with <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/#getting-started">Spring Boot&#8217;s documentation</link>.</simpara>
<simpara>Finally, we arrive at Spring Boot for Apache Geode (SBDG).</simpara>
<tip>
<simpara>See the corresponding Sample <link xl:href="guides/getting-started.html">Guide</link> and {github-samples-url}/intro/getting-started[Code]
to see Spring Boot for Apache Geode in action.</simpara>
</tip>
</chapter>
<chapter xml:id="maven-gradle">
<title>Using Spring Boot for Apache Geode</title>
<simpara>To use Spring Boot for Apache Geode, declare the <literal>spring-geode-starter</literal> on your Spring Boot application classpath:</simpara>
<example>
<title>Maven</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.geode&lt;/groupId&gt;
        &lt;artifactId&gt;spring-geode-starter&lt;/artifactId&gt;
        &lt;version&gt;{spring-boot-data-geode-version}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
<formalpara>
<title>Gradle</title>
<para>
<programlisting language="gradle" linenumbering="unnumbered">dependencies {
    compile 'org.springframework.geode:spring-geode-starter:{spring-boot-data-geode-version}'
}</programlisting>
</para>
</formalpara>
</example>
<section xml:id="maven-bom">
<title>Maven BOM</title>
<simpara>If you anticipate using more than one Spring Boot for Apache Geode (SBDG) module in your Spring Boot application,
you can also declare the new <literal>org.springframework.geode:spring-geode-bom</literal> Maven BOM in your application Maven POM.</simpara>
<simpara>Your application use case may require more than one module if (for example, you need (HTTP) Session state management
and replication with, for example, <literal>spring-geode-starter-session</literal>), if you need to enable Spring Boot Actuator endpoints
for Apache Geode (for example, <literal>spring-geode-starter-actuator</literal>), or if you need assistance writing complex Unit
and (Distributed) Integration Tests with Spring Test for Apache Geode (STDG) (for example, <literal>spring-geode-starter-test</literal>).</simpara>
<simpara>You can declare and use any one of the SBDG modules:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>spring-geode-starter</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spring-geode-starter-actuator</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spring-geode-starter-logging</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spring-geode-starter-session</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spring-geode-starter-test</literal></simpara>
</listitem>
</itemizedlist>
<simpara>When more than one SBDG module is in use, it makes sense to declare the <literal>spring-geode-bom</literal> to manage all the dependencies
such that the versions and transitive dependencies necessarily align properly.</simpara>
<simpara>A Spring Boot application Maven POM that declares the <literal>spring-geode-bom</literal> along with two or more module dependencies
might appear as follows:</simpara>
<example>
<title>Spring Boot application Maven POM</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;{spring-boot-version}&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;my-spring-boot-application&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;spring-geode.version&gt;{spring-boot-data-geode-version}&lt;/spring-geode.version&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.geode&lt;/groupId&gt;
                &lt;artifactId&gt;spring-geode-bom&lt;/artifactId&gt;
                &lt;version&gt;${spring-geode.version}&lt;/version&gt;
                &lt;scope&gt;import&lt;/scope&gt;
                &lt;type&gt;pom&lt;/type&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.geode&lt;/groupId&gt;
            &lt;artifactId&gt;spring-geode-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.geode&lt;/groupId&gt;
            &lt;artifactId&gt;spring-geode-starter-session&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.geode&lt;/groupId&gt;
            &lt;artifactId&gt;spring-geode-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;</programlisting>
</example>
<simpara>Notice that:</simpara>
<itemizedlist>
<listitem>
<simpara>The Spring Boot application Maven POM (<literal>pom.xml</literal>) contains a <literal>&lt;dependencyManagement&gt;</literal> section that declares
the <literal>org.springframework.geode:spring-geode-bom</literal>.</simpara>
</listitem>
<listitem>
<simpara>None of the <literal>spring-geode-starter[-xyz]</literal> dependencies explicitly specify a <literal>&lt;version&gt;</literal>. The version is managed by
the <literal>spring-geode.version</literal> property, making it easy to switch between versions of SBDG as needed and use it in all
the SBDG modules declared and used in your application Maven POM.</simpara>
</listitem>
</itemizedlist>
<simpara>If you change the version of SBDG, be sure to change the <literal>org.springframework.boot:spring-boot-starter-parent</literal> POM
version to match.  SBDG is always one <literal>major</literal> version behind but matches on <literal>minor</literal> version and <literal>patch</literal> version
(and <literal>version qualifier</literal>&#8201;&#8212;&#8201;<literal>SNAPSHOT</literal>, <literal>M#</literal>, <literal>RC#</literal>, or <literal>RELEASE</literal>, if applicable).</simpara>
<simpara>For example, SBDG <literal>1.4.0</literal> is based on Spring Boot <literal>2.4.0</literal>. SBDG <literal>1.3.5.RELEASE</literal> is based on Spring Boot <literal>2.3.5.RELEASE</literal>,
and so on. It is important that the versions align.</simpara>
<tip>
<simpara>All of these concerns are handled for you by going to <link xl:href="https://start.spring.io">start.spring.io</link>
and adding the <quote><emphasis>Spring for Apache Geode</emphasis></quote> dependency to a project. For convenience, you can click
this <link xl:href="https://start.spring.io/#!platformVersion={spring-boot-version}&amp;dependencies=geode">link</link> to get started.</simpara>
</tip>
</section>
<section xml:id="gradle-dependency-management">
<title>Gradle Dependency Management</title>
<simpara>Using Gradle is similar to using Maven.</simpara>
<simpara>Again, if you declare and use more than one SBDG module in your Spring Boot application (for example,
the <literal>spring-geode-starter</literal> along with the <literal>spring-geode-starter-session</literal> dependency), declaring the <literal>spring-geode-bom</literal>
inside your application Gradle build file helps.</simpara>
<simpara>Your application Gradle build file configuration (roughly) appears as follows:</simpara>
<example>
<title>Spring Boot application Gradle build file</title>
<programlisting language="groovy" linenumbering="unnumbered">plugins {
  id 'org.springframework.boot' version '{spring-boot-version}'
  id 'io.spring.dependency-management' version '1.0.10.RELEASE'
  id 'java'
}

// ...

ext {
  set('springGeodeVersion', "{spring-boot-data-geode-version}")
}

dependencies {
  implementation 'org.springframework.geode:spring-geode-starter'
  implementation 'org.springframework.geode:spring-geode-starter-actuator'
  testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

dependencyManagement {
  imports {
    mavenBom "org.springframework.geode:spring-geode-bom:${springGeodeVersion}"
  }
}</programlisting>
</example>
<simpara>A combination of the <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-gradle">Spring Boot Gradle Plugin</link>
and the <link xl:href="https://github.com/spring-gradle-plugins/dependency-management-plugin">Spring Dependency Management Gradle Plugin</link>
manages the application dependencies for you.</simpara>
<simpara>In a nutshell, the <emphasis>Spring Dependency Management Gradle Plugin</emphasis> provides dependency management capabilities for Gradle,
much like Maven. The <emphasis>Spring Boot Gradle Plugin</emphasis> defines a curated and tested set of versions for many third party Java
libraries. Together, they make adding dependencies and managing (compatible) versions easier.</simpara>
<simpara>Again, you do not need to explicitly declare the version when adding a dependency, including a new SBDG module
dependency (for example, <literal>spring-geode-starter-session</literal>), since this has already been determined for you.
You can declare the dependency as follows:</simpara>
<informalexample>
<programlisting language="groovy" linenumbering="unnumbered">implementation 'org.springframework.geode:spring-geode-starter-session'</programlisting>
</informalexample>
<simpara>The version of SBDG is controlled by the extension property (<literal>springGeodeVersion</literal>) in the application Gradle build file.</simpara>
<simpara>To use a different version of SBDG, set the <literal>springGeodeVersion</literal> property to the desired version (for example,
<literal>1.3.5.RELEASE</literal>). Remember to be sure that the version of Spring Boot matches.</simpara>
<simpara>SBDG is always one <literal>major</literal> version behind but matches on <literal>minor</literal> version and <literal>patch</literal> version (and <literal>version qualifier</literal>,
such as <literal>SNAPSHOT</literal>, <literal>M#</literal>, <literal>RC#</literal>, or <literal>RELEASE</literal>, if applicable). For example, SBDG <literal>1.4.0</literal> is based on Spring Boot <literal>2.4.0</literal>,
SBDG <literal>1.3.5.RELEASE</literal> is based on Spring Boot <literal>2.3.5.RELEASE</literal>, and so on. It is important that the versions align.</simpara>
<tip>
<simpara>All of these concerns are handled for you by going to <link xl:href="https://start.spring.io">start.spring.io</link>
and adding the <quote><emphasis>Spring for Apache Geode</emphasis></quote> dependency to a project. For convenience, you can click
this <link xl:href="https://start.spring.io/#!platformVersion={spring-boot-version}&amp;dependencies=geode">link</link> to get started.</simpara>
</tip>
</section>
</chapter>
<chapter xml:id="sbdg-dependency-versions">
<title>Primary Dependency Versions</title>
<simpara>Spring Boot for Apache Geode {version} builds and depends on the following versions of the base projects
listed below:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Dependencies &amp; Versions</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Java (JRE)</simpara></entry>
<entry align="left" valign="top"><simpara>17</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Apache Geode</simpara></entry>
<entry align="left" valign="top"><simpara>{apache-geode-artifact-version}</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spring Framework</simpara></entry>
<entry align="left" valign="top"><simpara>{spring-version}</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spring Boot</simpara></entry>
<entry align="left" valign="top"><simpara>{spring-boot-version}</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spring Data for Apache Geode</simpara></entry>
<entry align="left" valign="top"><simpara>{spring-data-geode-version}</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spring Session for Apache Geode</simpara></entry>
<entry align="left" valign="top"><simpara>{spring-session-data-geode-version}</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spring Test for Apache Geode</simpara></entry>
<entry align="left" valign="top"><simpara>{spring-test-data-geode-version}</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>It is essential that the versions of all the dependencies listed in the table above align accordingly. If the dependency
versions are misaligned, then functionality could be missing, or certain functions could behave unpredictably
from its specified contract.</simpara>
<simpara>Please follow dependency versions listed in the table above and use it as a guide when setting up
your Spring Boot projects using Apache Geode.</simpara>
<simpara>Again, the best way to setup your Spring Boot projects is by first, declaring the <literal>spring-boot-starter-parent</literal> Maven POM
as the parent POM in your project POM:</simpara>
<example>
<title>Spring Boot application Maven POM parent</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;{spring-boot-version}&lt;/version&gt;
&lt;/parent&gt;</programlisting>
</example>
<simpara>Or, when using Grade:</simpara>
<example>
<title>Spring Boot application Gradle build file Gradle Plugins required for dependency management</title>
<programlisting language="groovy" linenumbering="unnumbered">plugins {
  id 'org.springframework.boot' version '{spring-boot-version}'
  id 'io.spring.dependency-management' version '1.0.10.RELEASE'
  id 'java'
}</programlisting>
</example>
<simpara>And then, use the Spring Boot for Apache Geode, <literal>spring-geode-bom</literal>.  For example, with Maven:</simpara>
<example>
<title>Spring Boot application using the Spring Boot for Apache Geode, <literal>spring-geode-bom</literal> BOM in Maven</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;properties&gt;
    &lt;spring-geode.version&gt;{spring-boot-data-geode-version}&lt;/spring-geode.version&gt;
&lt;/properties&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.geode&lt;/groupId&gt;
            &lt;artifactId&gt;spring-geode-bom&lt;/artifactId&gt;
            &lt;version&gt;${spring-geode.version}&lt;/version&gt;
            &lt;scope&gt;import&lt;/scope&gt;
            &lt;type&gt;pom&lt;/type&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.geode&lt;/groupId&gt;
        &lt;artifactId&gt;spring-geode-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
</example>
<simpara>Or, with Gradle:</simpara>
<example>
<title>Spring Boot application using the Spring Boot for Apache Geode, <literal>spring-geode-bom</literal> BOM in Gradle</title>
<programlisting language="groovy" linenumbering="unnumbered">ext {
    set('springGeodeVersion', "{spring-boot-data-geode-version}")
}

dependencies {
    implementation 'org.springframework.geode:spring-geode-starter'
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.geode:spring-geode-bom:${springGeodeVersion}"
    }
}</programlisting>
</example>
<simpara>All of this is made simple by going to <link xl:href="https://start.spring.io">start.spring.io</link> and creating a Spring Boot
<literal>{spring-boot-version}</literal> project using Apache Geode.</simpara>
<section xml:id="sbdg-dependency-version-overrides">
<title>Overriding Dependency Versions</title>
<simpara>While Spring Boot for Apache Geode requires baseline versions of the <link linkend="sbdg-dependency-versions">primary dependencies</link>
listed above, it is possible, using Spring Boot&#8217;s dependency management capabilities, to override the versions of
3rd-party Java libraries and dependencies managed by Spring Boot itself.</simpara>
<simpara>When your Spring Boot application Maven POM inherits from the <literal>org.springframework.boot:spring-boot-starter-parent</literal>,
or alternatively, applies the Spring Dependency Management Gradle Plugin (<literal>io.spring.dependency-management</literal>) along with
the Spring Boot Gradle Plugin (<literal>org.springframework.boot</literal>) in your Spring Boot application Gradle build file, then you
automatically enable the dependency management capabilities provided by Spring Boot for all 3rd-party Java libraries
and dependencies curated and managed by Spring Boot.</simpara>
<simpara>Spring Boot&#8217;s dependency management harmonizes all 3rd-party Java libraries and dependencies that you are likely to use
in your Spring Boot applications. All these dependencies have been tested and proven to work with the version of Spring
Boot and other Spring dependencies (e.g. Spring Data, Spring Security) you may be using in your Spring Boot applications.</simpara>
<simpara>Still, there may be times when you want, or even need to override the version of some 3rd-party Java libraries used by
your Spring Boot applications, that are specifically managed by Spring Boot. In cases where you know that using a
different version of a managed dependency is safe to do so, then you have a few options for how to override
the dependency version:</simpara>
<warning>
<simpara>Use caution when overriding dependencies since they may not be compatible with other dependencies managed by
Spring Boot for which you may have declared on your application classpath, for example, by adding a starter. It is
common for multiple Java libraries to share the same transitive dependencies but use different versions of the Java
library (e.g. logging). This will often lead to Exceptions thrown at runtime due to API differences. Keep in mind that
Java resolves classes on the classpath from the first class definition that is found in the order that JARs or paths
have been defined on the classpath. Finally, Spring does not support dependency versions that have been overridden
and do not match the versions declared and managed by Spring Boot.
See <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/#appendix.dependency-versions.coordinates">documentation</link>.</simpara>
</warning>
<itemizedlist>
<listitem>
<simpara><xref linkend="sbdg-dependency-version-overrides-property"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="sbdg-dependency-version-overrides-dependencymanagement"/></simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>You should refer to Spring Boot&#8217;s documentation on
<link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.dependency-management">Dependency Management</link> for more details.</simpara>
</tip>
<section xml:id="sbdg-dependency-version-overrides-property">
<title>Version Property Override</title>
<simpara>Perhaps the easiest option to change the version of a Spring Boot managed dependency is to set the version property
used by Spring Boot to control the dependency&#8217;s version to the desired Java library version.</simpara>
<simpara>For example, if you want to use a different version of <emphasis role="strong">Log4j</emphasis> than what is currently set and determined by
Spring Boot, then you would do:</simpara>
<formalpara role="java">
<title>Maven dependency version property override</title>
<para>
<screen linenumbering="unnumbered">&lt;properties&gt;
  &lt;log4j2.version&gt;2.17.2&lt;/log4j2.version&gt;
&lt;/properties&gt;</screen>
</para>
</formalpara>
<formalpara>
<title>Gradle dependency version property override</title>
<para>
<screen>ext['log4j2.version'] = '2.17.2'</screen>
</para>
</formalpara>
<note>
<simpara>The Log4j version number used in the Maven and Gradle examples shown above is arbitrary. You must set
the <literal>log4j2.version</literal> property to a valid Log4j version that would be resolvable by Maven or Gradle when given
the fully qualified artifact: <literal>org.apache.logging.log4j:log4j:2.17.2</literal>.</simpara>
</note>
<simpara>The version property name must precisely match the version property declared in the <literal>spring-boot-dependencies</literal>
Maven POM.</simpara>
<simpara>See Spring Boot&#8217;s documentation on <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/#appendix.dependency-versions.properties">version properties</link>.</simpara>
<simpara>Additional details can be found in the Spring Boot Maven Plugin
<link xl:href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#using.parent-pom">documentation</link>
as well as the Spring Boot Gradle Plugin
<link xl:href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#managing-dependencies">documentation</link>.</simpara>
</section>
<section xml:id="sbdg-dependency-version-overrides-dependencymanagement">
<title>Override with Dependency Management</title>
<simpara>This option is not specific to Spring in general, or Spring Boot in particular, but applies to Maven and Gradle,
which both have intrinsic dependency management features and capabilities.</simpara>
<simpara>This approach is useful to not only control the versions of the dependencies managed by Spring Boot directly, but also
control the versions of dependencies that may be transitively pulled in by the dependencies that are managed by
Spring Boot. Additionally, this approach is more universal since it is handled by Maven or Gradle itself.</simpara>
<simpara>For example, when you declare the <literal>org.springframework.boot:spring-boot-starter-test</literal> dependency in your Spring Boot
application Maven POM or Gradle build file for testing purposes, you will see a dependency tree similar to:</simpara>
<formalpara>
<title><literal>$gradlew dependencies</literal> OR <literal>$mvn dependency:tree</literal></title>
<para>
<programlisting language="text" linenumbering="unnumbered">...
[INFO] +- org.springframework.boot:spring-boot-starter-test:jar:2.6.4:test
[INFO] |  +- org.springframework.boot:spring-boot-test:jar:2.6.4:test
[INFO] |  +- org.springframework.boot:spring-boot-test-autoconfigure:jar:2.6.4:test
[INFO] |  +- com.jayway.jsonpath:json-path:jar:2.6.0:test
[INFO] |  |  +- net.minidev:json-smart:jar:2.4.8:test
[INFO] |  |  |  \- net.minidev:accessors-smart:jar:2.4.8:test
[INFO] |  |  |     \- org.ow2.asm:asm:jar:9.1:test
[INFO] |  |  \- org.slf4j:slf4j-api:jar:1.7.36:compile
[INFO] |  +- jakarta.xml.bind:jakarta.xml.bind-api:jar:2.3.3:test
[INFO] |  |  \- jakarta.activation:jakarta.activation-api:jar:1.2.2:test
[INFO] |  +- org.assertj:assertj-core:jar:3.21.0:compile
[INFO] |  +- org.hamcrest:hamcrest:jar:2.2:compile
[INFO] |  +- org.junit.jupiter:junit-jupiter:jar:5.8.2:test
[INFO] |  |  +- org.junit.jupiter:junit-jupiter-api:jar:5.8.2:test
[INFO] |  |  |  +- org.opentest4j:opentest4j:jar:1.2.0:test
[INFO] |  |  |  +- org.junit.platform:junit-platform-commons:jar:1.8.2:test
[INFO] |  |  |  \- org.apiguardian:apiguardian-api:jar:1.1.2:test
[INFO] |  |  +- org.junit.jupiter:junit-jupiter-params:jar:5.8.2:test
[INFO] |  |  \- org.junit.jupiter:junit-jupiter-engine:jar:5.8.2:test
[INFO] |  |     \- org.junit.platform:junit-platform-engine:jar:1.8.2:test
...</programlisting>
</para>
</formalpara>
<simpara>If you wanted to override and control the version of the <literal>opentest4j</literal> transitive dependency, for whatever reason,
perhaps because you are using the <literal>opentest4j</literal> API directly in your application tests, then you could add dependency
management in either Maven or Gradle to control the <literal>opentest4j</literal> dependency version.</simpara>
<note>
<simpara>The <literal>opentest4j</literal> dependency is pulled in by JUnit and is not a dependency that Spring Boot specifically manages.
Of course, Maven or Gradle&#8217;s dependency management capabilities can be used to override dependencies that are managed
by Spring Boot as well.</simpara>
</note>
<simpara>Using the <literal>opentest4j</literal> dependency as an example, you can override the dependency version by doing the following:</simpara>
<formalpara>
<title>Maven dependency version override</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;project&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.opentest4j&lt;/groupId&gt;
                &lt;artifactId&gt;opentest4j&lt;/artifactId&gt;
                &lt;version&gt;1.0.0&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

&lt;/project&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Gradle dependency version override</title>
<para>
<programlisting language="grooy" linenumbering="unnumbered">plugins {
	id 'org.springframework.boot' version '{spring-boot-version}'
}

apply plugin:  'io.spring.dependency-management'

dependencyManagement {
  dependencies {
    dependency 'org.opentest4j:openttest4j:1.0.0'
  }
}</programlisting>
</para>
</formalpara>
<simpara>After applying Maven or Gradle dependency management configuration, you will then see:</simpara>
<formalpara>
<title><literal>$gradlew dependencies</literal> OR <literal>$mvn dependency:tree</literal></title>
<para>
<programlisting language="text" linenumbering="unnumbered">...
[INFO] +- org.springframework.boot:spring-boot-starter-test:jar:2.6.4:test
...
[INFO] |  |  |  +- org.opentest4j:opentest4j:jar:1.0.0:test
...</programlisting>
</para>
</formalpara>
<simpara>For more details on Maven dependency management, refer to
the <link xl:href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">documentation</link>.</simpara>
<simpara>For more details on Gradle dependency management, please refer to
the <link xl:href="https://docs.gradle.org/current/userguide/core_dependency_management.html">documentation</link></simpara>
</section>
</section>
<section xml:id="sbdg-dependency-exclusions">
<title>Excluding Dependencies</title>
<simpara>Sometimes, though rarely, it may be necessary to exclude a (transitive) dependency included by a Spring Boot,
or Spring Boot for Apache Geode, starter.</simpara>
<simpara>Perhaps a transitive dependency, such as Apache Log4j or Jackson, is pulled in by an underlying data store dependency,
such as Apache Geode or Redis, when using a starter (for example: <literal>spring-boot-starter-data-redis</literal>, or <literal>spring-geode-starter</literal>),
that could cause a conflict with your Spring Boot application. Or, maybe the transitive dependency currently contains
a serious bug or CVE.</simpara>
<simpara>Either way, you have concluded that it is safe to exclude this (transitive) dependency without adversely affecting
the runtime behavior and correctness of your Spring Boot application.</simpara>
<warning>
<simpara>You should be absolutely certain that removing the (transitive) dependency, rather than <link linkend="sbdg-dependency-version-overrides">overridding</link>
the (transitive) dependency is the correct course of action.</simpara>
</warning>
<simpara>For example, when you include the <literal>spring-geode-starter</literal> (the base starter of Spring Boot for Apache Geode), you notice
that Apache Lucene is transitively included by <literal>org.apache.geode:geode-lucene</literal>:</simpara>
<formalpara>
<title>Analyzing Dependencies using Gradle</title>
<para>
<programlisting language="text" linenumbering="unnumbered">$ gradlew :spring-geode-starter:dependencies

...
compileClasspath - Compile classpath for source set 'main'.
+--- org.springframework.boot:spring-boot-starter -&gt; 3.0.0-M5
|    +--- org.springframework.boot:spring-boot:3.0.0-M5
|    |    +--- org.springframework:spring-core:6.0.0-M6
...
+--- project :spring-geode
|    +--- project :apache-geode-extensions
|    |    +--- org.apache.geode:geode-core:1.15.0
|    |    |    +--- antlr:antlr:2.7.7
...
|    |    +--- org.apache.geode:geode-lucene:1.15.0
|    |    |    +--- org.apache.geode:geode-core:1.15.0 (*)
|    |    |    \--- org.apache.lucene:lucene-core:6.6.6
...
|    |    \--- org.apache.geode:geode-wan:1.15.0
...</programlisting>
</para>
</formalpara>
<formalpara>
<title>Analyzing Dependencies using Maven</title>
<para>
<programlisting language="txt" linenumbering="unnumbered">$ mvn dependency:tree

...
[INFO] --- maven-dependency-plugin:3.3.0:tree (default-cli) @ spring-geode-app ---
[INFO] org.example.app:spring-geode-app:jar:0.0.1-SNAPSHOT
[INFO] +- org.springframework.geode:spring-geode-starter:jar:1.7.4:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter:jar:2.7.1:compile
[INFO] |  |  +- org.springframework.boot:spring-boot:jar:2.7.1:compile
...
[INFO] |  +- org.springframework.geode:spring-geode:jar:1.7.4:compile
[INFO] |  |  +- org.springframework.data:spring-data-geode:jar:2.7.1:compile
[INFO] |  |  |  +- org.apache.geode:geode-core:jar:1.14.4:compile
...
[INFO] |  |  |  +- org.apache.geode:geode-lucene:jar:1.14.4:compile
[INFO] |  |  |  |  +- org.apache.lucene:lucene-core:jar:6.6.6:compile
[INFO] |  |  |  |  +- org.apache.geode:geode-gfsh:jar:1.14.4:runtime
[INFO] |  |  |  |  +- org.apache.lucene:lucene-analyzers-common:jar:6.6.6:runtime
[INFO] |  |  |  |  +- org.apache.lucene:lucene-queryparser:jar:6.6.6:runtime
[INFO] |  |  |  |  |  \- org.apache.lucene:lucene-queries:jar:6.6.6:runtime
[INFO] |  |  |  |  +- mx4j:mx4j:jar:3.0.2:runtime
[INFO] |  |  |  |  \- org.apache.lucene:lucene-analyzers-phonetic:jar:6.6.6:runtime
[INFO] |  |  |  |     \- commons-codec:commons-codec:jar:1.15:runtime
...
[INFO] |  |  |  +- org.apache.geode:geode-wan:jar:1.14.4:compile</programlisting>
</para>
</formalpara>
<simpara>However, you do not have any "search" use cases in your Spring Boot application that would require Apache Geode&#8217;s
integration with Apache Lucene.</simpara>
<simpara>Using your build tool, such as Gradle or Maven, you can add an exclusion on the <literal>org.apache.geode:geode-lucene</literal>
transitive dependency pulled in and included by Spring Boot for Apache Geode&#8217;s <literal>spring-geode-starter</literal>, like so:</simpara>
<formalpara>
<title>Declaring Exclusions with Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">implementation("org.springframework.geode:spring-geode-starter:{version}") {
  exclude group: "org.apache.geode", module: "geode-lucene"
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Declaring Exclusions with Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;pom&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.geode&lt;/groupId&gt;
      &lt;artifactId&gt;spring-geode-starter&lt;/artifactId&gt;
      &lt;version&gt;{version}&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;org.apache.geode&lt;/groupId&gt;
          &lt;artifactId&gt;geode-lucene&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/pom&gt;</programlisting>
</para>
</formalpara>
<simpara>After the appropriate exclusion is declared, the resulting dependencies (or dependency tree) should look like
the following:</simpara>
<formalpara>
<title>Analyzing Dependencies using Gradle after Exclusions</title>
<para>
<programlisting language="text" linenumbering="unnumbered">$ gradlew :spring-geode-starter:dependencies

...
compileClasspath - Compile classpath for source set 'main'.
+--- org.springframework.boot:spring-boot-starter -&gt; 3.0.0-M5
|    +--- org.springframework.boot:spring-boot:3.0.0-M5
|    |    +--- org.springframework:spring-core:6.0.0-M6
...
+--- project :spring-geode
|    +--- project :apache-geode-extensions
|    |    +--- org.apache.geode:geode-core:1.15.0
|    |    |    +--- antlr:antlr:2.7.7
...
|    |    \--- org.apache.geode:geode-wan:1.15.0
...</programlisting>
</para>
</formalpara>
<formalpara>
<title>Analyzing Dependencies using Maven</title>
<para>
<programlisting language="txt" linenumbering="unnumbered">$ mvn dependency:tree

...
[INFO] --- maven-dependency-plugin:3.3.0:tree (default-cli) @ spring-geode-app ---
[INFO] org.example.app:spring-geode-app:jar:0.0.1-SNAPSHOT
[INFO] +- org.springframework.geode:spring-geode-starter:jar:1.7.4:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter:jar:2.7.1:compile
[INFO] |  |  +- org.springframework.boot:spring-boot:jar:2.7.1:compile
...
[INFO] |  +- org.springframework.geode:spring-geode:jar:1.7.4:compile
[INFO] |  |  +- org.springframework.data:spring-data-geode:jar:2.7.1:compile
[INFO] |  |  |  +- org.apache.geode:geode-core:jar:1.14.4:compile
...
[INFO] |  |  |  +- org.apache.geode:geode-wan:jar:1.14.4:compile</programlisting>
</para>
</formalpara>
<simpara>Again, it cannot be overstated the importance of being careful when declaring exclusions.</simpara>
<tip>
<simpara>Please refer to the appropriate documentation in
<link xl:href="https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html">Maven</link>
and <link xl:href="https://docs.gradle.org/current/userguide/dependency_downgrade_and_exclude.html">Gradle</link> to declare exclusions.</simpara>
</tip>
</section>
</chapter>
<chapter xml:id="geode-clientcache-applications">
<title>Building <literal>ClientCache</literal> Applications</title>
<simpara>The first opinionated option provided to you by Spring Boot for Apache Geode (SBDG) is a
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/client/ClientCache.html"><literal>ClientCache</literal></link> instance
that you get by declaring Spring Boot for Apache Geode on your application classpath.</simpara>
<simpara>It is assumed that most application developers who use Spring Boot to build applications backed by Apache Geode
are building cache client applications deployed in an Apache Geode
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/topologies_and_comm/cs_configuration/chapter_overview.html">Client/Server Topology</link>.
The client/server topology is the most common and traditional architecture employed by enterprise applications
that use Apache Geode.</simpara>
<simpara>For example, you can begin building a Spring Boot Apache Geode <literal>ClientCache</literal> application by declaring the
<literal>spring-geode-starter</literal> on your application&#8217;s classpath:</simpara>
<example>
<title>Spring Boot for Apache Geode on the application classpath</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.geode&lt;/groupId&gt;
  &lt;artifactId&gt;spring-geode-starter&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting>
</example>
<simpara>Then you configure and bootstrap your Spring Boot, Apache Geode <literal>ClientCache</literal> application with the following
main application class:</simpara>
<example>
<title>Spring Boot, Apache Geode <literal>ClientCache</literal> Application</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
public class SpringBootApacheGeodeClientCacheApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootApacheGeodeClientCacheApplication.class, args);
    }
}</programlisting>
</example>
<simpara>Your application now has a <literal>ClientCache</literal> instance that can connect to an Apache Geode server running on <literal>localhost</literal>
and listening on the default <literal>CacheServer</literal> port, <literal>40404</literal>.</simpara>
<simpara>By default, an Apache Geode server (that is, <literal>CacheServer</literal>) must be running for the application to use the <literal>ClientCache</literal>
instance. However, it is perfectly valid to create a <literal>ClientCache</literal> instance and perform data access operations by using
<literal>LOCAL</literal> Regions. This is useful during development.</simpara>
<tip>
<simpara>To develop with <literal>LOCAL</literal> Regions, configure your cache Regions with the
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/client/ClientRegionShortcut.html#LOCAL"><literal>ClientRegionShortcut.LOCAL</literal></link>
data management policy.</simpara>
</tip>
<simpara>When you are ready to switch from your local development environment (IDE) to a client/server architecture in a managed
environment, change the data management policy of the client Region from <literal>LOCAL</literal> back to the default (<literal>PROXY</literal>)
or even a <literal>CACHING_PROXY</literal>, which causes the data to be sent to and received from one or more servers.</simpara>
<tip>
<simpara>Compare and contrast the preceding configuration with the Spring Data for Apache Geode
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-geode-applications">approach</link>.</simpara>
</tip>
<simpara>It is uncommon to ever need a direct reference to the <literal>ClientCache</literal> instance provided by SBDG injected into your
application components (for example, <literal>@Service</literal> or <literal>@Repository</literal> beans defined in a Spring <literal>ApplicationContext</literal>),
whether you are configuring additional Apache Geode objects (Regions, Indexes, and so on) or are using those objects
indirectly in your applications. However, it is possible to do so if and when needed.</simpara>
<simpara>For example, perhaps you want to perform some additional <literal>ClientCache</literal> initialization in a Spring Boot
<link xl:href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/ApplicationRunner.html"><literal>ApplicationRunner</literal></link> on startup:</simpara>
<example>
<title>Injecting a <literal>GemFireCache</literal> reference</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
public class SpringBootApacheGeodeClientCacheApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootApacheGeodeClientCacheApplication.class, args);
    }

    @Bean
    ApplicationRunner runAdditionalClientCacheInitialization(GemFireCache gemfireCache) {

        return args -&gt; {

            ClientCache clientCache = (ClientCache) gemfireCache;

            // perform additional ClientCache initialization as needed
        };
    }
}</programlisting>
</example>
<section xml:id="geode-peercache-applications">
<title>Building Embedded (Peer &amp; Server) Cache Applications</title>
<simpara>What if you want to build an embedded peer <literal>Cache</literal> application instead?</simpara>
<simpara>Perhaps you need an actual peer cache member, configured and bootstrapped with Spring Boot, along with the ability
to join this member to an existing cluster (of data servers) as a peer node.</simpara>
<simpara>Remember the second goal in Spring Boot&#8217;s <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/#getting-started-introducing-spring-boot">documentation</link>:</simpara>
<blockquote>
<simpara>Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults.</simpara>
</blockquote>
<simpara>Here, we focus on the second part of the goal: "<emphasis>get out of the way quickly as requirements start to diverge
from the defaults</emphasis>".</simpara>
<simpara>If your application requirements demand you use Spring Boot to configure and bootstrap an embedded peer <literal>Cache</literal> instance,
declare your intention with either SDG&#8217;s
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/PeerCacheApplication.html"><literal>@PeerCacheApplication</literal></link> annotation,
or, if you also need to enable connections from <literal>ClientCache</literal> applications, use SDG&#8217;s
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html"><literal>@CacheServerApplication</literal></link> annotation:</simpara>
<example>
<title>Spring Boot, Apache Geode <literal>CacheServer</literal> Application</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@CacheServerApplication(name = "SpringBootApacheGeodeCacheServerApplication")
public class SpringBootApacheGeodeCacheServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootApacheGeodeCacheServerApplication.class, args);
    }
}</programlisting>
</example>
<tip>
<simpara>An Apache Geode server is not necessarily a <literal>CacheServer</literal> capable of serving cache clients. It is merely a peer
member node in an Apache Geode cluster (that is, a distributed system) that stores and manages data.</simpara>
</tip>
<simpara>By explicitly declaring the <literal>@CacheServerApplication</literal> annotation, you tell Spring Boot that you do not want the default
<literal>ClientCache</literal> instance but rather want an embedded peer <literal>Cache</literal> instance with a <literal>CacheServer</literal> component, which enables
connections from <literal>ClientCache</literal> applications.</simpara>
<simpara>You can also enable two other Apache Geode services:
* An embedded <emphasis>Locator</emphasis>, which allows clients or even other peers to locate servers in the cluster.
* An embedded <emphasis>Manager</emphasis>, which allows the Apache Geode application process to be managed and monitored by using
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/tools_modules/gfsh/chapter_overview.html">Gfsh</link>, Apache Geode&#8217;s command-line shell tool:</simpara>
<example>
<title>Spring Boot Apache Geode <literal>CacheServer</literal> Application with <emphasis>Locator</emphasis> and <emphasis>Manager</emphasis> services enabled</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@CacheServerApplication(name = "SpringBootApacheGeodeCacheServerApplication")
@EnableLocator
@EnableManager
public class SpringBootApacheGeodeCacheServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootApacheGeodeCacheServerApplication.class, args);
    }
}</programlisting>
</example>
<simpara>Then you can use Gfsh to connect to and manage this server:</simpara>
<informalexample>
<programlisting language="text" linenumbering="unnumbered">$ echo $GEMFIRE
/Users/jblum/pivdev/apache-geode-1.2.1

$ gfsh
    _________________________     __
   / _____/ ______/ ______/ /____/ /
  / /  __/ /___  /_____  / _____  /
 / /__/ / ____/  _____/ / /    / /
/______/_/      /______/_/    /_/    1.2.1

Monitor and Manage Apache Geode

gfsh&gt;connect
Connecting to Locator at [host=localhost, port=10334] ..
Connecting to Manager at [host=10.0.0.121, port=1099] ..
Successfully connected to: [host=10.0.0.121, port=1099]


gfsh&gt;list members
                   Name                     | Id
------------------------------------------- | --------------------------------------------------------------------------
SpringBootApacheGeodeCacheServerApplication | 10.0.0.121(SpringBootApacheGeodeCacheServerApplication:29798)&lt;ec&gt;&lt;v0&gt;:1024


gfsh&gt;describe member --name=SpringBootApacheGeodeCacheServerApplication
Name        : SpringBootApacheGeodeCacheServerApplication
Id          : 10.0.0.121(SpringBootApacheGeodeCacheServerApplication:29798)&lt;ec&gt;&lt;v0&gt;:1024
Host        : 10.0.0.121
Regions     :
PID         : 29798
Groups      :
Used Heap   : 168M
Max Heap    : 3641M
Working Dir : /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build
Log file    : /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build
Locators    : localhost[10334]

Cache Server Information
Server Bind              :
Server Port              : 40404
Running                  : true
Client Connections       : 0</programlisting>
</informalexample>
<simpara>You can even start additional servers in Gfsh. These additional servers connect to your Spring Boot configured
and bootstrapped  Apache Geode <literal>CacheServer</literal> application. These additional servers started in Gfsh know about
the Spring Boot, Apache Geode server because of the embedded Locator service, which is running on <literal>localhost</literal>
and listening on the default Locator port, <literal>10334</literal>:</simpara>
<informalexample>
<programlisting language="text" linenumbering="unnumbered">gfsh&gt;start server --name=GfshServer --log-level=config --disable-default-server
Starting a Geode Server in /Users/jblum/pivdev/lab/GfshServer...
...
Server in /Users/jblum/pivdev/lab/GfshServer on 10.0.0.121 as GfshServer is currently online.
Process ID: 30031
Uptime: 3 seconds
Geode Version: 1.2.1
Java Version: 1.8.0_152
Log File: /Users/jblum/pivdev/lab/GfshServer/GfshServer.log
JVM Arguments: -Dgemfire.default.locators=10.0.0.121:127.0.0.1[10334] -Dgemfire.use-cluster-configuration=true -Dgemfire.start-dev-rest-api=false -Dgemfire.log-level=config -XX:OnOutOfMemoryError=kill -KILL %p -Dgemfire.launcher.registerSignalHandlers=true -Djava.awt.headless=true -Dsun.rmi.dgc.server.gcInterval=9223372036854775806
Class-Path: /Users/jblum/pivdev/apache-geode-1.2.1/lib/geode-core-1.2.1.jar:/Users/jblum/pivdev/apache-geode-1.2.1/lib/geode-dependencies.jar


gfsh&gt;list members
                   Name                     | Id
------------------------------------------- | --------------------------------------------------------------------------
SpringBootApacheGeodeCacheServerApplication | 10.0.0.121(SpringBootApacheGeodeCacheServerApplication:29798)&lt;ec&gt;&lt;v0&gt;:1024
GfshServer                                  | 10.0.0.121(GfshServer:30031)&lt;v1&gt;:1025</programlisting>
</informalexample>
<simpara>Perhaps you want to start the other way around. You may need to connect a Spring Boot configured and bootstrapped
Apache Geode server application to an existing cluster. You can start the cluster in Gfsh with the following commands
(shown with partial typical output):</simpara>
<informalexample>
<programlisting language="text" linenumbering="unnumbered">gfsh&gt;start locator --name=GfshLocator --port=11235 --log-level=config
Starting a Geode Locator in /Users/jblum/pivdev/lab/GfshLocator...
...
Locator in /Users/jblum/pivdev/lab/GfshLocator on 10.0.0.121[11235] as GfshLocator is currently online.
Process ID: 30245
Uptime: 3 seconds
Geode Version: 1.2.1
Java Version: 1.8.0_152
Log File: /Users/jblum/pivdev/lab/GfshLocator/GfshLocator.log
JVM Arguments: -Dgemfire.log-level=config -Dgemfire.enable-cluster-configuration=true -Dgemfire.load-cluster-configuration-from-dir=false -Dgemfire.launcher.registerSignalHandlers=true -Djava.awt.headless=true -Dsun.rmi.dgc.server.gcInterval=9223372036854775806
Class-Path: /Users/jblum/pivdev/apache-geode-1.2.1/lib/geode-core-1.2.1.jar:/Users/jblum/pivdev/apache-geode-1.2.1/lib/geode-dependencies.jar

Successfully connected to: JMX Manager [host=10.0.0.121, port=1099]

Cluster configuration service is up and running.


gfsh&gt;start server --name=GfshServer --log-level=config --disable-default-server
Starting a Geode Server in /Users/jblum/pivdev/lab/GfshServer...
....
Server in /Users/jblum/pivdev/lab/GfshServer on 10.0.0.121 as GfshServer is currently online.
Process ID: 30270
Uptime: 4 seconds
Geode Version: 1.2.1
Java Version: 1.8.0_152
Log File: /Users/jblum/pivdev/lab/GfshServer/GfshServer.log
JVM Arguments: -Dgemfire.default.locators=10.0.0.121[11235] -Dgemfire.use-cluster-configuration=true -Dgemfire.start-dev-rest-api=false -Dgemfire.log-level=config -XX:OnOutOfMemoryError=kill -KILL %p -Dgemfire.launcher.registerSignalHandlers=true -Djava.awt.headless=true -Dsun.rmi.dgc.server.gcInterval=9223372036854775806
Class-Path: /Users/jblum/pivdev/apache-geode-1.2.1/lib/geode-core-1.2.1.jar:/Users/jblum/pivdev/apache-geode-1.2.1/lib/geode-dependencies.jar


gfsh&gt;list members
   Name     | Id
----------- | --------------------------------------------------
GfshLocator | 10.0.0.121(GfshLocator:30245:locator)&lt;ec&gt;&lt;v0&gt;:1024
GfshServer  | 10.0.0.121(GfshServer:30270)&lt;v1&gt;:1025</programlisting>
</informalexample>
<simpara>Then modify the <literal>SpringBootApacheGeodeCacheServerApplication</literal> class to connect to the existing cluster:</simpara>
<example>
<title>Spring Boot Apache Geode <literal>CacheServer</literal> Application connecting to an external cluster</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@CacheServerApplication(name = "SpringBootApacheGeodeCacheServerApplication", locators = "localhost[11235]")
public class SpringBootApacheGeodeCacheServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootApacheGeodeClientCacheApplication.class, args);
    }
}</programlisting>
</example>
<tip>
<simpara>Notice that the <literal>SpringBootApacheGeodeCacheServerApplication</literal> class, <literal>@CacheServerApplication</literal> annotation&#8217;s
<literal>locators</literal> property are configured with the host and port (<literal>localhost[11235]</literal>), on which the Locator was started
by using Gfsh.</simpara>
</tip>
<simpara>After running your Spring Boot Apache Geode <literal>CacheServer</literal> application again and executing the <literal>list members</literal> command
in Gfsh again, you should see output similar to the following:</simpara>
<informalexample>
<programlisting language="text" linenumbering="unnumbered">gfsh&gt;list members
                   Name                     | Id
------------------------------------------- | ----------------------------------------------------------------------
GfshLocator                                 | 10.0.0.121(GfshLocator:30245:locator)&lt;ec&gt;&lt;v0&gt;:1024
GfshServer                                  | 10.0.0.121(GfshServer:30270)&lt;v1&gt;:1025
SpringBootApacheGeodeCacheServerApplication | 10.0.0.121(SpringBootApacheGeodeCacheServerApplication:30279)&lt;v2&gt;:1026


gfsh&gt;describe member --name=SpringBootApacheGeodeCacheServerApplication
Name        : SpringBootApacheGeodeCacheServerApplication
Id          : 10.0.0.121(SpringBootApacheGeodeCacheServerApplication:30279)&lt;v2&gt;:1026
Host        : 10.0.0.121
Regions     :
PID         : 30279
Groups      :
Used Heap   : 165M
Max Heap    : 3641M
Working Dir : /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build
Log file    : /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build
Locators    : localhost[11235]

Cache Server Information
Server Bind              :
Server Port              : 40404
Running                  : true
Client Connections       : 0</programlisting>
</informalexample>
<simpara>In both scenarios, the Spring Boot configured and bootstrapped Apache Geode server, the Gfsh Locator and Gfsh server
formed a cluster.</simpara>
<simpara>While you can use either approach and Spring does not care, it is far more convenient to use Spring Boot and your IDE
to form a small cluster while developing. Spring profiles make it far simpler and much faster to configure and start
a small cluster.</simpara>
<simpara>Also, this approach enables rapidly prototyping, testing, and debugging your entire end-to-end application
and system architecture right from the comfort and familiarity of your IDE. No additional tooling (such as Gfsh)
or knowledge is required to get started quickly and easily. Just build and run.</simpara>
<tip>
<simpara>Be careful to vary your port numbers for the embedded services, like the <literal>CacheServer</literal>, Locators, and the Manager,
especially if you start multiple instances on the same machine. Otherwise, you are likely to run into
a <literal>java.net.BindException</literal> caused by port conflicts.</simpara>
</tip>
<tip>
<simpara>See the <xref linkend="geode-cluster-configuration-bootstrapping"/> appendix for more details.</simpara>
</tip>
</section>
<section xml:id="geode-locator-applications">
<title>Building Locator Applications</title>
<simpara>In addition to <literal>ClientCache</literal>, <literal>CacheServer</literal>, and peer <literal>Cache</literal> applications, SDG, and by extension SBDG, now supports
Spring Boot Apache Geode Locator applications.</simpara>
<simpara>An Apache Geode Locator is a location-based service or, more typically, a standalone process that lets clients locate
a cluster of Apache Geode servers to manage data. Many cache clients can connect to the same cluster to share data.
Running multiple clients is common in a Microservices architecture where you need to scale-up the number of application
instances to satisfy the demand.</simpara>
<simpara>An Apache Geode Locator is also used by joining members of an existing cluster to scale-out and increase capacity of
the logically pooled system resources (memory, CPU, network and disk). A Locator maintains metadata that is sent to
the clients to enable such capabilities as single-hop data access to route data access operations to the data node
in the cluster maintaining the data of interests. A Locator also maintains load information for servers in the cluster,
which enables the load to be uniformly distributed across the cluster while also providing fail-over services to a
redundant member if the primary fails. A Locator provides many more benefits, and we encourage you to read the
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/configuring/running/running_the_locator.html">documentation</link> for more details.</simpara>
<simpara>As shown earlier, you can embed a Locator service within either a Spring Boot peer <literal>Cache</literal> or a <literal>CacheServer</literal>
application by using the SDG <literal>@EnableLocator</literal> annotation:</simpara>
<example>
<title>Embedded Locator Service</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@CacheServerApplication
@EnableLocator
class SpringBootCacheServerWithEmbeddedLocatorApplication {
	// ...
}</programlisting>
</example>
<simpara>However, it is more common to start standalone Locator JVM processes. This is useful when you want to increase the
resiliency of your cluster in the face of network and process failures, which are bound to happen. If a Locator JVM
process crashes or gets severed from the cluster due to a network failure or partition, having multiple Locators
provides a higher degree of availability (HA) through redundancy.</simpara>
<simpara>Even if all Locators in the cluster go down, the cluster still remains intact. You cannot add more peer members
(that is, scale-up the number of data nodes in the cluster) or connect any more clients, but the cluster is fine.
If all the locators in the cluster go down, it is safe to restart them only after a thorough diagnosis.</simpara>
<note>
<simpara>Once a client receives metadata about the cluster of servers, all data-access operations are sent directly to
servers in the cluster, not a Locator. Therefore, existing, connected clients remain connected and operable.</simpara>
</note>
<simpara>To configure and bootstrap Spring Boot Apache Geode Locator applications as standalone JVM processes, use the following
configuration:</simpara>
<example>
<title>Standalone Locator Process</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@LocatorApplication
class SpringBootApacheGeodeLocatorApplication {
	// ...
}</programlisting>
</example>
<simpara>Instead of using the <literal>@EnableLocator</literal> annotation, you now use the <literal>@LocatorApplication</literal> annotation.</simpara>
<simpara>The <literal>@LocatorApplication</literal> annotation works in the same way as the <literal>@PeerCacheApplication</literal> and <literal>@CacheServerApplication</literal>
annotations, bootstrapping an Apache Geode process and overriding the default <literal>ClientCache</literal> instance provided by SBDG.</simpara>
<note>
<simpara>If your <literal>@SpringBootApplication</literal> class is annotated with <literal>@LocatorApplication</literal>, it must be a <literal>Locator</literal> and not
a <literal>ClientCache</literal>, <literal>CacheServer</literal>, or peer <literal>Cache</literal> application.  If you need the application to function as a peer <literal>Cache</literal>,
perhaps with embedded <literal>CacheServer</literal> components and an embedded Locator, you need to follow the approach shown earlier:
using the <literal>@EnableLocator</literal> annotation with either the <literal>@PeerCacheApplication</literal> or <literal>@CacheServerApplication</literal> annotation.</simpara>
</note>
<simpara>With our Spring Boot Apache Geode Locator application, we can connect both Spring Boot configured and bootstrapped
peer members (peer <literal>Cache</literal>, <literal>CacheServer</literal> and <literal>Locator</literal> applications) as well as Gfsh started Locators and servers.</simpara>
<simpara>First, we need to start two Locators by using our Spring Boot Apache Geode Locator application class:</simpara>
<example>
<title>SpringBootApacheGeodeLocatorApplication class</title>
<programlisting language="java" linenumbering="unnumbered">@UseLocators
@SpringBootApplication
@LocatorApplication(name = "SpringBootApacheGeodeLocatorApplication")
public class SpringBootApacheGeodeLocatorApplication {

	public static void main(String[] args) {

		new SpringApplicationBuilder(SpringBootApacheGeodeLocatorApplication.class)
			.web(WebApplicationType.NONE)
			.build()
			.run(args);

		System.err.println("Press &lt;enter&gt; to exit!");

		new Scanner(System.in).nextLine();
	}

	@Configuration
	@EnableManager(start = true)
	@Profile("manager")
	@SuppressWarnings("unused")
	static class ManagerConfiguration { }

}</programlisting>
</example>
<simpara>We also need to vary the configuration for each Locator application instance.</simpara>
<simpara>Apache Geode requires each peer member in the cluster to be uniquely named. We can set the name of the Locator by using
the <literal>spring.data.gemfire.locator.name</literal> SDG property set as a JVM System Property in your IDE&#8217;s run configuration profile
for the main application class: <literal>-Dspring.data.gemfire.locator.name=SpringLocatorOne</literal>. We name the second Locator
application instance <literal>SpringLocatorTwo</literal>.</simpara>
<simpara>Additionally, we must vary the port numbers that the Locators use to listen for connections. By default, an Apache Geode
Locator listens on port <literal>10334</literal>. We can set the Locator port by using the <literal>spring.data.gemfire.locator.port</literal>
SDG property.</simpara>
<simpara>For our first Locator application instance (<literal>SpringLocatorOne</literal>), we also enable the "manager" profile so that
we can connect to the Locator by using Gfsh.</simpara>
<simpara>Our IDE run configuration profile for our first Locator application instance appears as:</simpara>
<simpara><literal>-server -ea -Dspring.profiles.active=manager -Dspring.data.gemfire.locator.name=SpringLocatorOne -Dlogback.log.level=INFO</literal></simpara>
<simpara>And our IDE run configuration profile for our second Locator application instance appears as:</simpara>
<simpara><literal>-server -ea -Dspring.profiles.active= -Dspring.data.gemfire.locator.name=SpringLocatorTwo -Dspring.data.gemfire.locator.port=11235 -Dlogback.log.level=INFO</literal></simpara>
<simpara>You should see log output similar to the following when you start a Locator application instance:</simpara>
<example>
<title>Spring Boot Apache Geode Locator log output</title>
<programlisting language="txt" linenumbering="unnumbered">  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::  (v2.2.0.BUILD-SNAPSHOT)

2019-09-01 11:02:48,707  INFO .SpringBootApacheGeodeLocatorApplication:  55 - Starting SpringBootApacheGeodeLocatorApplication on jblum-mbpro-2.local with PID 30077 (/Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/out/production/classes started by jblum in /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build)
2019-09-01 11:02:48,711  INFO .SpringBootApacheGeodeLocatorApplication: 651 - No active profile set, falling back to default profiles: default
2019-09-01 11:02:49,374  INFO xt.annotation.ConfigurationClassEnhancer: 355 - @Bean method LocatorApplicationConfiguration.exclusiveLocatorApplicationBeanFactoryPostProcessor is non-static and returns an object assignable to Spring's BeanFactoryPostProcessor interface. This will result in a failure to process annotations such as @Autowired, @Resource and @PostConstruct within the method's declaring @Configuration class. Add the 'static' modifier to this method to avoid these container lifecycle issues; see @Bean javadoc for complete details.
2019-09-01 11:02:49,919  INFO ode.distributed.internal.InternalLocator: 530 - Starting peer location for Distribution Locator on 10.99.199.24[11235]
2019-09-01 11:02:49,925  INFO ode.distributed.internal.InternalLocator: 498 - Starting Distribution Locator on 10.99.199.24[11235]
2019-09-01 11:02:49,926  INFO distributed.internal.tcpserver.TcpServer: 242 - Locator was created at Sun Sep 01 11:02:49 PDT 2019
2019-09-01 11:02:49,927  INFO distributed.internal.tcpserver.TcpServer: 243 - Listening on port 11235 bound on address 0.0.0.0/0.0.0.0
2019-09-01 11:02:49,928  INFO ternal.membership.gms.locator.GMSLocator: 162 - GemFire peer location service starting.  Other locators: localhost[10334]  Locators preferred as coordinators: true  Network partition detection enabled: true  View persistence file: /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build/locator11235view.dat
2019-09-01 11:02:49,928  INFO ternal.membership.gms.locator.GMSLocator: 416 - Peer locator attempting to recover from localhost/127.0.0.1:10334
2019-09-01 11:02:49,963  INFO ternal.membership.gms.locator.GMSLocator: 422 - Peer locator recovered initial membership of View[10.99.199.24(SpringLocatorOne:30043:locator)&lt;ec&gt;&lt;v0&gt;:41000|0] members: [10.99.199.24(SpringLocatorOne:30043:locator)&lt;ec&gt;&lt;v0&gt;:41000]
2019-09-01 11:02:49,963  INFO ternal.membership.gms.locator.GMSLocator: 407 - Peer locator recovered state from LocatorAddress [socketInetAddress=localhost/127.0.0.1:10334, hostname=localhost, isIpString=false]
2019-09-01 11:02:49,965  INFO ode.distributed.internal.InternalLocator: 644 - Starting distributed system
2019-09-01 11:02:50,007  INFO he.geode.internal.logging.LoggingSession:  82 -
---------------------------------------------------------------------------

  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with this
  work for additional information regarding copyright ownership.

  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with the
  License.  You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
  License for the specific language governing permissions and limitations
  under the License.

---------------------------------------------------------------------------
Build-Date: 2019-04-19 11:49:13 -0700
Build-Id: onichols 0
Build-Java-Version: 1.8.0_192
Build-Platform: Mac OS X 10.14.4 x86_64
Product-Name: Apache Geode
Product-Version: 1.9.0
Source-Date: 2019-04-19 11:11:31 -0700
Source-Repository: release/1.9.0
Source-Revision: c0a73d1cb84986d432003bd12e70175520e63597
Native version: native code unavailable
Running on: 10.99.199.24/10.99.199.24, 8 cpu(s), x86_64 Mac OS X 10.13.6
Communications version: 100
Process ID: 30077
User: jblum
Current dir: /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build
Home dir: /Users/jblum
Command Line Parameters:
  -ea
  -Dspring.profiles.active=
  -Dspring.data.gemfire.locator.name=SpringLocatorTwo
  -Dspring.data.gemfire.locator.port=11235
  -Dlogback.log.level=INFO
  -javaagent:/Applications/IntelliJ IDEA 19 CE.app/Contents/lib/idea_rt.jar=51961:/Applications/IntelliJ IDEA 19 CE.app/Contents/bin
  -Dfile.encoding=UTF-8
Class Path:
...
..
.
2019-09-01 11:02:54,112  INFO ode.distributed.internal.InternalLocator: 661 - Locator started on 10.99.199.24[11235]
2019-09-01 11:02:54,113  INFO ode.distributed.internal.InternalLocator: 769 - Starting server location for Distribution Locator on 10.99.199.24[11235]
2019-09-01 11:02:54,134  INFO nt.internal.locator.wan.LocatorDiscovery: 138 - Locator discovery task exchanged locator information 10.99.199.24[11235] with localhost[10334]: {-1=[10.99.199.24[10334]]}.
2019-09-01 11:02:54,242  INFO .SpringBootApacheGeodeLocatorApplication:  61 - Started SpringBootApacheGeodeLocatorApplication in 6.137470354 seconds (JVM running for 6.667)
Press &lt;enter&gt; to exit!</programlisting>
</example>
<simpara>Next, start up the second Locator application instance (you should see log output similar to the preceding list).
Then connect to the cluster of Locators by using Gfsh:</simpara>
<example>
<title>Cluster of Locators</title>
<programlisting language="txt" linenumbering="unnumbered">$ echo $GEMFIRE
/Users/jblum/pivdev/apache-geode-1.9.0

$ gfsh
    _________________________     __
   / _____/ ______/ ______/ /____/ /
  / /  __/ /___  /_____  / _____  /
 / /__/ / ____/  _____/ / /    / /
/______/_/      /______/_/    /_/    1.9.0

Monitor and Manage Apache Geode

gfsh&gt;connect
Connecting to Locator at [host=localhost, port=10334] ..
Connecting to Manager at [host=10.99.199.24, port=1099] ..
Successfully connected to: [host=10.99.199.24, port=1099]

gfsh&gt;list members
      Name       | Id
---------------- | ------------------------------------------------------------------------
SpringLocatorOne | 10.99.199.24(SpringLocatorOne:30043:locator)&lt;ec&gt;&lt;v0&gt;:41000 [Coordinator]
SpringLocatorTwo | 10.99.199.24(SpringLocatorTwo:30077:locator)&lt;ec&gt;&lt;v1&gt;:41001</programlisting>
</example>
<simpara>By using our <literal>SpringBootApacheGeodeCacheServerApplication</literal> main class from the previous section, we can configure
and bootstrap an Apache Geode <literal>CacheServer</literal> application with Spring Boot and connect it to our cluster of Locators:</simpara>
<example>
<title>SpringBootApacheGeodeCacheServerApplication class</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@CacheServerApplication(name = "SpringBootApacheGeodeCacheServerApplication")
@SuppressWarnings("unused")
public class SpringBootApacheGeodeCacheServerApplication {

	public static void main(String[] args) {

		new SpringApplicationBuilder(SpringBootApacheGeodeCacheServerApplication.class)
			.web(WebApplicationType.NONE)
			.build()
			.run(args);
	}

	@Configuration
	@UseLocators
	@Profile("clustered")
	static class ClusteredConfiguration { }

	@Configuration
	@EnableLocator
	@EnableManager(start = true)
	@Profile("!clustered")
	static class LonerConfiguration { }

}</programlisting>
</example>
<simpara>To do so, enable the "clustered" profile by using an IDE run profile configuration similar to:</simpara>
<simpara><literal>-server -ea -Dspring.profiles.active=clustered -Dspring.data.gemfire.name=SpringServer -Dspring.data.gemfire.cache.server.port=41414 -Dlogback.log.level=INFO</literal></simpara>
<simpara>After the server starts up, you should see the new peer member in the cluster:</simpara>
<example>
<title>Cluster with Spring Boot configured and bootstrapped Apache Geode <literal>CacheServer</literal></title>
<programlisting language="txt" linenumbering="unnumbered">gfsh&gt;list members
      Name       | Id
---------------- | ------------------------------------------------------------------------
SpringLocatorOne | 10.99.199.24(SpringLocatorOne:30043:locator)&lt;ec&gt;&lt;v0&gt;:41000 [Coordinator]
SpringLocatorTwo | 10.99.199.24(SpringLocatorTwo:30077:locator)&lt;ec&gt;&lt;v1&gt;:41001
SpringServer     | 10.99.199.24(SpringServer:30216)&lt;v2&gt;:41002</programlisting>
</example>
<simpara>Finally, we can even start additional Locators and servers connected to this cluster by using Gfsh:</simpara>
<example>
<title>Gfsh started Locators and Servers</title>
<programlisting language="txt" linenumbering="unnumbered">gfsh&gt;start locator --name=GfshLocator --port=12345 --log-level=config
Starting a Geode Locator in /Users/jblum/pivdev/lab/GfshLocator...
......
Locator in /Users/jblum/pivdev/lab/GfshLocator on 10.99.199.24[12345] as GfshLocator is currently online.
Process ID: 30259
Uptime: 5 seconds
Geode Version: 1.9.0
Java Version: 1.8.0_192
Log File: /Users/jblum/pivdev/lab/GfshLocator/GfshLocator.log
JVM Arguments: -Dgemfire.default.locators=10.99.199.24[11235],10.99.199.24[10334] -Dgemfire.enable-cluster-configuration=true -Dgemfire.load-cluster-configuration-from-dir=false -Dgemfire.log-level=config -Dgemfire.launcher.registerSignalHandlers=true -Djava.awt.headless=true -Dsun.rmi.dgc.server.gcInterval=9223372036854775806
Class-Path: /Users/jblum/pivdev/apache-geode-1.9.0/lib/geode-core-1.9.0.jar:/Users/jblum/pivdev/apache-geode-1.9.0/lib/geode-dependencies.jar

gfsh&gt;start server --name=GfshServer --server-port=45454 --log-level=config
Starting a Geode Server in /Users/jblum/pivdev/lab/GfshServer...
...
Server in /Users/jblum/pivdev/lab/GfshServer on 10.99.199.24[45454] as GfshServer is currently online.
Process ID: 30295
Uptime: 2 seconds
Geode Version: 1.9.0
Java Version: 1.8.0_192
Log File: /Users/jblum/pivdev/lab/GfshServer/GfshServer.log
JVM Arguments: -Dgemfire.default.locators=10.99.199.24[11235],10.99.199.24[12345],10.99.199.24[10334] -Dgemfire.start-dev-rest-api=false -Dgemfire.use-cluster-configuration=true -Dgemfire.log-level=config -XX:OnOutOfMemoryError=kill -KILL %p -Dgemfire.launcher.registerSignalHandlers=true -Djava.awt.headless=true -Dsun.rmi.dgc.server.gcInterval=9223372036854775806
Class-Path: /Users/jblum/pivdev/apache-geode-1.9.0/lib/geode-core-1.9.0.jar:/Users/jblum/pivdev/apache-geode-1.9.0/lib/geode-dependencies.jar

gfsh&gt;list members
      Name       | Id
---------------- | ------------------------------------------------------------------------
SpringLocatorOne | 10.99.199.24(SpringLocatorOne:30043:locator)&lt;ec&gt;&lt;v0&gt;:41000 [Coordinator]
SpringLocatorTwo | 10.99.199.24(SpringLocatorTwo:30077:locator)&lt;ec&gt;&lt;v1&gt;:41001
SpringServer     | 10.99.199.24(SpringServer:30216)&lt;v2&gt;:41002
GfshLocator      | 10.99.199.24(GfshLocator:30259:locator)&lt;ec&gt;&lt;v3&gt;:41003
GfshServer       | 10.99.199.24(GfshServer:30295)&lt;v4&gt;:41004</programlisting>
</example>
<simpara>You must be careful to vary the ports and name of your peer members appropriately. Spring, and Spring Boot
for Apache Geode (SBDG) in particular, make doing so easy.</simpara>
</section>
<section xml:id="geode-manager-applications">
<title>Building Manager Applications</title>
<simpara>As discussed in the previous sections, you can enable a Spring Boot configured and bootstrapped Apache Geode
peer member node in the cluster to function as a Manager.</simpara>
<simpara>An Apache Geode Manager is a peer member node in the cluster that runs the management service, letting the cluster
be managed and monitored with JMX-based tools, such as Gfsh, JConsole, or JVisualVM. Any tool using the JMX API
can connect to and manage an Apache Geode cluster for whatever purpose.</simpara>
<simpara>Like Locators, the cluster may have more than one Manager for redundancy.  Only server-side, peer member nodes
in the cluster may function Managers.  Therefore, a <literal>ClientCache</literal> application cannot be a Manager.</simpara>
<simpara>To create a Manager, use the SDG <literal>@EnableManager</literal> annotation.</simpara>
<simpara>The three primary uses of the <literal>@EnableManager</literal> annotation to create a Manager are:</simpara>
<simpara>1 - CacheServer Manager Application</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@CacheServerApplication(name = "CacheServerManagerApplication")
@EnableManager(start = true)
class CacheServerManagerApplication {
	// ...
}</programlisting>
</informalexample>
<simpara>2 - Peer Cache Manager Application</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@PeerCacheApplication(name = "PeerCacheManagerApplication")
@EnableManager(start = "true")
class PeerCacheManagerApplication {
	// ...
}</programlisting>
</informalexample>
<simpara>3 - Locator Manager Application</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@LocatorApplication(name = "LocatorManagerApplication")
@EnableManager(start = true)
class LocatorManagerApplication {
	// ...
}</programlisting>
</informalexample>
<simpara>#1 creates a peer <literal>Cache</literal> instance with a <literal>CacheServer</literal> component that accepts client connections along with
an embedded Manager that lets JMX clients connect.</simpara>
<simpara>#2 creates only a peer <literal>Cache</literal> instance along with an embedded Manager. As a peer <literal>Cache</literal> with no <literal>CacheServer</literal>
component, clients are not able to connect to this node. It is merely a server managing data.</simpara>
<simpara>#3 creates a Locator instance with an embedded Manager.</simpara>
<simpara>In all configuration arrangements, the Manager is configured to start immediately.</simpara>
<tip>
<simpara>See the Javadoc for the
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableManager.html"><literal>@EnableManager</literal> annotation</link>
for additional configuration options.</simpara>
</tip>
<simpara>As of Apache Geode 1.11.0, you must include additional Apache Geode dependencies on your Spring Boot application
classpath to make your application a proper Apache Geode Manager in the cluster, particularly if you also enable
the embedded HTTP service in the Manager.</simpara>
<simpara>The required dependencies are:</simpara>
<example>
<title>Additional Manager dependencies expressed in Gradle</title>
<programlisting language="groovy" linenumbering="unnumbered">runtime "org.apache.geode:geode-http-service"
runtime "org.apache.geode:geode-web"
runtime "org.springframework.boot:spring-boot-starter-jetty"</programlisting>
</example>
<simpara>The embedded HTTP service (implemented with the Eclipse Jetty Servlet Container), runs the Management (Admin) REST API,
which is used by Apache Geode tooling, such as Gfsh, to connect to an Apache Geode cluster over HTTP. In addition, it
also enables the Apache Geode <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/tools_modules/pulse/pulse-overview.html">Pulse</link> Monitoring Tool
(and Web application) to run.</simpara>
<simpara>Even if you do not start the embedded HTTP service, a Manager still requires the <literal>geode-http-service</literal>, <literal>geode-web</literal>
and <literal>spring-boot-starter-jetty</literal> dependencies.</simpara>
<simpara>Optionally, you may also include the <literal>geode-pulse</literal> dependency, as follows:</simpara>
<example>
<title>Additional, optional Manager depdendencies expressed in Gradle</title>
<programlisting language="groovy" linenumbering="unnumbered">runtime "org.apache.geode:geode-pulse"</programlisting>
</example>
<simpara>The <literal>geode-pulse</literal> dependency is only required if you want the Manager to automatically start
the Apache Geode <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/tools_modules/pulse/pulse-overview.html">Pulse</link> Monitoring Tool. Pulse enables you
to view the nodes of your Apache Geode cluster and monitor them in realtime.</simpara>
</section>
</chapter>
<chapter xml:id="geode-configuration-auto">
<title>Auto-configuration</title>
<simpara>The following Spring Framework, Spring Data for Apache Geode (SDG) and Spring Session for Apache Geode (SSDG)
annotations are implicitly declared by Spring Boot for Apache Geode&#8217;s (SBDG) auto-configuration.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>@ClientCacheApplication</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemfireCaching</literal> (alternatively, Spring Framework&#8217;s <literal>@EnableCaching</literal>)</simpara>
</listitem>
<listitem>
<simpara><literal>@EnableContinuousQueries</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemfireFunctions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemfireFunctionExecutions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemfireRepositories</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableLogging</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnablePdx</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableSecurity</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableSsl</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemFireHttpSession</literal></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This means that you need not explicitly declare any of these annotations on your <literal>@SpringBootApplication</literal> class,
since they are provided by SBDG already. The only reason you would explicitly declare any of these annotations is to
override Spring Boot&#8217;s, and in particular, SBDG&#8217;s auto-configuration. Otherwise, doing so is unnecessary.</simpara>
</note>
<tip>
<simpara>You should read the chapter in Spring Boot&#8217;s reference documentation on
<link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/#using-boot-auto-configuration">auto-configuration</link>.</simpara>
</tip>
<tip>
<simpara>You should review the chapter in Spring Data for Apache Geode&#8217;s (SDG) reference documentation
on <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config">annotation-based configuration</link>. For a quick reference
and overview of annotation-based configuration, see the
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstap-annotations-quickstart">annotations quickstart</link>.</simpara>
</tip>
<tip>
<simpara>See the corresponding sample <link xl:href="guides/boot-configuration.html">guide</link> and {github-samples-url}/boot/configuration[code]
to see Spring Boot auto-configuration for Apache Geode in action.</simpara>
</tip>
<section xml:id="geode-configuration-auto-customizing">
<title>Customizing Auto-configuration</title>
<simpara>You might ask, <quote>How do I customize the auto-configuration provided by SBDG if I do not explicitly declare
the annotation?</quote></simpara>
<simpara>For example, you may want to customize the member&#8217;s name.  You know that the
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html"><literal>@ClientCacheApplication</literal></link> annotation
provides the <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableGemFireProperties.html#name--"><literal>name</literal></link> attribute
so that you can set the client member&#8217;s name. However, SBDG has already implicitly declared the <literal>@ClientCacheApplication</literal>
annotation through auto-configuration on your behalf. What do you do?</simpara>
<simpara>In this case, SBDG supplies a few additional annotations.</simpara>
<simpara>For example, to set the (client or peer) member&#8217;s name, you can use the <literal>@UseMemberName</literal> annotation:</simpara>
<example>
<title>Setting the member&#8217;s name using <literal>@UseMemberName</literal></title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@UseMemberName("MyMemberName")
class SpringBootApacheGeodeClientCacheApplication {
	//...
}</programlisting>
</example>
<simpara>Alternatively, you could set the <literal>spring.application.name</literal> or the <literal>spring.data.gemfire.name</literal> property in Spring Boot
<literal>application.properties</literal>:</simpara>
<example>
<title>Setting the member&#8217;s name using the <literal>spring.application.name</literal> property</title>
<programlisting language="txt" linenumbering="unnumbered"># Spring Boot application.properties

spring.application.name = MyMemberName</programlisting>
</example>
<example>
<title>Setting the member&#8217;s name using the <literal>spring.data.gemfire.cache.name</literal> property</title>
<programlisting language="txt" linenumbering="unnumbered"># Spring Boot application.properties

spring.data.gemfire.cache.name = MyMemberName</programlisting>
</example>
<note>
<simpara>The <literal>spring.data.gemfire.cache.name</literal> property is an alias for the <literal>spring.data.gemfire.name</literal> property. Both
properties do the same thing (set the name of the client or peer member node).</simpara>
</note>
<simpara>In general, there are three ways to customize configuration, even in the context of SBDG&#8217;s auto-configuration:</simpara>
<itemizedlist>
<listitem>
<simpara>Using <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/config/annotation/package-summary.html">annotations</link>
provided by SBDG for common and popular concerns (such as naming client or peer members with the <literal>@UseMemberName</literal>
annotation or enabling durable clients with the <literal>@EnableDurableClient</literal> annotation).</simpara>
</listitem>
<listitem>
<simpara>Using well-known and documented <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-properties">properties</link>
(such as <literal>spring.application.name</literal>, or <literal>spring.data.gemfire.name</literal>, or <literal>spring.data.gemfire.cache.name</literal>).</simpara>
</listitem>
<listitem>
<simpara>Using <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-configurers">configurers</link>
(such as <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheConfigurer.html"><literal>ClientCacheConfigurer</literal></link>).</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>For the complete list of documented properties, see <xref linkend="geode-configuration-metadata"/>.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-auto-disabling">
<title>Disabling Auto-configuration</title>
<simpara>Spring Boot&#8217;s reference documentation explains how to
<link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/#using-boot-disabling-specific-auto-configuration">disable Spring Boot auto-configuration</link>.</simpara>
<simpara><xref linkend="geode-auto-configuration-disable"/> also explains how to disable SBDG auto-configuration.</simpara>
<simpara>In a nutshell, if you want to disable any auto-configuration provided by either Spring Boot or SBDG, declare your intent
in the <literal>@SpringBootApplication</literal> annotation:</simpara>
<example>
<title>Disabling Specific Auto-configuration Classes</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication(
  exclude = { DataSourceAutoConfiguration.class, PdxAutoConfiguration.class }
)
class SpringBootApacheGeodeClientCacheApplication {
	// ...
}</programlisting>
</example>
<caution>
<simpara>Make sure you understand what you are doing when you disable auto-configuration.</simpara>
</caution>
</section>
<section xml:id="geode-configuration-auto-overriding">
<title>Overriding Auto-configuration</title>
<simpara><xref linkend="geode-autoconfiguration-annotations-overriding"/> explains how to override SBDG auto-configuration.</simpara>
<simpara>In a nutshell, if you want to override the default auto-configuration provided by SBDG, you must annotate your
<literal>@SpringBootApplication</literal> class with your intent.</simpara>
<simpara>For example, suppose you want to configure and bootstrap an Apache Geode <literal>CacheServer</literal> application
(a peer, not a client):</simpara>
<example>
<title>Overriding the default <literal>ClientCache</literal> <emphasis>Auto-Configuration</emphasis> by configuring &amp; bootstrapping a <literal>CacheServer</literal> application</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@CacheServerApplication
class SpringBootApacheGeodeCacheServerApplication {
	// ...
}</programlisting>
</example>
<simpara>You can also explicitly declare the <literal>@ClientCacheApplication</literal> annotation on your <literal>@SpringBootApplication</literal> class:</simpara>
<example>
<title>Overriding by explicitly declaring <literal>@ClientCacheApplication</literal></title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@ClientCacheApplication
class SpringBootApacheGeodeClientCacheApplication {
	// ...
}</programlisting>
</example>
<simpara>You are overriding SBDG&#8217;s auto-configuration of the <literal>ClientCache</literal> instance. As a result, you have now also implicitly
consented to being responsible for other aspects of the configuration (such as security).</simpara>
<simpara>Why does that happen?</simpara>
<simpara>It happens because, in certain cases, such as security, certain aspects of security configuration (such as SSL) must be
configured before the cache instance is created. Also, Spring Boot always applies user configuration before
auto-configuration partially to determine what needs to be auto-configured in the first place.</simpara>
<caution>
<simpara>Make sure you understand what you are doing when you override auto-configuration.</simpara>
</caution>
</section>
<section xml:id="geode-configuration-auto-replacing">
<title>Replacing Auto-configuration</title>
<simpara>See the Spring Boot reference documentation on
<link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/#using-boot-replacing-auto-configuration">replacing auto-configuration</link>.</simpara>
</section>
<section xml:id="geode-configuration-auto-explained">
<title>Understanding Auto-configuration</title>
<simpara>This section covers the SBDG provided auto-configuration classes that correspond to the SDG annotations in more detail.</simpara>
<simpara>To review the complete list of SBDG auto-confiugration classes, see <xref linkend="geode-auto-configuration-disable-classes"/>.</simpara>
<section xml:id="geode-configuration-declarative-auto-configuration-clientcacheapplication">
<title><literal>@ClientCacheApplication</literal></title>
<note>
<simpara>The SBDG <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/ClientCacheAutoConfiguration.html"><literal>ClientCacheAutoConfiguration</literal></link> class
corresponds to the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html"><literal>@ClientCacheApplication</literal></link> annotation.</simpara>
</note>
<simpara>As explained in <xref linkend="getting-started"/> SBDG starts with the opinion that application developers primarily build Apache Geode
<link linkend="geode-clientcache-applications">client applications</link> by using Spring Boot.</simpara>
<simpara>Technically, this means building Spring Boot applications with an Apache Geode <literal>ClientCache</literal> instance connected to
a dedicated cluster of Apache Geode servers that manage the data as part of a
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/topologies_and_comm/cs_configuration/chapter_overview.html">client/server</link> topology.</simpara>
<simpara>By way of example, this means that you need not explicitly declare and annotate your <literal>@SpringBootApplication</literal> class
with SDG&#8217;s <literal>@ClientCacheApplication</literal> annotation, as the following example shows:</simpara>
<example>
<title>Do Not Do This</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@ClientCacheApplication
class SpringBootApacheGeodeClientCacheApplication {
	// ...
}</programlisting>
</example>
<simpara>SBDG&#8217;s provided auto-configuration class is already meta-annotated with SDG&#8217;s <literal>@ClientCacheApplication</literal> annotation.
Therefore, you need only do:</simpara>
<example>
<title>Do This</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
class SpringBootApacheGeodeClientCacheApplication {
	// ...
}</programlisting>
</example>
<tip>
<simpara>See SDG&#8217;s reference documentation for more details on Apache Geode
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-geode-applications">cache applications</link>
and <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-client-server-applications">client/server applications</link>
in particular.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-declarative-auto-configuration-enablecaching">
<title><literal>@EnableGemfireCaching</literal></title>
<note>
<simpara>The SBDG <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/CachingProviderAutoConfiguration.html"><literal>CachingProviderAutoConfiguration</literal></link> class
corresponds to the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/cache/config/EnableGemfireCaching.html"><literal>@EnableGemfireCaching</literal></link> annotation.</simpara>
</note>
<simpara>If you used the core Spring Framework to configure Apache Geode as a caching provider in
<link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache">Spring&#8217;s Cache Abstraction</link>, you need to:</simpara>
<example>
<title>Configuring caching using the Spring Framework</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableCaching
class CachingUsingApacheGeodeConfiguration {

    @Bean
    GemfireCacheManager cacheManager(GemFireCache cache) {

        GemfireCacheManager cacheManager = new GemfireCacheManager();

        cacheManager.setCache(cache);

        return cacheManager;
    }
}</programlisting>
</example>
<simpara>If you use Spring Data for Apache Geode&#8217;s <literal>@EnableGemfireCaching</literal> annotation, you can simplify the preceding
configuration:</simpara>
<example>
<title>Configuring caching using Spring Data for Apache Geode</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableGemfireCaching
class CachingUsingApacheGeodeConfiguration {

}</programlisting>
</example>
<simpara>Also, if you use SBDG, you need only do:</simpara>
<example>
<title>Configuring caching using Spring Boot for Apache Geode</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
class CachingUsingApacheGeodeConfiguration {

}</programlisting>
</example>
<simpara>This lets you focus on the areas in your application that would benefit from caching without having to enable the
plumbing. You can then demarcate the service methods in your application that are good candidates for caching:</simpara>
<example>
<title>Using caching in your application</title>
<programlisting language="java" linenumbering="unnumbered">@Service
class CustomerService {

    @Caching("CustomersByName")
    Customer findBy(String name) {
        // ...
    }
}</programlisting>
</example>
<tip>
<simpara>See <link linkend="geode-caching-provider">documentation on caching</link> for more details.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-declarative-auto-configuration-enableautocontinuousqueies">
<title><literal>@EnableContinuousQueries</literal></title>
<note>
<simpara>The SBDG <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/ContinuousQueryAutoConfiguration.html"><literal>ContinuousQueryAutoConfiguration</literal></link> class
corresponds to the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableContinuousQueries.html"><literal>@EnableContinuousQueries</literal></link> annotation.</simpara>
</note>
<simpara>Without having to enable anything, you can annotate your application (POJO) component method(s) with the SDG
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/listener/annotation/ContinuousQuery.html"><literal>@ContinuousQuery</literal></link>
annotation to register a CQ and start receiving events. The method acts as a <literal>CqEvent</literal> handler or, in Apache Geode&#8217;s
terminology, the method is an implementation of the
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/query/CqListener.html"><literal>CqListener</literal></link> interface.</simpara>
<example>
<title>Declare application CQs</title>
<programlisting language="java" linenumbering="unnumbered">@Component
class MyCustomerApplicationContinuousQueries {

    @ContinuousQuery("SELECT customer.* "
        + " FROM /Customers customers"
        + " WHERE customer.getSentiment().name().equalsIgnoreCase('UNHAPPY')")
    public void handleUnhappyCustomers(CqEvent event) {
        // ...
    }
}</programlisting>
</example>
<simpara>As the preceding example shows, you can define the events you are interested in receiving by using an OQL query with a
finely tuned query predicate that describes the events of interests and implements the handler method to process the
events (such as applying a credit to the customer&#8217;s account and following up in email).</simpara>
<tip>
<simpara>See <xref linkend="geode-continuous-query"/> for more details.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-declarative-auto-configuration-enablefunctions">
<title><literal>@EnableGemfireFunctionExecutions</literal> &amp; <literal>@EnableGemfireFunctions</literal></title>
<note>
<simpara>The SBDG <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/FunctionExecutionAutoConfiguration.html"><literal>FunctionExecutionAutoConfiguration</literal></link> class
corresponds to both the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/function/config/EnableGemfireFunctionExecutions.html"><literal>@EnableGemfireFunctionExecutions</literal></link>
and SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/function/config/EnableGemfireFunctions.html"><literal>@EnableGemfireFunctions</literal></link> annotations.</simpara>
</note>
<simpara>Whether you need to <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#function-execution">execute</link>
or <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#function-implementation">implement</link> a <literal>Function</literal>, SBDG detects the Function definition
and auto-configures it appropriately for use in your Spring Boot application. You need only define the Function
execution or implementation in a package below the main <literal>@SpringBootApplication</literal> class:</simpara>
<example>
<title>Declare a Function Execution</title>
<programlisting language="java" linenumbering="unnumbered">package example.app.functions;

@OnRegion("Accounts")
interface MyCustomerApplicationFunctions {

    void applyCredit(Customer customer);

}</programlisting>
</example>
<simpara>Then you can inject the Function execution into any application component and use it:</simpara>
<example>
<title>Use the Function</title>
<programlisting language="java" linenumbering="unnumbered">package example.app.service;

@Service
class CustomerService {

    @Autowired
    private MyCustomerApplicationFunctions customerFunctions;

    void analyzeCustomerSentiment(Customer customer) {

        // ...

        this.customerFunctions.applyCredit(customer);

        // ...
    }
}</programlisting>
</example>
<simpara>The same pattern basically applies to Function implementations, except in the implementation case, SBDG registers
the Function implementation for use (that is, to be called by a Function execution).</simpara>
<simpara>Doing so lets you focus on defining the logic required by your application and not worry about how Functions
are registered, called, and so on. SBDG handles this concern for you.</simpara>
<note>
<simpara>Function implementations are typically defined and registered on the server-side.</simpara>
</note>
<tip>
<simpara>See <xref linkend="geode-functions"/> for more details.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-declarative-auto-configuration-enablerepositories">
<title><literal>@EnableGemfireRepositories</literal></title>
<note>
<simpara>The SBDG <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/GemFireRepositoriesAutoConfigurationRegistrar.html"><literal>GemFireRepositoriesAutoConfigurationRegistrar</literal></link> class
corresponds to the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/repository/config/EnableGemfireRepositories.html"><literal>@EnableGemfireRepositories</literal></link> annotation.</simpara>
</note>
<simpara>As with Functions, you need concern yourself only with the data access operations (such as basic CRUD and simple queries)
required by your application to carry out its operation, not with how to create and perform them (for example,
<literal>Region.get(key)</literal> and <literal>Region.put(key, obj)</literal>) or execute them (for example, <literal>Query.execute(arguments)</literal>).</simpara>
<simpara>Start by defining your Spring Data Repository:</simpara>
<example>
<title>Define an application-specific Repository</title>
<programlisting language="java" linenumbering="unnumbered">package example.app.repo;

interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt; {

    List&lt;Customer&gt; findBySentimentEqualTo(Sentiment sentiment);

}</programlisting>
</example>
<simpara>Then you can inject the Repository into an application component and use it:</simpara>
<example>
<title>Using the application-specific Repository</title>
<programlisting language="java" linenumbering="unnumbered">package example.app.sevice;

@Service
class CustomerService {

    @Autowired
    private CustomerRepository repository;

    public void processCustomersWithSentiment(Sentiment sentiment) {

        this.repository.findBySentimentEqualTo(sentiment)
            .forEach(customer -&gt; { /* ... */ });

        // ...
    }
}</programlisting>
</example>
<simpara>Your application-specific Repository simply needs to be declared in a package below the main <literal>@SpringBootApplication</literal>
class. Again, you are focusing only on the data access operations and queries required to carry out the operatinons
of your application, nothing more.</simpara>
<tip>
<simpara>See <xref linkend="geode-repositories"/> for more details.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-declarative-auto-configuration-enablelogging">
<title><literal>@EnableLogging</literal></title>
<note>
<simpara>The SBDG <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/LoggingAutoConfiguration.html"><literal>LoggingAutoConfiguration</literal></link> class
corresponds to the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableLogging.html"><literal>@EnableLogging</literal></link> annotation.</simpara>
</note>
<simpara>Logging is an essential application concern to understand what is happening in the system along with when and where
the events occurred. By default, SBDG auto-configures logging for Apache Geode with the default log-level, <quote>config</quote>.</simpara>
<simpara>You can change any aspect of logging, such as the log-level, in Spring Boot <literal>application.properties</literal>:</simpara>
<example>
<title>Change the log-level for Apache Geode</title>
<programlisting language="txt" linenumbering="unnumbered"># Spring Boot application.properites.

spring.data.gemfire.cache.log-level=debug</programlisting>
</example>
<note>
<simpara>The 'spring.data.gemfire.logging.level' property is an alias for <literal>spring.data.gemfire.cache.log-level</literal>.</simpara>
</note>
<simpara>You can also configure other aspects, such as the log file size and disk space limits for the filesystem location used
to store the Apache Geode log files at runtime.</simpara>
<simpara>Under the hood, Apache Geode&#8217;s logging is based on Log4j. Therefore, you can configure Apache Geode logging to use any
logging provider (such as Logback) and configuration metadata appropriate for that logging provider so long as you
supply the necessary adapter between Log4j and whatever logging system you use. For instance, if you include
<literal>org.springframework.boot:spring-boot-starter-logging</literal>, you are using Logback and you will need the
<literal>org.apache.logging.log4j:log4j-to-slf4j</literal> adapter.</simpara>
</section>
<section xml:id="geode-configuration-declarative-auto-configuration-enablepdx">
<title><literal>@EnablePdx</literal></title>
<note>
<simpara>The SBDG <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/PdxSerializationAutoConfiguration.html"><literal>PdxSerializationAutoConfiguration</literal></link> class
corresponds to the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePdx.html"><literal>@EnablePdx</literal></link> annotation.</simpara>
</note>
<simpara>Any time you need to send an object over the network or overflow or persist an object to disk, your application domain
model object must be serializable. It would be painful to have to implement <literal>java.io.Serializable</literal> in every one of your
application domain model objects (such as <literal>Customer</literal>) that would potentially need to be serialized.</simpara>
<simpara>Furthermore, using Java Serialization may not be ideal (it may not be the most portable or efficient solution) in all
cases or even possible in other cases (such as when you use a third party library over which you have no control).</simpara>
<simpara>In these situations, you need to be able to send your object anywhere, anytime without unduly requiring the class type
to be serializable and exist on the classpath in every place it is sent. Indeed, the final destination may not even be
a Java application. This is where Apache Geode
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/data_serialization/gemfire_pdx_serialization.html">PDX Serialization</link> steps in to help.</simpara>
<simpara>However, you need not figure out how to configure PDX to identify the application class types that needs to be
serialized. Instead, you can define your class type as follows:</simpara>
<example>
<title>Customer class</title>
<programlisting language="java" linenumbering="unnumbered">@Region("Customers")
class Customer {

    @Id
    private Long id;

    @Indexed
    private String name;

    // ...
}</programlisting>
</example>
<simpara>SBDG&#8217;s auto-configuration handles the rest.</simpara>
<tip>
<simpara>See <xref linkend="geode-data-serialization"/> for more details.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-declarative-auto-configuration-enablesecurity">
<title><literal>@EnableSecurity</literal></title>
<note>
<simpara>The SBDG <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/ClientSecurityAutoConfiguration.html"><literal>ClientSecurityAutoConfiguration</literal></link> class
and <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/PeerSecurityAutoConfiguration.html"><literal>PeerSecurityAutoConfiguration</literal></link> class
correspond to the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSecurity.html"><literal>@EnableSecurity</literal></link> annotation,
but they apply security (specifically, authentication and authorization (auth) configuration) for both clients
and servers.</simpara>
</note>
<simpara>Configuring your Spring Boot, Apache Geode <literal>ClientCache</literal> application to properly authenticate with a cluster of secure
Apache Geode servers is as simple as setting a username and a password in Spring Boot <literal>application.properties</literal>:</simpara>
<example>
<title>Supplying Authentication Credentials</title>
<programlisting language="txt" linenumbering="unnumbered"># Spring Boot application.properties

spring.data.gemfire.security.username=Batman
spring.data.gemfire.security.password=r0b!n5ucks</programlisting>
</example>
<note>
<simpara>Authentication is even easier to configure in a managed environment, such as PCF when using PCC. You need not do
anything.</simpara>
</note>
<simpara>Authorization is configured on the server-side and is made simple with SBDG and the help of
<link xl:href="https://shiro.apache.org/">Apache Shiro</link>.
Of course, this assumes you use SBDG to configure and bootstrap your Apache Geode cluster in the first place, which is
even easier with SBDG. See <xref linkend="geode-cluster-configuration-bootstrapping"/>.</simpara>
<tip>
<simpara>See <xref linkend="geode-security"/> for more details.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-declarative-auto-configuration-enablessl">
<title><literal>@EnableSsl</literal></title>
<note>
<simpara>The SBDG <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/SslAutoConfiguration.html"><literal>SslAutoConfiguration</literal></link> class
corresponds to the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html"><literal>@EnableSsl</literal></link> annotation.</simpara>
</note>
<simpara>Configuring SSL for secure transport (TLS) between your Spring Boot, Apache Geode <literal>ClientCache</literal> application and an
Apache Geode cluster can be a real problem, especially to get right from the start. So, it is something that SBDG
makes as simple as possible.</simpara>
<simpara>You can supply a <literal>trusted.keystore</literal> file containing the certificates in a well-known location (such as the root of your
application classpath), and SBDG&#8217;s auto-configuration steps in to handle the rest.</simpara>
<simpara>This is useful during development, but we highly recommend using a more secure procedure (such as integrating with a
secure credential store like LDAP, CredHub or Vault) when deploying your Spring Boot application to production.</simpara>
<tip>
<simpara>See <xref linkend="geode-security-ssl"/> for more details.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-declarative-auto-configuration-enablespringsession">
<title><literal>@EnableGemFireHttpSession</literal></title>
<note>
<simpara>The SBDG <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/SpringSessionAutoConfiguration.html"><literal>SpringSessionAutoConfiguration</literal></link> class
corresponds to the SSDG <link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/api/org/springframework/session/data/gemfire/config/annotation/EnableGemFireHttpSession.html"><literal>@EnableGemFireHttpSession</literal></link> annotation.</simpara>
</note>
<simpara>Configuring Apache Geode to serve as the (HTTP) session state caching provider by using Spring Session requires that
you only include the correct starter, that is <literal>spring-geode-starter-session</literal>:</simpara>
<example>
<title>Using Spring Session</title>
<screen>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.geode&lt;/groupId&gt;
    &lt;artifactId&gt;spring-geode-starter-session&lt;/artifactId&gt;
    &lt;version&gt;{version}&lt;/version&gt;
&lt;/dependency&gt;</screen>
</example>
<simpara>With Spring Session&#8201;&#8212;&#8201;and specifically Spring Session for Apache Geode (SSDG)&#8201;&#8212;&#8201;on the classpath of your Spring Boot,
Apache Geode <literal>ClientCache</literal> Web application, you can manage your (HTTP) session state with Apache Geode. No further
configuration is needed. SBDG auto-configuration detects Spring Session on the application classpath and does the rest.</simpara>
<tip>
<simpara>See <xref linkend="geode-session"/> for more details.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-declarative-auto-configuration-regiontemplates">
<title>RegionTemplateAutoConfiguration</title>
<simpara>The SBDG <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/RegionTemplateAutoConfiguration.html"><literal>RegionTemplateAutoConfiguration</literal></link> class
has no corresponding SDG annotation. However, the auto-configuration of a <literal>GemfireTemplate</literal> for every Apache Geode
<literal>Region</literal> defined and declared in your Spring Boot application is still supplied by SBDG.</simpara>
<simpara>For example, you can define a Region by using:</simpara>
<example>
<title>Region definition using JavaConfig</title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
class GeodeConfiguration {

    @Bean("Customers")
    ClientRegionFactoryBean&lt;Long, Customer&gt; customersRegion(GemFireCache cache) {

        ClientRegionFactoryBean&lt;Long, Customer&gt; customersRegion =
            new ClientRegionFactoryBean&lt;&gt;();

        customersRegion.setCache(cache);
        customersRegion.setShortcut(ClientRegionShortcut.PROXY);

        return customersRegion;
    }
}</programlisting>
</example>
<simpara>Alternatively, you can define the <literal>Customers</literal> Region by using <literal>@EnableEntityDefinedRegions</literal>:</simpara>
<example>
<title>Region definition using <literal>@EnableEntityDefinedRegions</literal></title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@EnableEntityDefinedRegion(basePackageClasses = Customer.class)
class GeodeConfiguration {

}</programlisting>
</example>
<simpara>Then SBDG supplies a <literal>GemfireTemplate</literal> instance that you can use to perform low-level data-access operations
(indirectly) on the <literal>Customers</literal> Region:</simpara>
<example>
<title>Use the <literal>GemfireTemplate</literal> to access the "Customers" Region</title>
<programlisting language="java" linenumbering="unnumbered">@Repository
class CustomersDao {

    @Autowired
    @Qualifier("customersTemplate")
    private GemfireTemplate customersTemplate;

    Customer findById(Long id) {
        return this.customerTemplate.get(id);
    }
}</programlisting>
</example>
<simpara>You need not explicitly configure <literal>GemfireTemplates</literal> for each Region to which you need low-level data access (such as
when you are not using the Spring Data Repository abstraction).</simpara>
<simpara>Be careful to qualify the <literal>GemfireTemplate</literal> for the Region to which you need data access, especially given that you
probably have more than one Region defined in your Spring Boot application.</simpara>
<tip>
<simpara>See <xref linkend="geode-data-access-region-templates"/> for more details.</simpara>
</tip>
</section>
</section>
</chapter>
<chapter xml:id="geode-configuration-declarative">
<title>Declarative Configuration</title>
<simpara>The primary purpose of any software development framework is to help you be productive as quickly and as easily as
possible and to do so in a reliable manner.</simpara>
<simpara>As application developers, we want a framework to provide constructs that are both intuitive and familiar so that their
behaviors are predictable. This provided convenience not only helps you hit the ground running in the right direction
sooner but increases your focus on the application domain so that you can better understand the problem you are trying
to solve in the first place. Once the problem domain is well understood, you are more apt to make informed decisions
about the design, which leads to better outcomes, faster.</simpara>
<simpara>This is exactly what Spring Boot&#8217;s auto-configuration provides for you. It enables features, functionality, services
and supporting infrastructure for Spring applications in a loosely integrated way by using conventions (such as the
classpath) that ultimately help you keep your attention and focus on solving the problem at hand and not on the plumbing.</simpara>
<simpara>For example, if you are building a web application, you can include the <literal>org.springframework.boot:spring-boot-starter-web</literal>
dependency on your application classpath. Not only does Spring Boot enable you to build Spring Web MVC Controllers
appropriate to your application UC (your responsibility), but it also bootstraps your web application in an embedded
Servlet container on startup (Spring Boot&#8217;s responsibility).</simpara>
<simpara>This saves you from having to handle many low-level, repetitive, and tedious development tasks that are error-prone and
easy to get wrong when you are trying to solve problems. You need not care how the plumbing works until you need to
customize something. And, when you do, you are better informed and prepared to do so.</simpara>
<simpara>It is also equally essential that frameworks, such as Spring Boot, get out of the way quickly when application
requirements diverge from the provided defaults. This is the beautiful and powerful thing about Spring Boot and why
it is second to none in its class.</simpara>
<simpara>Still, auto-configuration does not solve every problem all the time. Therefore, you need to use declarative
configuration in some cases, whether expressed as bean definitions, in properties, or by some other means.  This is so
that frameworks do not leave things to chance, especially when things are ambiguous. The framework gives you choice.</simpara>
<simpara>Keeping our goals in mind, this chapter:</simpara>
<itemizedlist>
<listitem>
<simpara>Refers you to the SDG annotations covered by SBDG&#8217;s auto-configuration.</simpara>
</listitem>
<listitem>
<simpara>Lists all SDG annotations not covered by SBDG&#8217;s auto-configuration.</simpara>
</listitem>
<listitem>
<simpara>Covers the SBDG, SSDG and SDG annotations that you must explicitly declare and that provide the most value
and productivity when getting started with Apache Geode in Spring [Boot] applications.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>SDG refers to <link xl:href="https://spring.io/projects/spring-data-geode">Spring Data for Apache Geode</link>. SSDG refers to
<link xl:href="https://spring.io/projects/spring-session-data-geode">Spring Session for Apache Geode</link>. SBDG refers to
Spring Boot for Apache Geode (this project).</simpara>
</note>
<tip>
<simpara>The list of SDG annotations covered by SBDG&#8217;s auto-configuration is discussed in detail in the <xref linkend="appendix"/>,
in the <link linkend="geode-auto-configuration-annotations">Auto-configuration vs. Annotation-based configuration</link> section.</simpara>
</tip>
<simpara>To be absolutely clear about which SDG annotations we are referring to, we mean the SDG annotations in the
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/package-summary.html"><literal>org.springframework.data.gemfire.config.annotation</literal></link>
package.</simpara>
<simpara>In subsequent sections, we also cover which annotations are added by SBDG.</simpara>
<section xml:id="geode-configuration-declarative-auto-configuration">
<title>Auto-configuration</title>
<simpara>We explained auto-configuration in detail in the <link linkend="geode-configuration-auto">Auto-configuration</link> chapter.</simpara>
</section>
<section xml:id="geode-configuration-declarative-annotations">
<title>Annotations Not Covered by Auto-configuration</title>
<simpara>The following SDG annotations are not implicitly applied by SBDG&#8217;s auto-configuration:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>@EnableAutoRegionLookup</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableBeanFactoryLocator</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableCacheServer(s)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableCachingDefinedRegions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableClusterConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableClusterDefinedRegions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableCompression</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableDiskStore(s)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableEntityDefinedRegions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableEviction</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableExpiration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGatewayReceiver</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGatewaySender(s)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemFireAsLastResource</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemFireMockObjects</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableHttpService</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableIndexing</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableOffHeap</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableLocator</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableManager</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableMemcachedServer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnablePool(s)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableRedisServer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableStatistics</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@UseGemFireProperties</literal></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This content was also covered in <xref linkend="geode-autoconfiguration-annotations-explicit"/>.</simpara>
</note>
<simpara>One reason SBDG does not provide auto-configuration for several of the annotations is because the annotations
are server-specific:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>@EnableCacheServer(s)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGatewayReceiver</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGatewaySender(s)</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>@EnableHttpService</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableLocator</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableManager</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableMemcachedServer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableRedisServer</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Also, we <link linkend="geode-clientcache-applications">already stated</link> that SBDG is opinionated about providing a <literal>ClientCache</literal>
instance.</simpara>
<simpara>Other annotations are driven by need, including:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>@EnableAutoRegionLookup</literal> and <literal>@EnableBeanFactoryLocator</literal>: Really useful only when mixing configuration metadata
formats, such as Spring config with Apache Geode <literal>cache.xml</literal>. This is usually the case only if you have legacy
<literal>cache.xml</literal> config to begin with. Otherwise, you should not use these annotations.</simpara>
</listitem>
<listitem>
<simpara><literal>@EnableCompression</literal>: Requires the Snappy Compression Library to be on your application classpath.</simpara>
</listitem>
<listitem>
<simpara><literal>@EnableDiskStore(s)</literal> Used only for overflow and persistence.</simpara>
</listitem>
<listitem>
<simpara><literal>@EnableOffHeap</literal>: Enables data to be stored in main memory, which is useful only when your application data (that is,
objects stored in Apache Geode) are generally uniform in size.</simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemFireAsLastResource</literal>: Needed only in the context of JTA Transactions.</simpara>
</listitem>
<listitem>
<simpara><literal>@EnableStatistics</literal>: Useful if you need runtime metrics. However, enabling statistics gathering does consume
considerable system resources (CPU &amp; Memory).</simpara>
</listitem>
</itemizedlist>
<simpara>Still other annotations require more careful planning:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>@EnableEviction</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableExpiration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableIndexing</literal></simpara>
</listitem>
</itemizedlist>
<simpara>One annotation is used exclusively for unit testing:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>@EnableGemFireMockObjects</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The bottom-line is that a framework should not auto-configure every possible feature, especially when the features
consume additional system resources or require more careful planning (as determined by the use case).</simpara>
<simpara>However, all of these annotations are available for the application developer to use when needed.</simpara>
</section>
<section xml:id="geode-configuration-declarative-annotations-productivity">
<title>Productivity Annotations</title>
<simpara>This section calls out the annotations we believe to be most beneficial for your application development purposes when
using Apache Geode in Spring [Boot] applications.</simpara>
<section xml:id="geode-configuration-declarative-annotations-productivity-enableclusteraware">
<title><literal>@EnableClusterAware</literal> (SBDG)</title>
<simpara>The <literal>@EnableClusterAware</literal> annotation is arguably the most powerful and valuable annotation.</simpara>
<example>
<title>Declaring <literal>@EnableClusterAware</literal></title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableClusterAware
class SpringBootApacheGeodeClientCacheApplication {  }</programlisting>
</example>
<simpara>When you annotate your main <literal>@SpringBootApplication</literal> class with <literal>@EnableClusterAware</literal>, your Spring Boot, Apache Geode
<literal>ClientCache</literal> application is able to seamlessly switch between client/server and local-only topologies with no code
or configuration changes, regardless of the runtime environment (such as local/standalone versus cloud-managed
environments).</simpara>
<simpara>When a cluster of Apache Geode servers is detected, the client application sends and receives data to and from the
Apache Geode cluster. If a cluster is not available, the client automatically switches to storing data locally on the
client by using <literal>LOCAL</literal> Regions.</simpara>
<simpara>Additionally, the <literal>@EnableClusterAware</literal> annotation is meta-annotated with SDG&#8217;s
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableClusterConfiguration.html"><literal>@EnableClusterConfiguration</literal></link>
annotation.</simpara>
<simpara>The <literal>@EnableClusterConfiguration</literal> annotation lets configuration metadata defined on the client (such as Region and Index
definitions, as needed by the application based on requirements and use cases) be sent to the cluster of servers. If
those schema objects are not already present, they are created by the servers in the cluster in such a way that the
servers remember the configuration on restart as well as provide the configuration to new servers that join the cluster
when it is scaled out. This feature is careful not to stomp on any existing Region or Index objects already defined on
the servers, particularly since you may already have critical data stored in the Regions.</simpara>
<simpara>The primary motivation for the <literal>@EnableClusterAware</literal> annotation is to let you switch environments with minimal effort.
It is a common development practice to debug and test your application locally (in your IDE) and then push up to a
production-like (staging) environment for more rigorous integration testing.</simpara>
<simpara>By default, the configuration metadata is sent to the cluster by using a non-secure HTTP connection. However, you can
configure HTTPS, change the host and port, and configure the data management policy used by the servers when creating
Regions.</simpara>
<tip>
<simpara>See the section in the SDG reference documentation on
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-cluster">Configuring Cluster Configuration Push</link>
for more details.</simpara>
</tip>
<section xml:id="geode-configuration-declarative-annotations-productivity-enableclusteraware-strictmatch">
<title>@EnableClusterAware, strictMatch</title>
<simpara>The <literal>strictMatch</literal> attribute has been added to the <literal>@EnableClusterAware</literal> annotation to enable fail-fast behavior.
<literal>strictMatch</literal> is set to <literal>false</literal> by default.</simpara>
<simpara>Essentially, when you set <literal>strictMatch</literal> to <literal>true</literal>, your Spring Boot, Apache Geode <literal>ClientCache</literal> application requires
an Apache Geode cluster to exist. That is, the application requires a client/server topology to operate, and the
application should fail to start if a cluster is not present. The application should not startup in a local-only
capacity.</simpara>
<simpara>When <literal>strictMatch</literal> is set to <literal>true</literal> and an Apache Geode cluster is not available, your Spring Boot, Apache Geode
<literal>ClientCache</literal> application fails to start with a <literal>ClusterNotFoundException</literal>. The application does not attempt to
start in a local-only capacity.</simpara>
<simpara>You can explicitly set the <literal>strictMatch</literal> attribute programmatically by using the <literal>@EnableClusterAware</literal> annotation:</simpara>
<example>
<title>Set <literal>@EnableClusterAware.strictMatch</literal></title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableClusterAware(strictMatch = true)
class SpringBootApacheGeodeClientCacheApplication {  }</programlisting>
</example>
<simpara>Alternatively, you can set <literal>strictMatch</literal> attribute by using the corresponding property
in Spring Boot <literal>application.properties</literal>:</simpara>
<example>
<title>Set <literal>strictMatch</literal> using a property</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties

spring.boot.data.gemfire.cluster.condition.match.strict=true</programlisting>
</example>
<simpara>This is convenient when you need to apply this configuration setting conditionally, based on a Spring profile.</simpara>
<simpara>When you adjust the log level of the <literal>org.springframework.geode.config.annotation.ClusterAwareConfiguration</literal> logger
to <literal>INFO</literal>, you get more details from the <literal>@EnableClusterAware</literal> functionality when applying the logic to determine
the presence of an Apache Geode cluster, such as which explicitly or implicitly configured connections were successful.</simpara>
<simpara>The following example shows typical output:</simpara>
<example>
<title><literal>@EnableClusterAware</literal> INFO log output</title>
<programlisting language="txt" linenumbering="unnumbered">2021-01-20 14:02:28,740  INFO fig.annotation.ClusterAwareConfiguration: 476 - Failed to connect to localhost[40404]
2021-01-20 14:02:28,745  INFO fig.annotation.ClusterAwareConfiguration: 476 - Failed to connect to localhost[10334]
2021-01-20 14:02:28,746  INFO fig.annotation.ClusterAwareConfiguration: 470 - Successfully connected to localhost[57649]
2021-01-20 14:02:28,746  INFO fig.annotation.ClusterAwareConfiguration: 576 - Cluster was found; Auto-configuration made [1] successful connection(s);
2021-01-20 14:02:28,746  INFO fig.annotation.ClusterAwareConfiguration: 586 - Spring Boot application is running in a client/server topology, using a standalone Apache Geode-based cluster</programlisting>
</example>
<note>
<simpara>An attempt is always made to connect to <literal>localhost</literal> on the default <literal>Locator</literal> port, <literal>10334</literal>, and the default
<literal>CacheServer</literal> port, <literal>40404</literal>.</simpara>
</note>
<tip>
<simpara>You can force a successful match by setting the <literal>spring.boot.data.gemfire.cluster.condition.match</literal> property
to <literal>true</literal> in Spring Boot <literal>application.properties</literal>. This is sometimes useful for testing purposes.</simpara>
</tip>
</section>
</section>
<section xml:id="geode-configuration-declarative-annotations-productivity-regions">
<title><literal>@EnableCachingDefinedRegions</literal>, <literal>@EnableClusterDefinedRegions</literal> and <literal>@EnableEntityDefinedRegions</literal> (SDG)</title>
<simpara>These annotations are used to create Regions in the cache to manage your application data.</simpara>
<simpara>You can create Regions by using Java configuration and the Spring API as follows:</simpara>
<example>
<title>Creating a Region with Spring JavaConfig</title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
class GeodeConfiguration {

    @Bean("Customers")
    ClientRegionFactoryBean&lt;Long, Customer&gt; customersRegion(GemFireCache cache) {

        ClientRegionFactoryBean&lt;Long, Customer&gt; customers =
            new ClientRegionFactoryBean&lt;&gt;();

        customers.setCache(cache);
        customers.setShortcut(ClientRegionShortcut.PROXY);

        return customers;
    }
}</programlisting>
</example>
<simpara>You can do the same in XML:</simpara>
<example>
<title>Creating a client Region using Spring XML</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;gfe:client-region id="Customers" shorcut="PROXY"/&gt;</programlisting>
</example>
<simpara>However, using the provided annotations is far easier, especially during development, when the complete Region
configuration may be unknown and you want only to create a Region to persist your application data and move on.</simpara>
<section xml:id="geode-configuration-declarative-annotations-productivity-regions-enablecachingdefined">
<title><literal>@EnableCachingDefinedRegions</literal></title>
<simpara>The <literal>@EnableCachingDefinedRegions</literal> annotation is used when you have application components registered in the Spring
container that are annotated with Spring or JSR-107 JCache
<link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-jsr-107">annotations</link>.</simpara>
<simpara>Caches that are identified by name in the caching annotations are used to create Regions that hold the data
you want cached.</simpara>
<simpara>Consider the following example:</simpara>
<example>
<title>Defining Regions based on Spring or JSR-107 JCache Annotations</title>
<programlisting language="java" linenumbering="unnumbered">@Service
class CustomerService {

    @Cacheable(cacheNames = "CustomersByAccountNumber", key = "#account.number")
    Customer findBy(Account account) {
        // ...
    }
}</programlisting>
</example>
<simpara>Further consider the following example, in which the main <literal>@SpringBootApplication</literal> class is annotated with
<literal>@EnableCachingDefinedRegions</literal>:</simpara>
<example>
<title>Using <literal>@EnableCachingDefinedRegions</literal></title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableCachingDefineRegions
class SpringBootApacheGeodeClientCacheApplication {  }</programlisting>
</example>
<simpara>With this setup, SBDG would create a client <literal>PROXY</literal> Region (or <literal>PARTITION_REGION</literal> if your application were a peer member
of the Apache Geode cluster) with a name of <quote>CustomersByAccountNumber</quote>, as though you created the Region by using
either the Java configuration or XML approaches shown earlier.</simpara>
<simpara>You can use the <literal>clientRegionShortcut</literal> or <literal>serverRegionShortcut</literal> attribute to change the data management policy of
the Regions created on the client or servers, respectively.</simpara>
<simpara>For client Regions, you can also set the <literal>poolName</literal> attribute to assign a specific <literal>Pool</literal> of connections to be used by
the client <literal>*PROXY</literal> Regions to send data to the cluster.</simpara>
</section>
<section xml:id="geode-configuration-declarative-annotations-productivity-regions-enableentitydefined">
<title><literal>@EnableEntityDefinedRegions</literal></title>
<simpara>As with <literal>@EnableCachingDefinedRegions</literal>, <literal>@EnableEntityDefinedRegions</literal> lets you create Regions based on the entity
classes you have defined in your application domain model.</simpara>
<simpara>For instance, consider an entity class annotated with SDG&#8217;s
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/mapping/annotation/Region.html"><literal>@Region</literal></link>
mapping annotation:</simpara>
<example>
<title>Customer entity class annotated with <literal>@Region</literal></title>
<programlisting language="java" linenumbering="unnumbered">@Region("Customers")
class Customer {

    @Id
    private Long id;

    @Indexed
    private String name;

}</programlisting>
</example>
<simpara>For this class, SBDG creates Regions from the name specified in the <literal>@Region</literal> mapping annotation on the entity class.
In this case, the <literal>Customer</literal> application-defined entity class results in the creation of a Region named <quote>Customers</quote>
when the main <literal>@SpringBootApplication</literal> class is annotated with <literal>@EnableEntityDefinedRegions</literal>:</simpara>
<example>
<title>Using <literal>@EnableEntityDefinedRegions</literal></title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableEntityDefinedRegions(basePackageClasses = Customer.class,
    clientRegionShortcut = ClientRegionShortcut.CACHING_PROXY)
class SpringBootApacheGeodeClientCacheApplication {  }</programlisting>
</example>
<simpara>As with the <literal>@EnableCachingDefinedRegions</literal> annotation, you can set the client and server Region data management policy
by using the <literal>clientRegionShortcut</literal> and <literal>serverRegionShortcut</literal> attributes, respectively, and set a dedicated <literal>Pool</literal>
of connections used by client Regions with the <literal>poolName</literal> attribute.</simpara>
<simpara>However, unlike the <literal>@EnableCachingDefinedRegions</literal> annotation, you must specify either the <literal>basePackage</literal> attribute
or the type-safe <literal>basePackageClasses</literal> attribute (recommended) when you use the <literal>@EnableEntityDefinedRegions</literal> annotation.</simpara>
<simpara>Part of the reason for this is that <literal>@EnableEntityDefinedRegions</literal> performs a component scan for the entity classes
defined by your application. The component scan loads each class to inspect the annotation metadata for that class.
This is not unlike the JPA entity scan when working with JPA providers, such as Hibernate.</simpara>
<simpara>Therefore, it is customary to limit the scope of the scan. Otherwise, you end up potentially loading many classes
unnecessarily. After all, the JVM uses dynamic linking to load classes only when needed.</simpara>
<simpara>Both the <literal>basePackages</literal> and <literal>basePackageClasses</literal> attributes accept an array of values. With <literal>basePackageClasses</literal>, you
need only refer to a single class type in that package and every class in that package as well as classes in the
sub-packages are scanned to determine if the class type represents an entity. A class type is an entity if it is
annotated with the <literal>@Region</literal> mapping annotation. Otherwise, it is not considered to be an entity.</simpara>
<simpara>For example, suppose you had the following structure:</simpara>
<example>
<title>Entity Scan</title>
<programlisting language="txt" linenumbering="unnumbered">- example.app.crm.model
 |- Customer.class
 |- NonEntity.class
 |- contact
   |- Address.class
   |- PhoneNumber.class
   |- AnotherNonEntity.class
- example.app.accounts.model
 |- Account.class
...
..
.</programlisting>
</example>
<simpara>Then you could configure the <literal>@EnableEntityDefinedRegions</literal> as follows:</simpara>
<example>
<title>Targeting with <literal>@EnableEntityDefinedRegions</literal></title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableEntityDefinedRegions(basePackageClasses = { NonEntity.class, Account.class } )
class SpringBootApacheGeodeClientCacheApplication {  }</programlisting>
</example>
<simpara>If <literal>Customer</literal>, <literal>Address</literal>, <literal>PhoneNumber</literal> and <literal>Account</literal> were all entity classes properly annotated with <literal>@Region</literal>,
the component scan would pick up all these classes and create Regions for them. The <literal>NonEntity</literal> class serves only as
a marker in this case, to point to where (that is, which package) the scan should begin.</simpara>
<simpara>Additionally, the <literal>@EnableEntityDefinedRegions</literal> annotation provides include and exclude filters, the same as
the core Spring Frameworks <literal>@ComponentScan</literal> annotation.</simpara>
<tip>
<simpara>See the SDG reference documentation on
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-regions">Configuring Regions</link>
for more details.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-declarative-annotations-productivity-regions-enableclusterdefined">
<title><literal>@EnableClusterDefinedRegions</literal></title>
<simpara>Sometimes, it is ideal or even necessary to pull configuration from the cluster (rather than push configuration to the
cluster). That is, you want the Regions defined on the servers to be created on the client and used by your application.</simpara>
<simpara>To do so, annotate your main <literal>@SpringBootApplication</literal> class with <literal>@EnableClusterDefinedRegions</literal>:</simpara>
<example>
<title>Using <literal>@EnableClusterDefinedRegions</literal></title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableClusterDefinedRegions
class SpringBootApacheGeodeClientCacheApplication {  }</programlisting>
</example>
<simpara>Every Region that exists on the servers in the Apache Geode cluster will have a corresponding <literal>PROXY</literal> Region defined
and created on the client as a bean in your Spring Boot application.</simpara>
<simpara>If the cluster of servers defines a Region called <quote>ServerRegion</quote>, you can inject a client <literal>PROXY</literal> Region with
the same name (<quote>ServerRegion</quote>) into your Spring Boot application:</simpara>
<example>
<title>Using a server-side Region on the client</title>
<programlisting language="java" linenumbering="unnumbered">@Component
class SomeApplicationComponent {

    @Resource(name = "ServerRegion")
    private Region&lt;Integer, EntityType&gt; serverRegion;

    public void someMethod() {

        EntityType entity = new EntityType();

        this.serverRegion.put(1, entity);

        // ...
    }
}</programlisting>
</example>
<simpara>SBDG auto-configures a <literal>GemfireTemplate</literal> for the <quote>ServerRegion</quote> Region
(see <xref linkend="geode-configuration-declarative-auto-configuration-regiontemplates"/>),
so a better way to interact with the client <literal>PROXY</literal> Region that corresponds to the <quote>ServerRegion</quote> Region on the server
is to inject the template:</simpara>
<example>
<title>Using a server-side Region on the client with a template</title>
<programlisting language="java" linenumbering="unnumbered">@Component
class SomeApplicationComponent {

    @Autowired
    @Qualifier("serverRegionTemplate")
    private GemfireTemplate serverRegionTemplate;

    public void someMethod() {

        EntityType entity = new EntityType();

        this.serverRegionTemplate.put(1, entity);

        //...
    }
}</programlisting>
</example>
<tip>
<simpara>See the SDG reference documentation on
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-region-cluster-defined">Configuring Cluster-defined Regions</link>
for more details.</simpara>
</tip>
</section>
</section>
<section xml:id="geode-configuration-declarative-annotations-productivity-enableindexing">
<title><literal>@EnableIndexing</literal> (SDG)</title>
<simpara>You can also use the <literal>@EnableIndexing</literal> annotation&#8201;&#8212;&#8201;but only when you use <literal>@EnableEntityDefinedRegions</literal>. This is
because <literal>@EnableIndexing</literal> requires the entities to be scanned and analyzed for mapping metadata (defined on the class
type of the entity). This includes annotations such as the Spring Data Commons <literal>@Id</literal> annotation and the annotations
provided by SDG, such as <literal>@Indexed</literal> and <literal>@LuceneIndexed</literal>.</simpara>
<simpara>The <literal>@Id</literal> annotation identifies the (primary) key of the entity. The <literal>@Indexed</literal> annotation defines OQL indexes on object
fields, which can be used in the predicates of your OQL queries. The <literal>@LuceneIndexed</literal> annotation is used to define the
Apache Lucene Indexes required for searches.</simpara>
<note>
<simpara>Lucene Indexes can only be created on <literal>PARTITION</literal> Regions, and <literal>PARTITION</literal> Regions can only be defined on
the server side.</simpara>
</note>
<simpara>You may have noticed that the <literal>Customer</literal> entity class&#8217;s <literal>name</literal> field was annotated with <literal>@Indexed</literal>.</simpara>
<simpara>Consider the following listing:</simpara>
<example>
<title>Customer entity class with <literal>@Indexed</literal> annotated <literal>name</literal> field</title>
<programlisting language="java" linenumbering="unnumbered">@Region("Customers")
class Customer {

    @Id
    private Long id;

    @Indexed
    private String name;

}</programlisting>
</example>
<simpara>As a result, when our main <literal>@SpringBootApplication</literal> class is annotated with <literal>@EnableIndexing</literal>, an Apache Geode OQL Index
for the <literal>Customer.name</literal> field is created, allowing OQL queries on customers by name to use this Index:</simpara>
<example>
<title>Using <literal>@EnableIndexing</literal></title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableEntityDefinedRegions(basePackageClasses = Customer.class)
@EnableIndexing
class SpringBootApacheGeodeClientCacheApplication {  }</programlisting>
</example>
<note>
<simpara>Keep in mind that OQL Indexes are not persistent between restarts (that is, Apache Geode maintains Indexes
in memory only). An OQL Index is always rebuilt when the node is restarted.</simpara>
</note>
<simpara>When you combine <literal>@EnableIndexing</literal> with either <literal>@EnableClusterConfiguration</literal> or <literal>@EnableClusterAware</literal>, the Index
definitions are pushed to the server-side Regions where OQL queries are generally executed.</simpara>
<tip>
<simpara>See the SDG reference documentation on
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-region-indexes">Configuring Indexes</link>
for more details.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-declarative-annotations-productivity-enableexpiration">
<title><literal>@EnableExpiration</literal> (SDG)</title>
<simpara>It is often useful to define both eviction and expiration policies, particularly with a system like Apache Geode,
because it primarily keeps data in memory (on the JVM Heap). Your data volume size may far exceed the amount of
available JVM Heap memory, and keeping too much data on the JVM Heap can cause Garbage Collection (GC) issues.</simpara>
<tip>
<simpara>You can enable off-heap (or main memory usage) capabilities by declaring SDG&#8217;s <literal>@EnableOffHeap</literal> annotation.
See the SDG reference documentation on
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-region-off-heap">Configuring Off-Heap Memory</link>
for more details.</simpara>
</tip>
<simpara>Defining eviction and expiration policies lets you limit what is kept in memory and for how long.</simpara>
<simpara>While <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-region-eviction">configuring eviction</link> is easy with SDG,
we particularly want to call out expiration since
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-region-expiration">configuring expiration</link> has special support
in SDG.</simpara>
<simpara>With SDG, you can define the expiration policies associated with a particular application class type on the class type
itself, by using the <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/expiration/Expiration.html"><literal>@Expiration</literal></link>,
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/expiration/IdleTimeoutExpiration.html"><literal>@IdleTimeoutExpiration</literal></link>
and <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/expiration/TimeToLiveExpiration.html"><literal>@TimeToLiveExpiration</literal></link>
annotations.</simpara>
<tip>
<simpara>See the Apache Geode <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/expiration/how_expiration_works.html">User Guide</link>
for more details on the different expiration types&#8201;&#8212;&#8201;that is <emphasis>Idle Timeout</emphasis> (TTI) versus <emphasis>Time-to-Live</emphasis> (TTL).</simpara>
</tip>
<simpara>For example, suppose we want to limit the number of <literal>Customers</literal> maintained in memory for a period of time (measured in
seconds) based on the last time a <literal>Customer</literal> was accessed (for example, the last time a <literal>Customer</literal> was read). To do so,
we can define an idle timeout expiration (TTI) policy on our <literal>Customer</literal> class type:</simpara>
<example>
<title>Customer entity class with Idle Timeout Expiration (TTI)</title>
<programlisting language="java" linenumbering="unnumbered">@Region("Customers")
@IdleTimeoutExpiration(action = "INVALIDATE", timeout = "300")
class Customer {

    @Id
    private Long id;

    @Indexed
    private String name;

}</programlisting>
</example>
<simpara>The <literal>Customer</literal> entry in the <literal>Customers</literal> Region is <literal>invalidated</literal> after 300 seconds (5 minutes).</simpara>
<simpara>To enable annotation-based expiration policies, we need to annotate our main <literal>@SpringBootApplication</literal> class
with <literal>@EnableExpiration</literal>:</simpara>
<example>
<title>Enabling Expiration</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableExpiration
class SpringBootApacheGeodeApplication {  }</programlisting>
</example>
<note>
<simpara>Technically, this entity-class-specific annotation-based expiration policy is implemented by using Apache Geode&#8217;s
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/CustomExpiry.html"><literal>CustomExpiry</literal></link> interface.</simpara>
</note>
<tip>
<simpara>See the SDG reference doccumentation for more details on
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-region-expiration">configuring expiration</link>, along with
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap:region:expiration:annotation">annotation-based data expiration</link> in particular.</simpara>
</tip>
</section>
<section xml:id="geode-configuration-declarative-annotations-productivity-enablemockobjects">
<title><literal>@EnableGemFireMockObjects</literal> (STDG)</title>
<simpara>Software testing in general and unit testing in particular are a very important development tasks to ensure the quality
of your Spring Boot applications.</simpara>
<simpara>Apache Geode can make testing difficult in some cases, especially when tests have to be written as integration tests
to assert the correct behavior. This can be very costly and lengthens the feedback cycle. Fortunately, you can write
unit tests as well.</simpara>
<simpara>Spring provides a framework for testing Spring Boot applications that use Apache Geode. This is where the
<link xl:href="https://github.com/spring-projects/spring-test-data-geode#spring-test-framework-for-apache-geode&#8212;&#8203;vmware-tanzu-gemfire">Spring Test for Apache Geode (STDG)</link> project can help, particularly with
unit testing.</simpara>
<simpara>For example, if you do not care what Apache Geode would actually do in certain cases and only care about the <quote>contract</quote>,
which is what mocking a collaborator is all about, you could effectively mock Apache Geode objects to isolate the SUT,
or <quote>Subject Under Test</quote>, and focus on the interactions or outcomes you expect to happen.</simpara>
<simpara>With STDG, you need not change a bit of configuration to enable mock objects in the unit tests for your Spring Boot
applications. You need only annotate the test class with <literal>@EnableGemFireMockObjects</literal>:</simpara>
<example>
<title>Using Mock Apache Geode Objects</title>
<programlisting language="java" linenumbering="unnumbered">@RunWith(SpringRunner.class)
@SpringBootTest
class MyApplicationTestClass {

    @Test
    public void someTestCase() {
        // ...
    }

    @Configuration
    @EnableGemFireMockObjects
    static class GeodeConfiguration { }

}</programlisting>
</example>
<simpara>Your Spring Boot configuration of Apache Geode returns mock objects for all Apache Geode objects, such as Regions.</simpara>
<simpara>Mocking Apache Geode objects even works for objects created from the productivity annotations discussed in the previous
sections.</simpara>
<simpara>For example, consider the following Spring Boot, Apache Geode <literal>ClientCache</literal> application class:</simpara>
<example>
<title>Main <literal>@SpringBootApplication</literal> class under test</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableEntityDefinedRegions(basePackageClasses = Customer.class)
class SpringBootApacheGeodeClientCacheApplication {  }</programlisting>
</example>
<simpara>In the preceding example, the <literal>"Customers`" Region defined by the `Customer</literal> entity class and created by
the <literal>@EnableEntityDefinedRegions</literal> annotation would be a mock Region and not an actual Region. You can still inject
the Region in your test and assert interactions on the Region based on your application workflows:</simpara>
<example>
<title>Using Mock Apache Geode Objects</title>
<programlisting language="java" linenumbering="unnumbered">@RunWith(SpringRunner.class)
@SpringBootTest
class MyApplicationTestClass {

    @Resource(name = "Customers")
    private Region&lt;Long, Customer&gt; customers;

    @Test
    public void someTestCase() {

        Customer jonDoe = new Customer(1, "Jon Doe");

        // Use the application in some way and test the interaction on the "Customers" Region

        assertThat(this.customers).containsValue(jonDoe);

        // ...
    }
}</programlisting>
</example>
<simpara>There are many more things that STDG can do for you in both unit testing and integration testing.</simpara>
<simpara>See the <link xl:href="https://github.com/spring-projects/spring-test-data-geode#unit-testing-with-stdg">documentation on unit testing</link>
for more details.</simpara>
<simpara>You can <link xl:href="https://github.com/spring-projects/spring-test-data-geode#integration-testing-with-stdg">write integration tests</link>
that use STDG as well. Writing integration tests is an essential concern when you need to assert whether your
application OQL queries are well-formed, for instance. There are many other valid cases where integration testing
is also applicable.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="geode-configuration-externalized">
<title>Externalized Configuration</title>
<simpara>Like Spring Boot itself (see <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">Spring Boot&#8217;s documentation</link>),
Spring Boot for Apache Geode (SBDG) supports externalized configuration.</simpara>
<simpara>By externalized configuration, we mean configuration metadata stored in Spring Boot
<link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-application-property-files"><literal>application.properties</literal></link>.
You can even separate concerns by addressing each concern in an individual properties file. Optionally, you could also
enable any given property file for only a specific <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-profile-specific-properties">profile</link>.</simpara>
<simpara>You can do many other powerful things, such as (but not limited to) using
<link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-placeholders-in-properties">placeholders</link>
in properties, <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-encrypting-properties">encrypting</link>
properties, and so on. In this section, we focus particularly on
<link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-typesafe-configuration-properties">type safety</link>.</simpara>
<simpara>Like Spring Boot, Spring Boot for Apache Geode provides a hierarchy of classes that captures configuration for several
Apache Geode features in an associated <literal>@ConfigurationProperties</literal> annotated class. Again, the configuration metadata is
specified as well-known, documented properties in one or more Spring Boot <literal>application.properties</literal> files.</simpara>
<simpara>For instance, a Spring Boot, Apache Geode <literal>ClientCache</literal> application might be configured as follows:</simpara>
<example>
<title>Spring Boot <literal>application.properties</literal> containing Spring Data properties for Apache Geode</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties used to configure {geode-name}

spring.data.gemfire.name=MySpringBootApacheGeodeApplication

# Configure general cache properties
spring.data.gemfire.cache.copy-on-read=true
spring.data.gemfire.cache.log-level=debug

# Configure ClientCache specific properties
spring.data.gemfire.cache.client.durable-client-id=123
spring.data.gemfire.cache.client.keep-alive=true

# Configure a log file
spring.data.gemfire.logging.log-file=/path/to/geode.log

# Configure the client's connection Pool to the servers in the cluster
spring.data.gemfire.pool.locators=10.105.120.16[11235],boombox[10334]</programlisting>
</example>
<simpara>You can use many other properties to externalize the configuration of your Spring Boot, Apache Geode applications.
See the <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/package-frame.html">Javadoc</link>
for specific configuration properties. Specifically, review the <literal>enabling</literal> annotation attributes.</simpara>
<simpara>You may sometimes require access to the configuration metadata (specified in properties) in your Spring Boot
applications themselves, perhaps to further inspect or act on a particular configuration setting. You can access any
property by using Spring&#8217;s <link xl:href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/env/Environment.html"><literal>Environment</literal></link>
abstraction:</simpara>
<example>
<title>Using the Spring <literal>Environment</literal></title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
class GeodeConfiguration {

    void readConfigurationFromEnvironment(Environment environment) {
        boolean copyOnRead = environment.getProperty("spring.data.gemfire.cache.copy-on-read",
            Boolean.TYPE, false);
    }
}</programlisting>
</example>
<simpara>While using <literal>Environment</literal> is a nice approach, you might need access to additional properties or want to access
the property values in a type-safe manner. Therefore, you can now, thanks to SBDG&#8217;s auto-configured configuration
processor, access the configuration metadata by using <literal>@ConfigurationProperties</literal> classes.</simpara>
<simpara>To add to the preceding example, you can now do the following:</simpara>
<example>
<title>Using <literal>GemFireProperties</literal></title>
<programlisting language="java" linenumbering="unnumbered">@Component
class MyApplicationComponent {

    @Autowired
    private GemFireProperties gemfireProperties;

    public void someMethodUsingGemFireProperties() {

        boolean copyOnRead = this.gemfireProperties.getCache().isCopyOnRead();

        // do something with `copyOnRead`
    }
}</programlisting>
</example>
<simpara>Given a handle to <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/configuration/GemFireProperties.html"><literal>GemFireProperties</literal></link>,
you can access any of the configuration properties that are used to configure Apache Geode in a Spring context. You need
only autowire an instance of <literal>GemFireProperties</literal> into your application component.</simpara>
<simpara>See the complete reference for the
<link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/configuration/package-frame.html">SBDG <literal>@ConfigurationProperties</literal> classes and supporting classes</link>.</simpara>
<section xml:id="geode-configuration-externalized-session">
<title>Externalized Configuration of Spring Session</title>
<simpara>You can access the externalized configuration of Spring Session when you use Apache Geode as your (HTTP) session state
caching provider.</simpara>
<simpara>In this case, you need only acquire a reference to an instance of the
<link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/configuration/SpringSessionProperties.html"><literal>SpringSessionProperties</literal></link>
class.</simpara>
<simpara>As shown earlier in this chapter, you can specify Spring Session for Apache Geode (SSDG) properties as follows:</simpara>
<example>
<title>Spring Boot <literal>application.properties</literal> for Spring Session using Apache Geode as the (HTTP) session state caching provider</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties used to configure {geode-name} as a (HTTP) session state caching provider
# in Spring Session

spring.session.data.gemfire.session.expiration.max-inactive-interval-seconds=300
spring.session.data.gemfire.session.region.name=UserSessions</programlisting>
</example>
<simpara>Then, in your application, you can do something similar to the following example:</simpara>
<example>
<title>Using <literal>SpringSessionProperties</literal></title>
<programlisting language="java" linenumbering="unnumbered">@Component
class MyApplicationComponent {

    @Autowired
    private SpringSessionProperties springSessionProperties;

    public void someMethodUsingSpringSessionProperties() {

        String sessionRegionName = this.springSessionProperties
            .getSession().getRegion().getName();

        // do something with `sessionRegionName`
    }
}</programlisting>
</example>
</section>
</chapter>
<chapter xml:id="geode-configuration-gemfire-properties">
<title>Using Geode Properties</title>
<simpara>As of Spring Boot for Apache Geode (SBDG) 1.3, you can declare Apache Geode properties from <literal>gemfire.properties</literal>
in Spring Boot <literal>application.properties</literal>.</simpara>
<tip>
<simpara>See the <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/reference/topics/gemfire_properties.html">User Guide</link> for a complete list
of valid Apache Geode properties.</simpara>
</tip>
<simpara>Note that you can declare only valid Geode properties in <literal>gemfire.properties</literal> or, alternatively,
<literal>gfsecurity.properties</literal>.</simpara>
<simpara>The following example shows how to declare properties in <literal>gemfire.properties</literal>:</simpara>
<example>
<title>Valid <literal>gemfire.properties</literal></title>
<programlisting language="properties" linenumbering="unnumbered"># Geode Properties in gemfire.properties

name=ExampleCacheName
log-level=TRACE
enable-time-statistics=true
durable-client-id=123
# ...</programlisting>
</example>
<simpara>All of the properties declared in the preceding example correspond to valid Geode properties. It is illegal to declare
properties in <literal>gemfire.properties</literal> that are not valid Geode properties, even if those properties are prefixed with a
different qualifier (such as <literal>spring.*</literal>). Apache Geode throws an <literal>IllegalArgumentException</literal> for invalid properties.</simpara>
<simpara>Consider the following <literal>gemfire.properties</literal> file with an <literal>invalid-property</literal>:</simpara>
<example>
<title>Invalid <literal>gemfire.properties</literal></title>
<programlisting language="properties" linenumbering="unnumbered"># Geode Properties in gemfire.properties

name=ExampleCacheName
invalid-property=TEST</programlisting>
</example>
<simpara>Apache Geode throws an <literal>IllegalArgumentException</literal>:</simpara>
<example>
<title><literal>IllegalArgumentException</literal> thrown by Apache Geode for Invalid Property (Full Text Omitted)</title>
<programlisting language="txt" linenumbering="unnumbered">Exception in thread "main" java.lang.IllegalArgumentException: Unknown configuration attribute name invalid-property.
Valid attribute names are: ack-severe-alert-threshold ack-wait-threshold archive-disk-space-limit ...
	at o.a.g.internal.AbstractConfig.checkAttributeName(AbstractConfig.java:333)
	at o.a.g.distributed.internal.AbstractDistributionConfig.checkAttributeName(AbstractDistributionConfig.java:725)
	at o.a.g.distributed.internal.AbstractDistributionConfig.getAttributeType(AbstractDistributionConfig.java:887)
	at o.a.g.internal.AbstractConfig.setAttribute(AbstractConfig.java:222)
	at o.a.g.distributed.internal.DistributionConfigImpl.initialize(DistributionConfigImpl.java:1632)
	at o.a.g.distributed.internal.DistributionConfigImpl.&lt;init&gt;(DistributionConfigImpl.java:994)
	at o.a.g.distributed.internal.DistributionConfigImpl.&lt;init&gt;(DistributionConfigImpl.java:903)
	at o.a.g.distributed.internal.ConnectionConfigImpl.lambda$new$2(ConnectionConfigImpl.java:37)
	at o.a.g.distributed.internal.ConnectionConfigImpl.convert(ConnectionConfigImpl.java:73)
	at o.a.g.distributed.internal.ConnectionConfigImpl.&lt;init&gt;(ConnectionConfigImpl.java:36)
	at o.a.g.distributed.internal.InternalDistributedSystem$Builder.build(InternalDistributedSystem.java:3004)
	at o.a.g.distributed.internal.InternalDistributedSystem.connectInternal(InternalDistributedSystem.java:269)
	at o.a.g.cache.client.ClientCacheFactory.connectInternalDistributedSystem(ClientCacheFactory.java:280)
	at o.a.g.cache.client.ClientCacheFactory.basicCreate(ClientCacheFactory.java:250)
	at o.a.g.cache.client.ClientCacheFactory.create(ClientCacheFactory.java:216)
	at org.example.app.ApacheGeodeClientCacheApplication.main(...)</programlisting>
</example>
<simpara>It is inconvenient to have to separate Apache Geode properties from other application properties, or to have to declare
only Apache Geode properties in a <literal>gemfire.properties</literal> file and application properties in a separate properties file,
such as Spring Boot <literal>application.properties</literal>.</simpara>
<simpara>Additionally, because of Apache Geode&#8217;s constraint on properties, you cannot use the full power of Spring Boot when you
compose <literal>application.properties</literal>.</simpara>
<simpara>You can include certain properties based on a Spring profile while excluding other properties. This is essential when
properties are environment- or context-specific.</simpara>
<simpara>Spring Data for Apache Geode already provides a wide range of properties mapping to Apache Geode properties.</simpara>
<simpara>For example, the SDG <literal>spring.data.gemfire.locators</literal> property maps to the <literal>gemfire.locators</literal> property
(<literal>locators</literal> in <literal>gemfire.properties</literal>) from Apache Geode. Likewise, there are a full set of SDG properties that map to
the corresponding Apache Geode properties in the <link linkend="geode-configuration-metadata-springdata">Appendix</link>.</simpara>
<simpara>You can express the Geode properties shown earlier as SDG properties in Spring Boot <literal>application.properties</literal>,
as follows:</simpara>
<example>
<title>Configuring Geode Properties using SDG Properties</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Data for {geode-name} properties in application.properties

spring.data.gemfire.name=ExampleCacheName
spring.data.gemfire.cache.log-level=TRACE
spring.data.gemfire.cache.client.durable-client-id=123
spring.data.gemfire.stats.enable-time-statistics=true
# ...</programlisting>
</example>
<simpara>However, some Apache Geode properties have no equivalent SDG property, such as <literal>gemfire.groups</literal> (<literal>groups</literal> in
<literal>gemfire.properties</literal>). This is partly due to the fact that many Apache Geode properties are applicable only when
configured on the server (such as <literal>groups</literal> or <literal>enforce-unique-host</literal>).</simpara>
<tip>
<simpara>See the <literal>@EnableGemFireProperties</literal> annotation
(<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableGemFireProperties.html">attributes</link>)
from SDG for a complete list of Apache Geode properties with no corresponding SDG property.</simpara>
</tip>
<simpara>Furthermore, many of the SDG properties also correspond to API calls.</simpara>
<simpara>For example, <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#keepAlive"><literal>spring.data.gemfire.cache.client.keep-alive</literal></link>
translates to the <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/client/ClientCache.html#close-boolean"><literal>ClientCache.close(boolean keepAlive)</literal></link>
API call.</simpara>
<simpara>Still, it would be convenient to be able to declare application and Apache Geode properties together, in a single
properties file, such as Spring Boot <literal>application.properties</literal>. After all, it is not uncommon to declare JDBC Connection
properties in a Spring Boot <literal>application.properties</literal> file.</simpara>
<simpara>Therefore, as of SBDG 1.3, you can now declare Apache Geode properties in Spring Boot <literal>application.properties</literal> directly,
as follows:</simpara>
<example>
<title>Geode Properties declared in Spring Boot <literal>application.properties</literal></title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties

server.port=8181
spring.application.name=ExampleApp
gemfire.durable-client-id=123
gemfire.enable-time-statistics=true</programlisting>
</example>
<simpara>This is convenient and ideal for several reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>If you already have a large number of Apache Geode properties declared as <literal>gemfire.</literal> properties (either in
<literal>gemfire.properties</literal> or <literal>gfsecurity.properties</literal>) or declared on the Java command-line as JVM System properties
(such as <literal>-Dgemfire.name=ExampleCacheName</literal>), you can reuse these property declarations.</simpara>
</listitem>
<listitem>
<simpara>If you are unfamiliar with SDG&#8217;s corresponding properties, you can declare Geode properties instead.</simpara>
</listitem>
<listitem>
<simpara>You can take advantage of Spring features, such as Spring profiles.</simpara>
</listitem>
<listitem>
<simpara>You can also use property placeholders with Geode properties (such as
<literal>gemfire.log-level=${external.log-level.property}</literal>).</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>We encourage you to use the SDG properties, which cover more than Apache Geode properties.</simpara>
</tip>
<simpara>However, SBDG requires that the Geode property must have the <literal>gemfire.</literal> prefix in Spring Boot <literal>application.properties</literal>.
This indicates that the property belongs to Apache Geode. Without the <literal>gemfire.</literal> prefix, the property is not
appropriately applied to the Apache Geode cache instance.</simpara>
<simpara>It would be ambiguous if your Spring Boot applications integrated with several technologies, including Apache Geode,
and they too had matching properties, such as <literal>bind-address</literal> or <literal>log-file</literal>.</simpara>
<simpara>SBDG makes a best attempt to log warnings when a Geode property is invalid or is not set. For example, the following
Geode property would result in logging a warning:</simpara>
<example>
<title>Invalid Apache Geode Property</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties

spring.application.name=ExampleApp
gemfire.non-existing-property=TEST</programlisting>
</example>
<simpara>The resulting warning in the log would read:</simpara>
<example>
<title>Invalid Geode Property Warning Message</title>
<programlisting language="text" linenumbering="unnumbered">[gemfire.non-existing-property] is not a valid Apache Geode property</programlisting>
</example>
<simpara>If a Geode Property is not properly set, the following warning is logged:</simpara>
<example>
<title>Invalide Geode Property Value Warning Message</title>
<programlisting language="text" linenumbering="unnumbered">Apache Geode Property [gemfire.security-manager] was not set</programlisting>
</example>
<simpara>With regards to the third point mentioned earlier, you can now compose and declare Geode properties based on a context
(such as your application environment) using Spring profiles.</simpara>
<simpara>For example, you might start with a base set of properties in Spring Boot <literal>application.properties</literal>:</simpara>
<example>
<title>Base Properties</title>
<programlisting language="properties" linenumbering="unnumbered">server.port=8181
spring.application.name=ExampleApp
gemfire.durable-client-id=123
gemfire.enable-time-statistics=false</programlisting>
</example>
<simpara>Then you can vary the properties by environment, as the next two listings (for QA and production) show:</simpara>
<example>
<title>QA Properties</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application-qa.properties

server.port=9191
spring.application.name=TestApp
gemfire.enable-time-statistics=true
gemfire.enable-network-partition-detection=true
gemfire.groups=QA
# ...</programlisting>
</example>
<example>
<title>Production Properties</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application-prod.properties

server.port=80
spring.application.name=ProductionApp
gemfire.archive-disk-space-limit=1000
gemfire.archive-file-size-limit=50
gemfire.enforce-unique-host=true
gemfire.groups=PROD
# ...</programlisting>
</example>
<simpara>You can then apply the appropriate set of properties by configuring the Spring profile with
<literal>-Dspring.profiles.active=prod</literal>. You can also enable more than one profile at a time with
<literal>-Dspring.profiles.active=profile1,profile2,&#8230;&#8203;,profileN</literal></simpara>
<simpara>If both <literal>spring.data.gemfire.*</literal> properties and the matching Apache Geode properties are declared in Spring Boot
<literal>application.properties</literal>, the SDG properties take precedence.</simpara>
<simpara>If a property is specified more than once, as would potentially be the case when composing multiple Spring Boot
<literal>application.properties</literal> files and you enable more than one Spring profile at time, the last property declaration wins.
In the example shown earlier, the value for <literal>gemfire.groups</literal> would be <literal>PROD</literal> when <literal>-Dspring.profiles.active=qa,prod</literal>
is configured.</simpara>
<simpara>Consider the following Spring Boot <literal>application.properties</literal>:</simpara>
<example>
<title>Property Precedence</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties

gemfire.durable-client-id=123
spring.data.gemfire.cache.client.durable-client-id=987</programlisting>
</example>
<simpara>The <literal>durable-client-id</literal> is <literal>987</literal>. It does not matter which order the SDG or Apache Geode properties are declared in
Spring Boot <literal>application.properties</literal>. The matching SDG property overrides the Apache Geode property when duplicates
are found.</simpara>
<simpara>Finally, you cannot refer to Geode properties declared in Spring Boot <literal>application.properties</literal> with the SBDG
<literal>GemFireProperties</literal> class (see the <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/boot/autoconfigure/configuration/GemFireProperties.html">Javadoc</link>).</simpara>
<simpara>Consider the following example:</simpara>
<example>
<title>Geode Properties declared in Spring Boot <literal>application.properties</literal></title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties

gemfire.name=TestCacheName</programlisting>
</example>
<simpara>Given the preceding property, the following assertion holds:</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">import org.springframework.geode.boot.autoconfigure.configuration.GemFireProperties;

@RunWith(SpringRunner.class)
@SpringBootTest
class GemFirePropertiesTestSuite {

	@Autowired
    private GemFireProperties gemfireProperties;

	@Test
	public void gemfirePropertiesTestCase() {
		assertThat(this.gemfireProperties.getCache().getName()).isNotEqualTo("TestCacheName");
	}
}</programlisting>
</informalexample>
<tip>
<simpara>You can declare <literal>application.properties</literal> in the <literal>@SpringBootTest</literal> annotation. For example, you could have declared
<literal>gemfire.name</literal> in the annotation by setting <literal>@SpringBootTest(properties = { "gemfire.name=TestCacheName" })</literal>
for testing purposes instead of declaring the property in a separate Spring Boot <literal>application.properties</literal> file.</simpara>
</tip>
<simpara>Only <literal>spring.data.gemfire.*</literal> prefixed properties are mapped to the SBDG <literal>GemFireProperties</literal> class hierarchy.</simpara>
<tip>
<simpara>Prefer SDG properties over Geode properties. See the SDG properties reference
in the <link linkend="geode-configuration-metadata-springdata">Appendix</link>.</simpara>
</tip>
</chapter>
<chapter xml:id="geode-caching-provider">
<title>Caching with Apache Geode</title>
<simpara>One of the easiest, quickest and least invasive ways to start using Apache Geode in your Spring Boot applications
is to use Apache Geode as a <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration">caching provider</link>
in <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache">Spring&#8217;s Cache Abstraction</link>. SDG
<link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration-gemfire">enables</link>
Apache Geode to function as a caching provider in Spring&#8217;s Cache Abstraction.</simpara>
<tip>
<simpara>See the <emphasis>Spring Data for Apache Geode Reference Guide</emphasis> for more details on
the <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#apis:spring-cache-abstraction">support</link>
and <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-caching">configuration</link>
of Apache Geode as a caching provider in Spring&#8217;s Cache Abstraction.</simpara>
</tip>
<tip>
<simpara>Make sure you thoroughly understand the <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-strategies">concepts</link>
behind Spring&#8217;s Cache Abstraction before you continue.</simpara>
</tip>
<tip>
<simpara>See also the relevant section on <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/#boot-features-caching">caching</link>
in Spring Boot&#8217;s reference documentation. Spring Boot even provides auto-configuration support for a few of the simple
<link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/#_supported_cache_providers">caching providers</link>.</simpara>
</tip>
<simpara>Indeed, caching can be an effective software design pattern to avoid the cost of invoking a potentially expensive
operation when, given the same input, the operation yields the same output, every time.</simpara>
<simpara>Some classic examples of caching include, but are not limited to, looking up a customer by name or account number,
looking up a book by ISBN, geocoding a physical address, and caching the calculation of a person&#8217;s credit score
when the person applies for a financial loan.</simpara>
<simpara>If you need the proven power of an enterprise-class caching solution, with strong consistency, high availability,
low latency, and multi-site (WAN) capabilities, then you should consider <link xl:href="https://geode.apache.org/">Apache Geode</link>.
Alternatively, VMWare, Inc. offers a commercial solution, built on Apache Geode, called VMware Tanzu GemFire.</simpara>
<simpara>Spring&#8217;s <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-annotations">declarative, annotation-based caching</link> makes it
simple to get started with caching, which is as easy as annotating your application components with the appropriate
Spring cache annotations.</simpara>
<tip>
<simpara>Spring&#8217;s declarative, annotation-based caching also
<link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-jsr-107">supports</link> JSR-107 JCache annotations.</simpara>
</tip>
<simpara>For example, suppose you want to cache the results of determining a person&#8217;s eligibility when applying for a loan. A
person&#8217;s financial status is unlikely to change in the time that the computer runs the algorithms to compute a person&#8217;s
eligibility after all the financial information for the person has been collected, submitted for review and processed.</simpara>
<simpara>Our application might consist of a financial loan service to process a person&#8217;s eligibility over a given period of time:</simpara>
<example>
<title>Spring application service component applicable to caching</title>
<programlisting language="java" linenumbering="unnumbered">@Service
class FinancialLoanApplicationService {

    @Cacheable("EligibilityDecisions")
    EligibilityDecision processEligibility(Person person, Timespan timespan) {
        // ...
    }
}</programlisting>
</example>
<simpara>Notice the <literal>@Cacheable</literal> annotation declared on the <literal>processEligibility(:Person, :Timespan)</literal> method of our service class.</simpara>
<simpara>When the <literal>FinancialLoanApplicationService.processEligibility(..)</literal> method is called, Spring&#8217;s caching infrastructure
first consults the "EligibilityDecisions" cache to determine if a decision has already been computed for the given
person within the given span of time. If the person&#8217;s eligibility in the given time frame has already been determined,
the existing decision is returned from the cache. Otherwise, the <literal>processEligibility(..)</literal> method is invoked
and the result of the method is cached when the method returns, before returning the decision to the caller.</simpara>
<simpara>Spring Boot for Apache Geode auto-configures Apache Geode as the caching provider when Apache Geode is declared on
the application classpath and when no other caching provider (such as Redis) has been configured.</simpara>
<simpara>If Spring Boot for Apache Geode detects that another cache provider has already been configured, then Apache Geode
will not function as the caching provider for the application. This lets you configure another store, such as
Redis, as the caching provider and perhaps use Apache Geode as your application&#8217;s persistent store.</simpara>
<simpara>The only other requirement to enable caching in a Spring Boot application is for the declared caches (as specified
in Spring&#8217;s or JSR-107&#8217;s caching annotations) to have been created and already exist, especially before the operation
on which caching was applied is invoked. This means the backend data store must provide the data structure that serves
as the cache. For Apache Geode, this means a cache <literal>Region</literal>.</simpara>
<simpara>To configure the necessary Regions that back the caches declared in Spring&#8217;s cache annotations, use Spring Data
for Apache Geode&#8217;s <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableCachingDefinedRegions.html"><literal>@EnableCachingDefinedRegions</literal></link>
annotation.</simpara>
<simpara>The following listing shows a complete Spring Boot application:</simpara>
<example>
<title>Spring Boot cache enabled application using Apache Geode</title>
<programlisting language="java" linenumbering="unnumbered">package example.app;

@SpringBootApplication
@EnableCachingDefinedRegions
class FinancialLoanApplication {

    public static void main(String[] args) {
        SpringApplication.run(FinancialLoanApplication.class, args);
    }
}</programlisting>
</example>
<tip>
<simpara>The <literal>FinancialLoanApplicationService</literal> is picked up by Spring&#8217;s classpath component scan, since this class
is annotated with Spring&#8217;s <literal>@Service</literal> stereotype annotation.</simpara>
</tip>
<tip>
<simpara>You can set the <literal>DataPolicy</literal> of the Region created through the <literal>@EnableCachingDefinedRegions</literal> annotation
by setting the <literal>clientRegionShortcut</literal> attribute to a valid enumerated value.</simpara>
</tip>
<note>
<simpara>Spring Boot for Apache Geode does not recognize nor apply the <literal>spring.cache.cache-names</literal> property. Instead, you
should use SDG&#8217;s <literal>@EnableCachingDefinedRegions</literal> on an appropriate Spring Boot application <literal>@Configuration</literal> class.</simpara>
</note>
<section xml:id="geode-caching-provider-look-aside-near-inline-multi-site">
<title>Look-Aside Caching, Near Caching, Inline Caching, and Multi-Site Caching</title>
<simpara>Four different types of caching patterns can be applied with Spring when using Apache Geode for your application caching
needs:</simpara>
<itemizedlist>
<listitem>
<simpara>Look-aside caching</simpara>
</listitem>
<listitem>
<simpara>Near caching</simpara>
</listitem>
<listitem>
<simpara>[Async] Inline caching</simpara>
</listitem>
<listitem>
<simpara>Multi-site caching</simpara>
</listitem>
</itemizedlist>
<simpara>Typically, when most users think of caching, they think of Look-aside caching. This is the default caching
pattern applied by Spring&#8217;s Cache Abstraction.</simpara>
<simpara>In a nutshell, Near caching keeps the data closer to where the data is used, thereby improving on performance due to
lower latencies when data is needed (no extra network hops). This also improves application throughput&#8201;&#8212;&#8201;that is,
the amount of work completed in a given period of time.</simpara>
<simpara>Within Inline caching_, developers have a choice between synchronous (read/write-through) and asynchronous (write-behind)
configurations depending on the application use case and requirements. Synchronous, read/write-through Inline caching
is necessary if consistency is a concern. Asynchronous, write-behind Inline caching is applicable if throughput
and low-latency are a priority.</simpara>
<simpara>Within Multi-site caching, there are active-active and active-passive arrangements. More details on Multi-site caching
will be presented in a later release.</simpara>
<section xml:id="geode-caching-provider-look-aside-caching">
<title>Look-Aside Caching</title>
<tip>
<simpara>See the corresponding sample <link xl:href="guides/caching-look-aside.html">guide</link>
and {github-samples-url}/caching/look-aside[code] to see Look-aside caching with Apache Geode in action.</simpara>
</tip>
<simpara>The caching pattern demonstrated in the preceding example is a form of
<link xl:href="https://content.pivotal.io/blog/an-introduction-to-look-aside-vs-inline-caching-patterns">Look-aside caching</link>
(or "<emphasis>Cache Aside</emphasis>").</simpara>
<simpara>Essentially, the data of interest is searched for in the cache first, before calling a potentially expensive
operation, such as an operation that makes an IO- or network-bound request that results in either a blocking
or a latency-sensitive computation.</simpara>
<simpara>If the data can be found in the cache (stored in-memory to reduce latency), the data is returned without ever invoking
the expensive operation. If the data cannot be found in the cache, the operation must be invoked. However, before
returning, the result of the operation is cached for subsequent requests when the same input is requested again by
another caller, resulting in much improved response times.</simpara>
<simpara>The typical Look-aside caching pattern applied in your Spring application code looks similar to the following:</simpara>
<example>
<title>Look-Aside Caching Pattern Applied</title>
<programlisting language="java" linenumbering="unnumbered">@Service
class CustomerService {

  private final CustomerRepository customerRepository;

  @Cacheable("Customers")
  Customer findByAcccount(Account account) {

    // pre-processing logic here

    Customer customer = customerRepository.findByAccoundNumber(account.getNumber());

    // post-processing logic here

    return customer;
  }
}</programlisting>
</example>
<simpara>In this design, the <literal>CustomerRepository</literal> is perhaps a JDBC- or JPA/Hibernate-backed implementation that accesses
the external data source (for example, an RDBMS) directly. The <literal>@Cacheable</literal> annotation wraps, or "decorates",
the <literal>findByAccount(:Account):Customer</literal> operation (method) to provide caching behavior.</simpara>
<note>
<simpara>This operation may be expensive because it may validate the customer&#8217;s account before looking up the customer,
pull multiple bits of information to retrieve the customer record, and so on&#8201;&#8212;&#8201;hence the need for caching.</simpara>
</note>
</section>
<section xml:id="geode-caching-provider-near-caching">
<title>Near Caching</title>
<tip>
<simpara>See the corresponding sample <link xl:href="guides/caching-near.html">guide</link> and {github-samples-url}/caching/near[code]
to see Near caching with Apache Geode in action.</simpara>
</tip>
<simpara>Near caching is another pattern of caching where the cache is collocated with the application. This is useful when
the caching technology is configured in a client/server arrangement.</simpara>
<simpara>We already mentioned that Spring Boot for Apache Geode <link xl:href="clientcache-applications.xml#geode-clientcache-applications">provides</link>
an auto-configured <literal>ClientCache</literal> instance by default. A <literal>ClientCache</literal> instance is most effective when the data access
operations, including cache access, are distributed to the servers in a cluster that is accessible to the client and,
in most cases, multiple clients. This lets other cache client applications access the same data. However, this also
means the application incurs a network hop penalty to evaluate the presence of the data in the cache.</simpara>
<simpara>To help avoid the cost of this network hop in a client/server topology, a local cache can be established to maintain
a subset of the data in the corresponding server-side cache (that is, a Region). Therefore, the client cache contains
only the data of interest to the application. This "local" cache (that is, a client-side Region) is consulted before
forwarding the lookup request to the server.</simpara>
<simpara>To enable Near caching when using Apache Geode, change the Region&#8217;s (that is the <literal>Cache</literal> in Spring&#8217;s Cache Abstraction)
data management policy from <literal>PROXY</literal> (the default) to <literal>CACHING_PROXY</literal>:</simpara>
<example>
<title>Enable Near Caching with Apache Geode</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableCachingDefinedRegions(clientRegionShortcut = ClientRegionShortcut.CACHING_PROXY)
class FinancialLoanApplication {

    public static void main(String[] args) {
        SpringApplication.run(FinancialLoanApplication.class, args);
    }
}</programlisting>
</example>
<tip>
<simpara>The default client Region data management policy is
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/client/ClientRegionShortcut.html#PROXY"><literal>ClientRegionShortcut.PROXY</literal></link>.
As a result, all data access operations are immediately forwarded to the server.</simpara>
</tip>
<tip>
<simpara>See also the Apache Geode documentation concerning
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/events/how_client_server_distribution_works.html">client/server event distribution</link>
and, specifically, <quote>Client Interest Registration on the Server,</quote> which applies when you use client <literal>CACHING_PROXY</literal>
Regions to manage state in addition to the corresponding server-side Region. This is necessary to receive updates on
entries in the Region that might have been changed by other clients that have access to the same data.</simpara>
</tip>
</section>
<section xml:id="geode-caching-provider-inline-caching">
<title>Inline Caching</title>
<simpara>The next pattern of caching covered in this chapter is Inline caching.</simpara>
<simpara>You can apply two different configurations of Inline caching to your Spring Boot applications when you use
the Inline caching pattern: synchronous (read/write-through) and asynchronous (write-behind).</simpara>
<note>
<simpara>Asynchronous (currently) offers only write capabilities, from the cache to the external data source. There is no
option to asynchronously and automatically load the cache when the value becomes available in the external data source.</simpara>
</note>
<section xml:id="geode-caching-provider-inline-caching-synchronous">
<title>Synchronous Inline Caching</title>
<tip>
<simpara>See the corresponding sample <link xl:href="guides/caching-inline.html">guide</link> and {github-samples-url}/caching/inline[code]
to see Inline caching with Apache Geode in action.</simpara>
</tip>
<simpara>When employing Inline caching and a cache miss occurs, the application service method might not be invoked still, since
a cache can be configured to invoke a loader to load the missing entry from an external data source.</simpara>
<simpara>With Apache Geode, you can configure the cache (or, to use Apache Geode terminology, the Region) with a
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/CacheLoader.html"><literal>CacheLoader</literal></link>. A <literal>CacheLoader</literal> is implemented to
retrieve missing values from an external data source when a cache miss occurs. The external data source could be
an RDBMS or any other type of data store (for example, another NoSQL data store, such as Apache Cassandra, MongoDB,
or Neo4j).</simpara>
<tip>
<simpara>See Apache Geode&#8217;s User Guide on
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/outside_data_sources/how_data_loaders_work.html">data loaders</link> for more details.</simpara>
</tip>
<simpara>Likewise, you can also configure an Apache Geode Region with a
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/CacheWriter.html"><literal>CacheWriter</literal></link>.  A <literal>CacheWriter</literal> is responsible for
writing an entry that has been put into the Region to the backend data store, such as an RDBMS. This is referred to
as a write-through operation, because it is synchronous. If the backend data store fails to be updated, the entry is
not stored in the Region. This helps to ensure consistency between the backend data store and the Apache Geode Region.</simpara>
<tip>
<simpara>You can also implement Inline caching using asynchronous write-behind operations by registering
an <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/asyncqueue/AsyncEventListener.html"><literal>AsyncEventListener</literal></link>
on an <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/asyncqueue/AsyncEventQueue.html"><literal>AsyncEventQueue</literal></link> attached to
a server-side Region. See Apache Geode&#8217;s User Guide for more
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/events/implementing_write_behind_event_handler.html">details</link>. We cover asynchronous
write-behind Inline caching in the next section.</simpara>
</tip>
<simpara>The typical pattern of Inline caching when applied to application code looks similar to the following:</simpara>
<example>
<title>Inline Caching Pattern Applied</title>
<programlisting language="java" linenumbering="unnumbered">@Service
class CustomerService {

  private CustomerRepository customerRepository;

  Customer findByAccount(Account account) {

      // pre-processing logic here

      Customer customer = customerRepository.findByAccountNumber(account.getNumber());

      // post-processing logic here.

      return customer;
  }
}</programlisting>
</example>
<simpara>The main difference is that no Spring or JSR-107 caching annotations are applied to the application&#8217;s service methods,
and the <literal>CustomerRepository</literal> accesses Apache Geode directly and the RDBMS indirectly.</simpara>
<section xml:id="geode-caching-provider-inline-caching-synchronous-cacheloader-cachewriter">
<title>Implementing CacheLoaders and CacheWriters for Inline Caching</title>
<simpara>You can use Spring to configure a <literal>CacheLoader</literal> or <literal>CacheWriter</literal> as a bean in the Spring <literal>ApplicationContext</literal> and then
wire the loader or writer to a Region. Given that the <literal>CacheLoader</literal> or <literal>CacheWriter</literal> is a Spring bean like any other
bean in the Spring <literal>ApplicationContext</literal>, you can inject any <literal>DataSource</literal> you like into the loader or writer.</simpara>
<simpara>While you can configure client Regions with <literal>CacheLoaders</literal> and <literal>CacheWriters</literal>, it is more common to configure
the corresponding server-side Region:</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@CacheServerApplication
class FinancialLoanApplicationServer {

    public static void main(String[] args) {
        SpringApplication.run(FinancialLoanApplicationServer.class, args);
    }

	@Bean("EligibilityDecisions")
	PartitionedRegionFactoryBean&lt;Object, Object&gt; eligibilityDecisionsRegion(
            GemFireCache gemfireCache, CacheLoader eligibilityDecisionLoader,
            CacheWriter eligibilityDecisionWriter) {

        PartitionedRegionFactoryBean&lt;?, EligibilityDecision&gt; eligibilityDecisionsRegion =
            new PartitionedRegionFactoryBean&lt;&gt;();

        eligibilityDecisionsRegion.setCache(gemfireCache);
        eligibilityDecisionsRegion.setCacheLoader(eligibilityDecisionLoader);
        eligibilityDecisionsRegion.setCacheWriter(eligibilityDecisionWriter);
        eligibilityDecisionsRegion.setPersistent(false);

        return eligibilityDecisionsRegion;
    }

    @Bean
    CacheLoader&lt;?, EligibilityDecision&gt; eligibilityDecisionLoader(
            DataSource dataSource) {

        return new EligibilityDecisionLoader(dataSource);
    }

    @Bean
    CacheWriter&lt;?, EligibilityDecision&gt; eligibilityDecisionWriter(
            DataSource dataSource) {

        return new EligibilityDecisionWriter(dataSource);
    }

    @Bean
    DataSource dataSource() {
      // ...
    }
}</programlisting>
</informalexample>
<simpara>Then you could implement the <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/CacheLoader.html"><literal>CacheLoader</literal></link>
and <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/CacheWriter.html"><literal>CacheWriter</literal></link> interfaces, as appropriate:</simpara>
<example>
<title>EligibilityDecisionLoader</title>
<programlisting language="java" linenumbering="unnumbered">class EligibilityDecisionLoader implements CacheLoader&lt;?, EligibilityDecision&gt; {

  private final DataSource dataSource;

  EligibilityDecisionLoader(DataSource dataSource) {
    this.dataSource = dataSource;
  }

  public EligibilityDecision load(LoadHelper&lt;?, EligibilityDecision&gt; helper) {

    Object key = helper.getKey();

    // Use the configured DataSource to load the EligibilityDecision identified by the key
    // from a backend, external data store.
  }
}</programlisting>
</example>
<tip>
<simpara>SBDG provides the <literal>org.springframework.geode.cache.support.CacheLoaderSupport</literal> <literal>@FunctionalInterface</literal> to
conveniently implement application <literal>CacheLoaders</literal>.</simpara>
</tip>
<simpara>If the configured <literal>CacheLoader</literal> still cannot resolve the value, the cache lookup operation results in a cache miss
and the application service method is then invoked to compute the value:</simpara>
<example>
<title>EligibilityDecisionWriter</title>
<programlisting language="java" linenumbering="unnumbered">class EligibilityDecisionWriter implements CacheWriter&lt;?, EligibilityDecision&gt; {

  private final DataSource dataSource;

  EligibilityDecisionWriter(DataSource dataSource) {
    this.dataSource = dataSource;
  }

  public void beforeCreate(EntryEvent&lt;?, EligiblityDecision&gt; entryEvent) {
    // Use configured DataSource to save (e.g. INSERT) the entry value into the backend data store
  }

  public void beforeUpdate(EntryEvent&lt;?, EligiblityDecision&gt; entryEvent) {
    // Use the configured DataSource to save (e.g. UPDATE or UPSERT) the entry value into the backend data store
  }

  public void beforeDestroy(EntryEvent&lt;?, EligiblityDecision&gt; entryEvent) {
    // Use the configured DataSource to delete (i.e. DELETE) the entry value from the backend data store
  }

  // ...
}</programlisting>
</example>
<tip>
<simpara>SBDG provides the <literal>org.springframework.geode.cache.support.CacheWriterSupport</literal> interface to conveniently implement
application <literal>CacheWriters</literal>.</simpara>
</tip>
<note>
<simpara>Your <literal>CacheWriter</literal> implementation can use any data access technology to interface with your backend data store
(for example JDBC, Spring&#8217;s <literal>JdbcTemplate</literal>, JPA with Hibernate, and others). It is not limited to using only a
<literal>javax.sql.DataSource</literal>. In fact, we present another, more useful and convenient approach to implementing Inline caching
in the next section.</simpara>
</note>
</section>
<section xml:id="geode-caching-provider-inline-caching-synchronous-using-spring-data-repositories">
<title>Inline Caching with Spring Data Repositories</title>
<simpara>Spring Boot for Apache Geode offers dedicated support to configure Inline caching with Spring Data Repositories.</simpara>
<simpara>This is powerful, because it lets you:</simpara>
<itemizedlist>
<listitem>
<simpara>Access any backend data store supported by Spring Data (such as Redis for key-value or other distributed data
structures, MongoDB for documents, Neo4j for graphs, Elasticsearch for search, and so on).</simpara>
</listitem>
<listitem>
<simpara>Use complex mapping strategies (such as ORM provided by JPA with Hibernate).</simpara>
</listitem>
</itemizedlist>
<simpara>We believe that users should store data where it is most easily accessible. If you access and process documents,
then MongoDB, Couchbase, or another document store is probably going to be the most logical choice to manage
your application&#8217;s documents.</simpara>
<simpara>However, this does not mean that you have to give up Apache Geode in your application/system architecture. You can use
each data store for what it is good at. While MongoDB is excellent at handling documents, Apache Geode is a valuable
choice for consistency, high-availability/low-latency, high-throughput, multi-site, scale-out application use cases.</simpara>
<simpara>As such, using Apache Geode&#8217;s <literal>CacheLoader</literal> and <literal>CacheWriter</literal> provides a nice integration point between itself and other
data stores to best serve your application&#8217;s use case and requirements.</simpara>
<simpara>Suppose you use JPA and Hibernate to access data managed in an Oracle database. Then, you can configure Apache Geode to
read/write-through to the backend Oracle database when performing cache (Region) operations by delegating to a
Spring Data JPA Repository.</simpara>
<simpara>The configuration might look something like:</simpara>
<example>
<title>Inline caching configuration using SBDG</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EntityScan(basePackageClasses = Customer.class)
@EnableEntityDefinedRegions(basePackageClasses = Customer.class)
@EnableJpaRepositories(basePackageClasses = CustomerRepository.class)
class SpringBootOracleDatabaseApacheGeodeApplication {

  @Bean
  InlineCachingRegionConfigurer&lt;Customer, Long&gt; inlineCachingForCustomersRegionConfigurer(
      CustomerRepository customerRepository) {

    return new InlineCachingRegionConfigurer&lt;&gt;(customerRepository, Predicate.isEqual("Customers"));
  }
}</programlisting>
</example>
<simpara>SBDG provides the <literal>InlineCachingRegionConfigurer&lt;ENTITY, ID&gt;</literal> interface.</simpara>
<simpara>Given a <literal>Predicate</literal> to express the criteria used to match the target Region by name and a Spring Data <literal>CrudRepository</literal>,
the <literal>InlineCachingRegionConfigurer</literal> configures and adapts the Spring Data <literal>CrudRepository</literal> as a <literal>CacheLoader</literal>
and <literal>CacheWriter</literal> registered on the Region (for example, "Customers") to enable Inline caching functionality.</simpara>
<simpara>You need only declare <literal>InlineCachingRegionConfigurer</literal> as a bean in the Spring <literal>ApplicationContext</literal> and make
the association between the Region (by name) and the appropriate Spring Data <literal>CrudRepository</literal>.</simpara>
<simpara>In this example, we used JPA and Spring Data JPA to store and retrieve data stored in the cache (Region) to and from
a backend database. However, you can inject any Spring Data Repository for any data store (Redis, MongoDB, and others)
that supports the Spring Data Repository abstraction.</simpara>
<tip>
<simpara>If you want only to support one-way data access operations when you use Inline caching, you can use either
the <literal>RepositoryCacheLoaderRegionConfigurer</literal> for reads or the <literal>RepositoryCacheWriterRegionConfigurer</literal> for writes,
instead of the <literal>InlineCachingRegionConfigurer</literal>, which supports both reads and writes.</simpara>
</tip>
<tip>
<simpara>To see a similar implementation of Inline caching with a database (an in-memory HSQLDB database) in action, see the
<link xl:href="https://github.com/spring-projects/spring-boot-data-geode/blob/master/spring-geode/src/test/java/org/springframework/geode/cache/inline/database/InlineCachingWithDatabaseIntegrationTests.java"><literal>InlineCachingWithDatabaseIntegrationTests</literal></link>
test class from the SBDG test suite. A dedicated sample will be provided in a future release.</simpara>
</tip>
</section>
</section>
<section xml:id="geode-caching-provider-inline-caching-asynchronous">
<title>Asynchronous Inline Caching</title>
<tip>
<simpara>See the corresponding sample <link xl:href="guides/caching-inline-async.html">guide</link>
and {github-samples-url}/caching/inline-async[code] to see asynchronous Inline caching with Apache Geode in action.</simpara>
</tip>
<simpara>If consistency between the cache and your external data source is not a concern, and you need only write from the cache
to the backend data store periodically, you can employ asynchronous (write-behind) Inline caching.</simpara>
<simpara>As the term, "write-behind", implies, a write to the backend data store is asynchronous and not strictly tied to the
cache operation. As a result, the backend data store is in an "eventually consistent" state, since the cache is
primarily used by the application at runtime to access and manage data. In this case, the backend data store is used
to persist the state of the cache (and that of the application) at periodic intervals.</simpara>
<simpara>If multiple applications are updating the backend data store concurrently, you could combine a <literal>CacheLoader</literal>
to synchronously read through to the backend data store and keep the cache up-to-date as well as asynchronously
write behind from the cache to the backend data store when the cache is updated to eventually inform other interested
applications of data changes. In this capacity, the backend data store is still the primary System of Record (SoR).</simpara>
<simpara>If data processing is not time sensitive, you can gain a performance advantage from quantity-based or time-based
batch updates.</simpara>
<section xml:id="geode-caching-provider-inline-caching-asynchronous-asynceventlistener">
<title>Implementing an AsyncEventListener for Inline Caching</title>
<simpara>If you were to configure asynchronous, write-behind Inline caching by hand, you would need to do the following yourself:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Implement an <literal>AsyncEventListener</literal> to write to an external data source on cache events.</simpara>
</listitem>
<listitem>
<simpara>Configure and register the listener with an <literal>AsyncEventQueue</literal> (AEQ).</simpara>
</listitem>
<listitem>
<simpara>Create a Region to serve as the source of cache events and attach the AEQ to the Region.</simpara>
</listitem>
</orderedlist>
<simpara>The advantage of this approach is that you have access to and control over low-level configuration details.
The disadvantage is that with more moving parts, it is easier to make errors.</simpara>
<simpara>Following on from our synchronous, read/write-through, Inline caching examples from the prior sections,
our <literal>AsyncEventListener</literal> implementation might appear as follows:</simpara>
<example>
<title>Example <literal>AsyncEventListener</literal> for Asynchronous, Write-Behind Inline Caching</title>
<programlisting language="java" linenumbering="unnumbered">@Component
class ExampleAsyncEventListener implements AsyncEventListener {

	private final DataSource dataSource;

	ExampleAsyncEventListener(DataSoruce dataSource) {
		this.dataSource = dataSource;
	}

	@Override
	public boolean processEvents(List&lt;AsyncEvent&gt; events) {

        // Iterate over the ordered AsyncEvents and use the configured DataSource
        // to write to the external, backend DataSource

	}
}</programlisting>
</example>
<note>
<simpara>Instead of directly injecting a <literal>DataSource</literal> into your <literal>AsyncEventListener</literal>, you could use JDBC, Spring&#8217;s
<literal>JdbcTemplate</literal>, JPA and Hibernate, or another data access API or framework. Later in this chapter, we show how SBDG
simplifies the <literal>AsyncEventListener</literal> implementation by using Spring Data Repositories.</simpara>
</note>
<simpara>Then we need to register this listener with an <literal>AsyncEventQueue</literal> (step 2 from the procedure shown earlier) and attach it
to the target Region that will be the source of the cache events we want to persist asynchronously (step 3):</simpara>
<example>
<title>Create and Configure an <literal>AsyncEventQueue</literal></title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@PeerCacheApplication
class GeodeConfiguration {

	@Bean
    DataSource exampleDataSource() {
		// Construct and configure a data store specific DataSource
    }

	@Bean
    ExampleAsyncEventListener exampleAsyncEventListener(DataSource dataSource) {
		return new ExampleAsyncEventListener(dataSource);
    }

	@Bean
    AsyncEventQueueFactoryBean exampleAsyncEventQueue(Cache peerCache, ExampleAsyncEventListener listener) {

		AsyncEventQueueFactoryBean asyncEventQueue = new AsyncEventQueueFactoryBean(peerCache, listener);

		asyncEventQueue.setBatchConflationEnabled(true);
		asyncEventQueue.setBatchSize(50);
		asyncEventQueue.setBatchTimeInterval(15000); // 15 seconds
        asyncEventQueue.setMaximumQueueMemory(64); // 64 MB
        // ...

		return asyncEventQueue;
    }

    @Bean("Example")
    PartitionedRegionFactoryBean&lt;?, ?&gt; exampleRegion(Cache peerCache, AsyncEventQueue queue) {

        PartitionedRegionFactoryBean&lt;?, ?&gt; exampleRegion = new PartitionedRegionFactoryBean&lt;&gt;();

        exampleRegion.setAsyncEventQueues(ArrayUtils.asArray(queue));
        exampleRegion.setCache(peerCache);
        // ...

        return exampleRegion;
    }
}</programlisting>
</example>
<simpara>While this approach affords you a lot of control over the low-level configuration, in addition to
your <literal>AsyncEventListener</literal> implementation, this is a lot of boilerplate code.</simpara>
<tip>
<simpara>See the Javadoc for SDG&#8217;s
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/wan/AsyncEventQueueFactoryBean.html"><literal>AsyncEventQueueFactoryBean</literal></link>
for more detail on the configuration of the AEQ.</simpara>
</tip>
<tip>
<simpara>See Apache Geode&#8217;s <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/events/implementing_write_behind_event_handler.html">User Guide</link>
for more details on AEQs and listeners.</simpara>
</tip>
<simpara>Fortunately, with SBDG, there is a better way.</simpara>
</section>
<section xml:id="geode-caching-provider-inline-caching-asynchronous-using-spring-data-repositories">
<title>Asynchronous Inline Caching with Spring Data Repositories</title>
<simpara>The implementation and configuration of the <literal>AsyncEventListener</literal> as well as the AEQ shown in
the <link linkend="geode-caching-provider-inline-caching-asynchronous-asynceventlistener">preceding section</link>
can be simplified as follows:</simpara>
<example>
<title>Using SBDG to configure Asynchronous, Write-Behind Inline Caching</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EntityScan(basePackageClasses = ExampleEntity.class)
@EnableJpaRepositories(basePackageClasses = ExampleRepository.class)
@EnableEntityDefinedRegions(basePackageClasses = ExampleEnity.class)
class ExampleSpringBootApacheGeodeAsyncInlineCachingApplication {

	@Bean
    AsyncInlineCachingRegionConfigurer asyncInlineCachingRegionConfigurer(
    	    CrudRepository&lt;ExampleEntity, Long&gt; repository) {

		return AsyncInlineCachingRegionConfigurer.create(repository, "Example")
            .withQueueBatchConflationEnabled()
            .withQueueBatchSize(50)
            .withQueueBatchTimeInterval(Duration.ofSeconds(15))
            .withQueueMaxMemory(64);
    }
}</programlisting>
</example>
<simpara>The <literal>AsyncInlineCachingRegionConfigurer.create(..)</literal> method is overloaded to accept a <literal>Predicate</literal> in place of the <literal>String</literal>
to programmatically express more powerful matching logic and identify the target Region (by name) on which to configure
asynchronous Inline caching functionality.</simpara>
<simpara>The <literal>AsyncInlineCachingRegionConfigurer</literal> uses the <link xl:href="https://en.wikipedia.org/wiki/Builder_pattern">Builder software design pattern</link>
and <literal>withQueue*(..)</literal> builder methods to configure the underlying <literal>AsyncEventQueue</literal> (AEQ) when the queue&#8217;s configuration
deviates from the defaults, as specified by Apache Geode.</simpara>
<simpara>Under the hood, the <literal>AsyncInlineCachingRegionConfigurer</literal> constructs a new instance of the <literal>RepositoryAsyncEventListener</literal>
class initialized with the given Spring Data <literal>CrudRepository</literal>. The <literal>RegionConfigurer</literal> then registers the listener with
the AEQ and attaches it to the target <literal>Region</literal>.</simpara>
<simpara>With the power of Spring Boot auto-configuration and SBDG, the configuration is much more concise and intuitive.</simpara>
</section>
<section xml:id="geode-caching-provider-inline-caching-asynchronous-listener">
<title>About <literal>RepositoryAsyncEventListener</literal></title>
<simpara>The SBDG <literal>RepositoryAsyncEventListener</literal> class is the magic ingredient behind the integration of the cache with
an external data source.</simpara>
<simpara>The listener is a specialized <link xl:href="https://en.wikipedia.org/wiki/Adapter_pattern">adapter</link> that processes <literal>AsyncEvents</literal> by
invoking an appropriate <literal>CrudRepository</literal> method based on the cache operation. The listener requires an instance of
<literal>CrudRepository</literal>. The listener supports any external data source supported by Spring Data&#8217;s Repository abstraction.</simpara>
<simpara>Backend data store, data access operations (such as INSERT, UPDATE, DELETE, and so on) triggered by cache events
are performed asynchronously from the cache operation. This means the state of the cache and backend data store
will be "eventually consistent".</simpara>
<simpara>Given the complex nature of "eventually consistent" systems and asynchronous concurrent processing, the
<literal>RepositoryAsyncEventListener</literal> lets you register a custom <literal>AsyncEventErrorHandler</literal> to handle the errors that occur
during processing of <literal>AsyncEvents</literal>, perhaps due to a faulty backend data store data access operation (such as
<literal>OptimisticLockingFailureException</literal>), in an application-relevant way.</simpara>
<simpara>The <literal>AsyncEventErrorHandler</literal> interface is a <literal>java.util.function.Function</literal> implementation and <literal>@FunctionalInterface</literal>
defined as:</simpara>
<example>
<title>AsyncEventErrorHandler interface definition</title>
<programlisting language="java" linenumbering="unnumbered">@FunctionalInterface
interface AsyncEventErrorHandler implements Function&lt;AsyncEventError, Boolean&gt; { }</programlisting>
</example>
<simpara>The <literal>AsyncEventError</literal> class encapsulates <literal>AsyncEvent</literal> along with the <literal>Throwable</literal> that was thrown while processing
the <literal>AsyncEvent</literal>.</simpara>
<simpara>Since the <literal>AsyncEventErrorHandler</literal> interface implements <literal>Function</literal>, you should override the <literal>apply(:AsyncEventError)</literal>
method to handle the error with application-specific actions. The handler returns a <literal>Boolean</literal> to indicate whether it
was able to handle the error or not:</simpara>
<example>
<title>Custom <literal>AsyncEventErrorHandler</literal> implementation</title>
<programlisting language="java" linenumbering="unnumbered">class CustomAsyncEventErrorHandler implements AsyncEventErrorHandler {

	@Override
    public Boolean apply(AsyncEventError error) {

		if (error.getCause() instanceof OptimisticLockingFailureException) {
			// handle optimistic locking failure if you can
            return true; // if error was successfully handled
		}
		else if (error.getCause() instanceof IncorrectResultSizeDataAccessException) {
			// handle no row or too many row update if you can
            return true; // if error was successfully handled
		}
		else {
			// ...
		}

		return false;
    }
}</programlisting>
</example>
<simpara>You can configure the <literal>RepositoryAsyncEventListener</literal> with your custom <literal>AsyncEventErrorHandler</literal> by using the
<literal>AsyncInlineCachingRegionConfigurer</literal>:</simpara>
<example>
<title>Configuring a custom <literal>AsyncEventErrorHandler</literal></title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
class GeodeConfiguration {

	@Bean
	CustomAsyncEventErrorHandler customAsyncEventErrorHandler() {
		return new CustomAsyncEventErrorHandler();
	}

	@Bean
    AsyncInlineCachingRegionConfigurer asyncInlineCachingRegionConfigurer(
    	    CrudRepository&lt;?, ?&gt; repository,
            CustomAsyncEventErrorHandler errorHandler) {

		return AsyncInlineCachingRegionConfigurer.create(repository, "Example")
            .withAsyncEventErrorHandler(errorHandler);
    }
}</programlisting>
</example>
<simpara>Also, since <literal>AsyncEventErrorHandler</literal> implements <literal>Function</literal>, you can <link xl:href="https://en.wikipedia.org/wiki/Composite_pattern">compose</link>
multiple error handlers by using <link xl:href="https://docs.oracle.com/en/java/javase/17/docs/api//java/util/function/Function.html#andThen-java.util.function.Function-"><literal>Function.andThen(:Function)</literal></link>.</simpara>
<simpara>By default, the <literal>RepositoryAsyncEventListener</literal> handles <literal>CREATE</literal>, <literal>UPDATE</literal>, and <literal>REMOVE</literal> cache event, entry operations.</simpara>
<simpara><literal>CREATE</literal> and <literal>UPDATE</literal> translate to <literal>CrudRepository.save(entity)</literal>. The <literal>entity</literal> is derived from
<literal>AsyncEvent.getDeserializedValue()</literal>.</simpara>
<simpara><literal>REMOVE</literal> translates to <literal>CrudRepository.delete(entity)</literal>. The <literal>entity</literal> is derived from
<literal>AsyncEvent.getDeserializedValue()</literal>.</simpara>
<simpara>The cache <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/Operation.html"><literal>Operation</literal></link> to <literal>CrudRepository</literal> method is
supported by the <literal>AsyncEventOperationRepositoryFunction</literal> interface, which implements <literal>java.util.function.Function</literal>
and is a <literal>@FunctionalInterface</literal>.</simpara>
<simpara>This interface becomes useful if and when you want to implement <literal>CrudRepository</literal> method invocations for other
<literal>AsyncEvent</literal> <literal>Operations</literal> not handled by SBDG&#8217;s <literal>RepositoryAsyncEventListener</literal>.</simpara>
<simpara>The <literal>AsyncEventOperationRepositoryFunction</literal> interface is defined as follows:</simpara>
<example>
<title>AsyncEventOperationRepositoryFunction interface definition</title>
<programlisting language="java" linenumbering="unnumbered">@FunctionalInterface
interface AsyncEventOperationRepositoryFunction&lt;T, ID&gt; implements Function&lt;AsyncEvent&lt;ID, T&gt;,  Boolean&gt; {

	default boolean canProcess(AsyncEvent&lt;ID, T&gt; event) {
		return false;
	}
}</programlisting>
</example>
<simpara><literal>T</literal> is the class type of the entity and <literal>ID</literal> is the class type of the entity&#8217;s identifier (ID), possibly declared with
Spring Data&#8217;s <link xl:href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/annotation/Id.html"><literal>org.springframework.data.annotation.Id</literal></link>
annotation.</simpara>
<simpara>For convenience, SBDG provides the <literal>AbstractAsyncEventOperationRepositoryFunction</literal> class for extension, where you can
provide implementations for the <literal>cacheProcess(:AsyncEvent)</literal> and <literal>doRepositoryOp(entity)</literal> methods.</simpara>
<note>
<simpara>The <literal>AsyncEventOperationRepositoryFunction.apply(:AsyncEvent)</literal> method is already implemented in terms of
<literal>canProcess(:AsyncEvent)</literal>, <literal>resolveEntity(:AsyncEvent)</literal>, <literal>doRepositoryOp(entity)</literal>, and catching and handling
any <literal>Throwable</literal> (errors) by calling the configured <literal>AsyncEventErrorHandler</literal>.</simpara>
</note>
<simpara>For example, you may want to handle <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/Operation.html#INVALIDATE"><literal>Operation.INVALIDATE</literal></link>
cache events as well, deleting the entity from the backend data store by invoking the <literal>CrudRepository.delete(entity)</literal>
method:</simpara>
<example>
<title>Handling <literal>AsyncEvent</literal>, <literal>Operation.INVALIDATE</literal></title>
<programlisting language="java" linenumbering="unnumbered">@Component
class InvalidateAsyncEventRepositoryFunction
        extends RepositoryAsyncEventListener.AbstractAsyncEventOperationRepositoryFunction&lt;?, ?&gt; {

	InvalidateAsyncEventRepositoryFunction(RepositoryAsyncEventListener&lt;?, ?&gt; listener) {
		super(listener);
	}

	@Override
	public boolean canProcess(AsyncEvent&lt;?, ?&gt; event) {
		return event != null &amp;&amp; Operation.INVALIDATE.equals(event.getOperation());
	}


	@Override
	protected Object doRepositoryOperation(Object entity) {
		getRepository().delete(entity);
		return null;
	}
}</programlisting>
</example>
<simpara>You can then register your user-defined, <literal>AsyncEventOperationRepositoryFunction</literal> (that is,
<literal>InvalidateAsyncEventRepositoryFunction</literal>) with the <literal>RepositoryAsyncEventListener</literal> by using
the <literal>AsyncInlineCachingRegionConfigurer</literal>:</simpara>
<example>
<title>Configuring a user-defined <literal>AsyncEventOperationRepositoryFunction</literal></title>
<programlisting language="java" linenumbering="unnumbered">import org.springframework.geode.cache.RepositoryAsyncEventListener;

@Configuration
class GeodeConfiguration {

	@Bean
    AsyncInlineCachingRegionConfigurer asyncInlineCachingRegionConfigurer(
    	    CrudRepository&lt;?, ?&gt; repository,
            CustomAsyncEventErrorHandler errorHandler ) {

		return AsyncInlineCachingRegionConfigurer.create(repository, "ExampleRegion")
            .applyToListener(listener -&gt; {

            	if (listener instanceof RepositoryAsyncEventListener) {

            		RepositoryAsyncEventListener&lt;?, ?&gt; repositoryListener =
                        (RepositoryAsyncEventListener&lt;?, ?&gt;) listener;

             		repositoryListener.register(new InvalidAsyncEventRepositoryFunction(repositoryListener));
            	}

            	return listener;
            });
    }
}</programlisting>
</example>
<simpara>This same technique can be applied to <literal>CREATE</literal>, <literal>UPDATE</literal>, and <literal>REMOVE</literal> cache operations as well, effectively overriding
the default behavior for these cache operations handled by SBDG.</simpara>
</section>
<section xml:id="geode-caching-provider-inline-caching-asynchronous-region-configurer">
<title>About <literal>AsyncInlineCachingRegionConfigurer</literal></title>
<simpara>As we saw in the previous section, you can intercept and post-process the essential components that are constructed
and configured by the <literal>AsyncInlineCachingRegionConfigurer</literal> class during initialization.</simpara>
<simpara>SBDG&#8217;s lets you intercept and post-process the <literal>AsyncEventListener</literal> (such as <literal>RepositoryAsyncEventListener</literal>),
the <literal>AsyncEventQueueFactory</literal> and even the <literal>AsyncEventQueue</literal> created by the <literal>AsyncInlineCachingRegionConfigurer</literal>
(a SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/RegionConfigurer.html"><literal>RegionConfigurer</literal></link>)
during Spring <literal>ApplicationContext</literal> bean initialization.</simpara>
<simpara>The <literal>AsyncInlineCachingRegionConfigurer</literal> class provides the following builder methods to intercept and post-process any
of the following Apache Geode objects:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>applyToListener(:Function&lt;AsyncEventListener, AsyncEventListener&gt;)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>applyToQueue(:Function&lt;AsyncEventQueue, AsyncEventQueue&gt;)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>applyToQueueFactory(:Function&lt;AsyncEventQueueFactory, AsyncEventQueueFactory&gt;)</literal></simpara>
</listitem>
</itemizedlist>
<simpara>All of these <literal>apply*</literal> methods accept a <literal>java.util.function.Function</literal> that applies the logic of the <literal>Function</literal> to
the Apache Geode object (such as <literal>AsyncEventListener</literal>), returning the object as a result.</simpara>
<tip>
<simpara>The Apache Geode object returned by the <literal>Function</literal> may be the same object, a proxy, or a completely new object.
Essentially, the returned object can be anything you want. This is the fundamental premise behind Aspect-Oriented
Programming (AOP) and the <link xl:href="https://en.wikipedia.org/wiki/Decorator_pattern">Decorator software design pattern</link>.</simpara>
</tip>
<simpara>The <literal>apply*</literal> methods and the supplied <literal>Function</literal> let you decorate, enhance, post-process, or otherwise modify
the Apache Geode objects created by the configurer.</simpara>
<simpara>The <literal>AsyncInlineCachingRegionConfigurer</literal> strictly adheres to
the <link xl:href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">open/close principle</link>
and is, therefore, flexibly extensible.</simpara>
</section>
</section>
</section>
<section xml:id="geode-caching-provider-multi-site-caching">
<title>Multi-Site Caching</title>
<simpara>The final pattern of caching presented in this chapter is Multi-site caching.</simpara>
<simpara>As described earlier, there are two configuration arrangements, depending on your application usage patterns,
requirements and user demographic: active-active and active-passive.</simpara>
<simpara>Multi-site caching, along with active-active and active-passive configuration arrangements, are described in more detail
in the sample <link xl:href="guides/caching-multi-site.html">guide</link>. Also, be sure to review the sample
{github-samples-url}/caching/multi-site[code].</simpara>
</section>
</section>
<section xml:id="geode-caching-provider-advanced-configuration">
<title>Advanced Caching Configuration</title>
<simpara>Apache Geode supports additional caching capabilities to manage the entries stored in the cache.</simpara>
<simpara>As you can imagine, given that cache entries are stored in-memory, it becomes important to manage and monitor
the available memory used by the cache. After all, by default, Apache Geode stores data in the JVM Heap.</simpara>
<simpara>You can employ several techniques to more effectively manage memory, such as using
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/eviction/chapter_overview.html">eviction</link>, possibly
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/storing_data_on_disk/chapter_overview.html">overflowing data to disk</link>,
configuring both entry Idle-Timeout_ (TTI) and Time-to-Live_ (TTL)
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/expiration/chapter_overview.html">expiration policies</link>,
configuring <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/managing/region_compression.html">compression</link>,
and using <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/managing/heap_use/off_heap_management.html">off-heap</link>
or main memory.</simpara>
<simpara>You can use several other strategies as well, as described in
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/managing/heap_use/heap_management.html">Managing Heap and Off-heap Memory</link>.</simpara>
<simpara>While this is beyond the scope of this document, know that Spring Data for Apache Geode makes all of these
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-regions">configuration options</link> available to you.</simpara>
</section>
<section xml:id="geode-caching-provider-disable">
<title>Disable Caching</title>
<simpara>There may be cases where you do not want your Spring Boot application to cache application state with
<link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache">Spring&#8217;s Cache Abstraction</link> using Apache Geode. In certain cases,
you may use another Spring supported caching provider, such as Redis, to cache and manage your application state.
In other cases, you may not want to use Spring&#8217;s Cache Abstraction at all.</simpara>
<simpara>Either way, you can specifically call out your Spring Cache Abstraction provider by using the <literal>spring.cache.type</literal>
property in <literal>application.properties</literal>:</simpara>
<example>
<title>Use Redis as the Spring Cache Abstraction Provider</title>
<programlisting language="txt" linenumbering="unnumbered">#application.properties

spring.cache.type=redis
...</programlisting>
</example>
<simpara>If you prefer not to use Spring&#8217;s Cache Abstraction to manage your Spring Boot application&#8217;s state at all, then set
the <literal>spring.cache.type</literal> property to "none":</simpara>
<example>
<title>Disable Spring&#8217;s Cache Abstraction</title>
<programlisting language="txt" linenumbering="unnumbered">#application.properties

spring.cache.type=none
...</programlisting>
</example>
<simpara>See the Spring Boot <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-caching.html#boot-features-caching-provider-none">documentation</link>
for more detail.</simpara>
<tip>
<simpara>You can include multiple caching providers on the classpath of your Spring Boot application. For instance,
you might use Redis to cache your application&#8217;s state while using Apache Geode as your application&#8217;s persistent
data store (that is, the System of Record (SOR)).</simpara>
</tip>
<note>
<simpara>Spring Boot does not properly recognize <literal>spring.cache.type=[gemfire|geode]</literal>, even though Spring Boot
for Apache Geode is set up to handle either of these property values (that is, either <literal>gemfire</literal> or <literal>geode</literal>).</simpara>
</note>
</section>
</chapter>
<chapter xml:id="geode-data-access-region-templates">
<title>Data Access with GemfireTemplate</title>
<simpara>There are several ways to access data stored in Apache Geode.</simpara>
<simpara>For instance, you can use the <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/Region.html">Region API</link> directly. If you
are driven by the application&#8217;s domain context, you can use the power of
<link xl:href="https://docs.spring.io/spring-data/commons/docs/current/reference/html/#repositories">Spring Data Repositories</link> instead.</simpara>
<simpara>While the Region API offers flexibility, it couples your application to Apache Geode, which is usually undesirable
and unnecessary. While using Spring Data Repositories provides a very powerful and convenient abstraction, you give up
the flexibility provided by a lower-level Region API.</simpara>
<simpara>A good compromise is to use the <link xl:href="https://en.wikipedia.org/wiki/Template_method_pattern">Template software design pattern</link>.
This pattern is consistently and widely used throughout the entire Spring portfolio.</simpara>
<simpara>For example, the Spring Framework provides <link xl:href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html"><literal>JdbcTemplate</literal></link>
and <link xl:href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jms/core/JmsTemplate.html"><literal>JmsTemplate</literal></link>.</simpara>
<simpara>Other Spring Data modules, such as Spring Data Redis, offer the
<link xl:href="https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/core/RedisTemplate.html"><literal>RedisTemplate</literal></link>,
and Spring Data for Apache Geode (SDG) itself offers the
<link xl:href="https://docs.spring.io/spring-data/gemfire/docs/current/api/org/springframework/data/gemfire/GemfireTemplate.html"><literal>GemfireTemplate</literal></link>.</simpara>
<simpara>The <literal>GemfireTemplate</literal> provides a highly consistent and familiar API to perform data access operations on Apache Geode
cache <literal>Regions</literal>.</simpara>
<simpara><literal>GemfireTemplate</literal> offers:</simpara>
<itemizedlist>
<listitem>
<simpara>A simple and convenient data access API to perform basic CRUD and simple query operations on cache Regions.</simpara>
</listitem>
<listitem>
<simpara>Use of Spring Framework&#8217;s consistent data access <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#dao-exceptions">Exception hierarchy</link>.</simpara>
</listitem>
<listitem>
<simpara>Automatic enlistment in the presence of local cache transactions.</simpara>
</listitem>
<listitem>
<simpara>Consistency and protection from <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/Region.html">Region API</link> breaking changes.</simpara>
</listitem>
</itemizedlist>
<simpara>Given these advantages, Spring Boot for Apache Geode (SBDG) auto-configures <literal>GemfireTemplate</literal> beans for each Region
present in the Apache Geode cache.</simpara>
<simpara>Additionally, SBDG is careful not to create a <literal>GemfireTemplate</literal> if you have already declared a <literal>GemfireTemplate</literal> bean
in the Spring <literal>ApplicationContext</literal> for a given Region.</simpara>
<section xml:id="geode-data-access-region-templates-explicit-declaration">
<title>Explicitly Declared Regions</title>
<simpara>Consider an explicitly declared Region bean definition:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Explicitly Declared Region Bean Definition</simpara>
</listitem>
</orderedlist>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@Configuration
class GeodeConfiguration {

    @Bean("Example")
    ClientRegionFactoryBean&lt;?, ?&gt; exampleRegion(GemFireCache gemfireCache) {
        // ...
    }
}</programlisting>
</informalexample>
<simpara>SBDG automatically creates a <literal>GemfireTemplate</literal> bean for the <literal>Example</literal> Region by using the bean name <literal>exampleTemplate</literal>.
SBDG names the <literal>GemfireTemplate</literal> bean after the Region by converting the first letter in the Region&#8217;s name to lower case
and appending <literal>Template</literal> to the bean name.</simpara>
<simpara>In a managed Data Access Object (DAO), you can inject the Template:</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@Repository
class ExampleDataAccessObject {

    @Autowired
    @Qualifier("exampleTemplate")
    private GemfireTemplate exampleTemplate;

}</programlisting>
</informalexample>
<simpara>You should use the <literal>@Qualifier</literal> annotation to qualify which <literal>GemfireTemplate</literal> bean you are specifically referring,
especially if you have more than one Region bean definition.</simpara>
</section>
<section xml:id="geode-data-access-region-templates-entity-defined">
<title>Entity-defined Regions</title>
<simpara>SBDG auto-configures <literal>GemfireTemplate</literal> beans for entity-defined Regions.</simpara>
<simpara>Consider the following entity class:</simpara>
<example>
<title>Customer class</title>
<programlisting language="java" linenumbering="unnumbered">@Region("Customers")
class Customer {
    // ...
}</programlisting>
</example>
<simpara>Further consider the following configuration:</simpara>
<example>
<title>Apache Geode Configuration</title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@EnableEntityDefinedRegions(basePackageClasses = Customer.class)
class GeodeConfiguration {
    // ...
}</programlisting>
</example>
<simpara>SBDG auto-configures a <literal>GemfireTemplate</literal> bean for the <literal>Customers</literal> Region named <literal>customersTemplate</literal>, which you can then
inject into an application component:</simpara>
<example>
<title>CustomerService application component</title>
<programlisting language="java" linenumbering="unnumbered">@Service
class CustomerService {

    @Bean
    @Qualifier("customersTemplate")
    private GemfireTemplate customersTemplate;

}</programlisting>
</example>
<simpara>Again, be careful to qualify the <literal>GemfireTemplate</literal> bean injection if you have multiple Regions, whether declared
explicitly or implicitly, such as when you use the <literal>@EnableEntityDefineRegions</literal> annotation.</simpara>
</section>
<section xml:id="geode-data-access-region-templates-caching-defined">
<title>Caching-defined Regions</title>
<simpara>SBDG auto-configures <literal>GemfireTemplate</literal> beans for caching-defined Regions.</simpara>
<simpara>When you use Spring Framework&#8217;s <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache">Cache Abstraction</link> backed by Apache Geode,
one requirement is to configure Regions for each of the caches specified in the
<link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-referenceintegration.html#cache-annotations">caching annotations</link> of your application service components.</simpara>
<simpara>Fortunately, SBDG makes enabling and configuring caching easy and <link linkend="geode-caching-provider">automatic</link>.</simpara>
<simpara>Consider the following cacheable application service component:</simpara>
<example>
<title>Cacheable <literal>CustomerService</literal> class</title>
<programlisting language="java" linenumbering="unnumbered">@Service
class CacheableCustomerService {

    @Bean
    @Qualifier("customersByNameTemplate")
    private GemfireTemplate customersByNameTemplate;

    @Cacheable("CustomersByName")
    public Customer findBy(String name) {
        return toCustomer(customersByNameTemplate.query("name = " + name));
    }
}</programlisting>
</example>
<simpara>Further consider the following configuration:</simpara>
<example>
<title>Apache Geode Configuration</title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@EnableCachingDefinedRegions
class GeodeConfiguration {

    @Bean
    public CustomerService customerService() {
        return new CustomerService();
    }
}</programlisting>
</example>
<simpara>SBDG auto-configures a <literal>GemfireTemplate</literal> bean named <literal>customersByNameTemplate</literal> to perform data access operations on
the <literal>CustomersByName</literal> (<literal>@Cacheable</literal>) Region. You can then inject the bean into any managed application component,
as shown in the preceding application service component example.</simpara>
<simpara>Again, be careful to qualify the <literal>GemfireTemplate</literal> bean injection if you have multiple Regions, whether declared
explicitly or implicitly, such as when you use the <literal>@EnableCachingDefineRegions</literal> annotation.</simpara>
<warning>
<simpara>Autowiring (that is, injecting) <literal>GemfireTemplate</literal> beans auto-configured by SBDG for caching-defined Regions
into your application components does not always work. This has to do with the Spring container bean creation process.
In those cases, you may need to lazily lookup the <literal>GemfireTemplate</literal> by using
<literal>applicationContext.getBean("customersByNameTemplate", GemfireTemplate.class)</literal>. This is not ideal, but it works when
autowiring does not.</simpara>
</warning>
</section>
<section xml:id="geode-data-access-region-templates-native-defined">
<title>Native-defined Regions</title>
<simpara>SBDG even auto-configures <literal>GemfireTemplate</literal> beans for Regions that have been defined with Apache Geode native
configuration metadata, such as <literal>cache.xml</literal>.</simpara>
<simpara>Consider the following Apache Geode native <literal>cache.xml</literal>:</simpara>
<example>
<title>Client <literal>cache.xml</literal></title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;client-cache xmlns="http://geode.apache.org/schema/cache"
			  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			  xsi:schemaLocation="http://geode.apache.org/schema/cache http://geode.apache.org/schema/cache/cache-1.0.xsd"
			  version="1.0"&gt;

	&lt;region name="Example" refid="LOCAL"/&gt;

&lt;/client-cache&gt;</programlisting>
</example>
<simpara>Further consider the following Spring configuration:</simpara>
<example>
<title>Apache Geode Configuration</title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@EnableGemFireProperties(cacheXmlFile = "cache.xml")
class GeodeConfiguration {
    // ...
}</programlisting>
</example>
<simpara>SBDG auto-configures a <literal>GemfireTemplate</literal> bean named <literal>exampleTemplate</literal> after the <literal>Example</literal> Region defined in <literal>cache.xml</literal>.
You can inject this template as you would any other Spring-managed bean:</simpara>
<example>
<title>Injecting the <literal>GemfireTemplate</literal></title>
<programlisting language="java" linenumbering="unnumbered">@Service
class ExampleService {

    @Autowired
    @Qualifier("exampleTemplate")
    private GemfireTemplate exampleTemplate;

}</programlisting>
</example>
<simpara>The rules described earlier apply when multiple Regions are present.</simpara>
</section>
<section xml:id="geode-data-access-region-templates-rules">
<title>Template Creation Rules</title>
<simpara>Fortunately, SBDG is careful not to create a <literal>GemfireTemplate</literal> bean for a Region if a template by the same name already
exists.</simpara>
<simpara>For example, consider the following configuration:</simpara>
<example>
<title>Apache Geode Configuration</title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@EnableEntityDefinedRegions(basePackageClasses = Customer.class)
class GeodeConfiguration {

    @Bean
    public GemfireTemplate customersTemplate(GemFireCache cache) {
        return new GemfireTemplate(cache.getRegion("/Customers"));
    }
}</programlisting>
</example>
<simpara>Further consider the following example:</simpara>
<example>
<title>Customer class</title>
<programlisting language="java" linenumbering="unnumbered">@Region("Customers")
class Customer {
    // ...
}</programlisting>
</example>
<simpara>Because you explicitly defined and declared the <literal>customersTemplate</literal> bean, SBDG does not automatically create a template
for the <literal>Customers</literal> Region. This applies regardless of how the Region was created, whether by using
<literal>@EnableEntityDefinedRegions</literal>, <literal>@EnableCachingDefinedRegions</literal>, explicitly declaring Regions,
or natively defining Regions.</simpara>
<simpara>Even if you name the template differently from the Region for which the template was configured, SBDG conserves
resources and does not create the template.</simpara>
<simpara>For example, suppose you named the <literal>GemfireTemplate</literal> bean <literal>vipCustomersTemplate</literal>, even though the Region name
is <literal>Customers</literal>, based on the <literal>@Region</literal> annotated <literal>Customer</literal> class, which specified the <literal>Customers</literal> Region.</simpara>
<simpara>With the following configuration, SBDG is still careful not to create the template:</simpara>
<example>
<title>Apache Geode Configuration</title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@EnableEntityDefinedRegions(basePackageClasses = Customer.class)
class GeodeConfiguration {

    @Bean
    public GemfireTemplate vipCustomersTemplate(GemFireCache cache) {
        return new GemfireTemplate(cache.getRegion("/Customers"));
    }
}</programlisting>
</example>
<simpara>SBDG identifies that your <literal>vipCustomersTemplate</literal> is the template used with the <literal>Customers</literal> Region, and SBDG does not
create the <literal>customersTemplate</literal> bean, which would result in two <literal>GemfireTemplate</literal> beans for the same Region.</simpara>
<note>
<simpara>The name of your Spring bean defined in Java configuration is the name of the method if the Spring bean is not
explicitly named by using the <literal>name</literal> attribute or the <literal>value</literal> attribute of the <literal>@Bean</literal> annotation.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="geode-repositories">
<title>Spring Data Repositories</title>
<simpara>Using Spring Data Repositories with Apache Geode makes short work of data access operations when you use Apache Geode
as your System of Record (SoR) to persist your application&#8217;s state.</simpara>
<simpara><link xl:href="https://docs.spring.io/spring-data/commons/docs/current/reference/html/#repositories">Spring Data Repositories</link> provide a convenient and powerful way to define
basic CRUD and simple query data access operations by specifying the contract of those data access operations in a Java
interface.</simpara>
<simpara>Spring Boot for Apache Geode auto-configures the Spring Data for Apache Geode
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#gemfire-repositories">Repository extension</link>
when either is declared on your application&#8217;s classpath. You need not do anything special to enable it. You can start
coding your application-specific Repository interfaces.</simpara>
<simpara>The following example defines a <literal>Customer</literal> class to model customers and map it to the Apache Geode <literal>Customers</literal> Region
by using the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/mapping/annotation/Region.html"><literal>@Region</literal></link>
mapping annotation:</simpara>
<example>
<title><literal>Customer</literal> entity class</title>
<programlisting language="java" linenumbering="unnumbered">package example.app.crm.model;

@Region("Customers")
class Customer {

    @Id
    private Long id;

    private String name;

}</programlisting>
</example>
<simpara>The following example shows how to declare your Repository (a.k.a. <link xl:href="https://en.wikipedia.org/wiki/Data_access_object">Data Access Object (DAO)</link>)
for <literal>Customers</literal>:</simpara>
<example>
<title><literal>CustomerRepository</literal> for peristing and accessing <literal>Customers</literal></title>
<programlisting language="java" linenumbering="unnumbered">package example.app.crm.repo;

interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt; {

    List&lt;Customer&gt; findByLastNameLikeOrderByLastNameDescFirstNameAsc(String customerLastNameWildcard);

}</programlisting>
</example>
<simpara>Then you can use the <literal>CustomerRepository</literal> in an application service class:</simpara>
<example>
<title>Inject and use the <literal>CustomerRepository</literal></title>
<programlisting language="java" linenumbering="unnumbered">package example.app;

@SpringBootApplication
@EnableEntityDefinedRegions(basePackageClasses = Customer.class)
class SpringBootApacheGeodeClientCacheApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootApacheGeodeClientCacheApplication.class, args);
    }

    @Bean
    ApplicationRunner runner(CustomerRepository customerRepository) {

        // Matches Williams, Wilson, etc.
        List&lt;Customer&gt; customers =
            customerRepository.findByLastNameLikeOrderByLastNameDescFirstNameAsc("Wil%");

        // process the list of matching customers...
    }
}</programlisting>
</example>
<simpara>See Spring Data Commons' <link xl:href="https://docs.spring.io/spring-data/commons/docs/current/reference/html/#repositories">Repositories abstraction</link>
and Spring Data for Apache Geode&#8217;s <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#gemfire-repositories">Repositories extension</link>
for more detail.</simpara>
</chapter>
<chapter xml:id="geode-functions">
<title>Function Implementations &amp; Executions</title>
<simpara>This chapter is about using Apache Geode in a Spring context for distributed computing use cases.</simpara>
<section xml:id="_background">
<title>Background</title>
<simpara>Distributed computing, particularly in conjunction with data access and mutation operations, is a very effective
and efficient use of clustered computing resources. This is similar to <link xl:href="https://en.wikipedia.org/wiki/MapReduce">MapReduce</link>.</simpara>
<simpara>A naively conceived query returning potentially hundreds of thousands (or even millions) of rows of data in a result set
to the application that queried and requested the data can be very costly, especially under load. Therefore, it is
typically more efficient to move the processing and computations on the predicated data set to where the data resides,
perform the required computations, summarize the results, and then send the reduced data set back to the client.</simpara>
<simpara>Additionally, when the computations are handled in parallel, across the cluster of computing resources, the operation
can be performed much more quickly. This typically involves intelligently organizing the data using various partitioning
(a.k.a. sharding) strategies to uniformly balance the data set across the cluster.</simpara>
<simpara>Apache Geode addresses this very important application concern in its
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/function_exec/chapter_overview.html">Function execution</link> framework.</simpara>
<simpara>Spring Data for Apache Geode <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#function-annotations">builds</link> on this Function execution
framework by letting developers <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#function-implementation">implement</link>
and <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#function-execution">execute</link> Apache Geode functions with a simple POJO-based
annotation configuration model.</simpara>
<tip>
<simpara>See <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#_implementation_vs_execution">the section about implementation versus execution</link>
for the difference between Function implementation and execution.</simpara>
</tip>
<simpara>Taking this a step further, Spring Boot for Apache Geode auto-configures and enables both Function implementation
and execution out-of-the-box. Therefore, you can immediately begin writing Functions and invoking them without having to
worry about all the necessary plumbing to begin with. You can rest assured that it works as expected.</simpara>
</section>
<section xml:id="_applying_functions">
<title>Applying Functions</title>
<simpara>Earlier, when we talked about <link linkend="geode-caching-provider">caching</link>, we described a <literal>FinancialLoanApplicationService</literal> class
that could process eligibility when someone (represented by a <literal>Person</literal> object) applied for a financial loan.</simpara>
<simpara>This can be a very resource intensive and expensive operation, since it might involve collecting credit and employment
history, gathering information on outstanding loans, and so on. We applied caching in order to not have to recompute
or redetermine eligibility every time a loan office may want to review the decision with the customer.</simpara>
<simpara>But, what about the process of computing eligibility in the first place?</simpara>
<simpara>Currently, the application&#8217;s <literal>FinancialLoanApplicationService</literal> class seems to be designed to fetch the data and perform
the eligibility determination in place. However, it might be far better to distribute the processing and even determine
eligibility for a larger group of people all at once, especially when multiple, related people are involved in a single
decision, as is typically the case.</simpara>
<simpara>We can implement an <literal>EligibilityDeterminationFunction</literal> class by using SDG:</simpara>
<example>
<title>Function implementation</title>
<programlisting language="java" linenumbering="unnumbered">@Component
class EligibilityDeterminationFunction {

    @GemfireFunction(HA = true, hasResult = true, optimizeForWrite=true)
    public EligibilityDecision determineEligibility(FunctionContext functionContext, Person person, Timespan timespan) {
        // ...
    }
}</programlisting>
</example>
<simpara>By using the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/function/annotation/GemfireFunction.html"><literal>@GemfireFunction</literal></link>
annotation, we can implement our Function as a POJO method. SDG appropriately handles registering this POJO method
as a proper Function with Apache Geode.</simpara>
<simpara>If we now want to call this function from our Spring Boot <literal>ClientCache</literal> application, we can define
a function execution interface with a method name that matches the function name and that targets the execution
on the <literal>EligibilityDecisions</literal> Region:</simpara>
<example>
<title>Function execution</title>
<programlisting language="java" linenumbering="unnumbered">@OnRegion("EligibilityDecisions")
interface EligibilityDeterminationExecution {

  EligibilityDecision determineEligibility(Person person, Timespan timespan);

}</programlisting>
</example>
<simpara>We can then inject an instance of the <literal>EligibilityDeterminationExecution</literal> interface into our
<literal>FinancialLoanApplicationService</literal>, as we would any other object or Spring bean:</simpara>
<example>
<title>Function use</title>
<programlisting language="java" linenumbering="unnumbered">@Service
class FinancialLoanApplicationService {

    private final EligibilityDeterminationExecution execution;

    public LoanApplicationService(EligibilityDeterminationExecution execution) {
        this.execution = execution;
    }

    @Cacheable("EligibilityDecisions")
    EligibilityDecision processEligibility(Person person, Timespan timespan) {
        return this.execution.determineEligibility(person, timespan);
    }
}</programlisting>
</example>
<simpara>As with caching, no additional configuration is required to enable and find your application Function implementations
and executions. You can simply build and run. Spring Boot for Apache Geode handles the rest.</simpara>
<tip>
<simpara>It is common to "implement" and register your application Functions on the server and "execute" them from
the client.</simpara>
</tip>
</section>
</chapter>
<chapter xml:id="geode-continuous-query">
<title>Continuous Query</title>
<simpara>Some applications must process a stream of events as they happen and intelligently react in (near) real-time to
the countless changes in the data over time. Those applications need frameworks that can make processing a stream
of events as they happen as easy as possible.</simpara>
<simpara>Spring Boot for Apache Geode does just that, without users having to perform any complex setup or configure any
necessary infrastructure components to enable such functionality. Developers can define the criteria for the
data of interest and implement a handler (listener) to process the stream of events as they occur.</simpara>
<simpara><link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/continuous_querying/chapter_overview.html">Continuous Query (CQ)</link> lets you
easily define your criteria for the data you need. With CQ, you can express the criteria that match the data you need
by specifying a query predicate. Apache Geode implements the
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/querying_basics/query_basics.html">Object Query Language (OQL)</link>
for defining and executing queries. OQL resembles SQL and supports projections, query predicates, ordering,
and aggregates. Also, when used in CQs, they execute continuously, firing events when the data changes in such ways
as to match the criteria expressed in the query predicate.</simpara>
<simpara>Spring Boot for Apache Geode combines the ease of identifying the data you need by using an OQL query statement with
implementing the listener callback (handler) in one easy step.</simpara>
<simpara>For example, suppose you want to perform some follow-up action when a customer&#8217;s financial loan application is either
approved or denied.</simpara>
<simpara>First, the application model for our <literal>EligibilityDecision</literal> class might look something like the following:</simpara>
<example>
<title>EligibilityDecision class</title>
<programlisting language="java" linenumbering="unnumbered">@Region("EligibilityDecisions")
class EligibilityDecision {

    private final Person person;

    private Status status = Status.UNDETERMINED;

    private final Timespan timespan;

    enum Status {

        APPROVED,
        DENIED,
        UNDETERMINED,

    }
}</programlisting>
</example>
<simpara>Then we can implement and declare our CQ event handler methods to be notified when an eligibility decision is either
<literal>APPROVED</literal> or <literal>DENIED</literal>:</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@Component
class EligibilityDecisionPostProcessor {

    @ContinuousQuery(name = "ApprovedDecisionsHandler",
        query = "SELECT decisions.*
                 FROM /EligibilityDecisions decisions
                 WHERE decisions.getStatus().name().equalsIgnoreCase('APPROVED')")
    public void processApprovedDecisions(CqEvent event) {
        // ...
    }

    @ContinuousQuery(name = "DeniedDecisionsHandler",
        query = "SELECT decisions.*
                 FROM /EligibilityDecisions decisions
                 WHERE decisions.getStatus().name().equalsIgnoreCase('DENIED')")
    public void processDeniedDecisions(CqEvent event) {
        // ...
    }
}</programlisting>
</informalexample>
<simpara>Thus, when eligibility is processed and a decision has been made, either approved or denied, our application gets
notified, and as an application developer, you are free to code your handler and respond to the event any way you like.
Also, because our Continuous Query (CQ) handler class is a component (or a bean in the Spring <literal>ApplicationContext</literal>)
you can auto-wire any other beans necessary to carry out the application&#8217;s intended function.</simpara>
<simpara>This is not unlike Spring&#8217;s <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#jms-annotated">annotation-driven listener endpoints</link>,
which are used in (JMS) message listeners and handlers, except in Spring Boot for Apache Geode, you need not do anything
special to enable this functionality. You can declare the <literal>@ContinuousQuery</literal> annotation on any POJO method and go to
work on other things.</simpara>
</chapter>
<chapter xml:id="geode-data-using">
<title>Using Data</title>
<simpara>One of the most important tasks during development is ensuring your Spring Boot application handles data correctly.
To verify the accuracy, integrity, and availability of your data, your application needs data with which to work.</simpara>
<simpara>For those of you already familiar with Spring Boot&#8217;s support for
<link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-initialize-a-database-using-spring-jdbc">SQL database initialization</link>,
the approach when using Apache Geode should be easy to understand.</simpara>
<simpara>Apache Geode provides built-in support, similar in function to Spring Boot&#8217;s SQL database initialization, by using:</simpara>
<itemizedlist>
<listitem>
<simpara>Gfsh&#8217;s <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/tools_modules/gfsh/quick_ref_commands_by_area.html#topic_C7DB8A800D6244AE8FF3ADDCF139DCE4">import/export</link> data commands.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/managing/cache_snapshots/chapter_overview.html">Snapshot service</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/storing_data_on_disk/chapter_overview.html">Persistence</link> with <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/managing/disk_storage/chapter_overview.html">disk storage</link></simpara>
</listitem>
</itemizedlist>
<simpara>For example, by enabling persistence with disk storage, you could
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/managing/disk_storage/backup_restore_disk_store.html">backup and restore</link>
persistent <literal>DiskStore</literal> files from one cluster to another.</simpara>
<simpara>Alternatively, using Apache Geode&#8217;s Snapshot Service, you can export data contained in targeted <literal>Regions</literal> from one
cluster during shutdown and import the data into another cluster on startup. The Snapshot Service lets you filter data
while it is being imported and exported.</simpara>
<simpara>Finally, you can use Apache Geode shell (Gfsh) commands to
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/tools_modules/gfsh/command-pages/export.html#topic_263B70069BFC4A7185F86B3272011734">export data</link>
and <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/tools_modules/gfsh/command-pages/import.html#topic_jw2_2ld_2l">import data</link>.</simpara>
<tip>
<simpara>Spring Data for Apache Geode (SDG) contains dedicated support for
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap:region:persistence">persistence</link>
and the <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap:snapshot">Snapshot Service</link>.</simpara>
</tip>
<simpara>In all cases, the files generated by persistence, the Snapshot Service and Gfsh&#8217;s <literal>export</literal> command are in a proprietary
binary format.</simpara>
<simpara>Furthermore, none of these approaches are as convenient as Spring Boot&#8217;s database initialization automation. Therefore,
Spring Boot for Apache Geode (SBDG) offers support to import data from JSON into Apache Geode as PDX.</simpara>
<simpara>Unlike Spring Boot, SBDG offers support to export data as well. By default, data is imported and exported in JSON format.</simpara>
<note>
<simpara>SBDG does not provide an equivalent to Spring Boot&#8217;s <literal>schema.sql</literal> file. The best way to define the data structures
(the <literal>Region</literal> instances) that manage your data is with SDG&#8217;s annotation-based configuration support for defining cache
<literal>Region</literal> instances from your application&#8217;s <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-regions">entity classes</link>
or indirectly from Spring and JSR-107 or JCache <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-caching">caching annotations</link>.</simpara>
</note>
<tip>
<simpara>See SBDG&#8217;s <link linkend="geode-configuration-declarative-annotations-productivity-regions">documentation</link> on the same.</simpara>
</tip>
<warning>
<simpara>While this feature works and many edge cases were thought through and tested thoroughly, there are still some
limitations that need to be ironed out. See <link xl:href="https://github.com/spring-projects/spring-boot-data-geode/issues/82">issue-82</link>
and <link xl:href="https://github.com/spring-projects/spring-boot-data-geode/issues/83">issue-83</link> for more details. The Spring team
strongly recommends that this feature be used only for development and testing purposes.</simpara>
</warning>
<section xml:id="geode-data-using-import">
<title>Importing Data</title>
<simpara>You can import data into a <literal>Region</literal> by defining a JSON file that contain the JSON objects you wish to load. The JSON
file must follow a predefined naming convention and be placed in the root of your application classpath:</simpara>
<simpara><literal>data-&lt;regionName&gt;.json</literal></simpara>
<note>
<simpara><literal>&lt;regionName&gt;</literal> refers to the lowercase "name" of the <literal>Region</literal>, as defined by
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/Region.html#getName--"><literal>Region.getName()</literal></link>.</simpara>
</note>
<simpara>For example, if you have a <literal>Region</literal> named "Orders", you would create a JSON file called <literal>data-orders.json</literal> and place it
in the root of your application classpath (for example, in <literal>src/test/resources</literal>).</simpara>
<simpara>Create JSON files for each <literal>Region</literal> that is implicitly defined (for example, by using <literal>@EnableEntityDefinedRegions</literal>)
or explicitly defined (with <literal>ClientRegionFactoryBean</literal> in Java configuration) in your Spring Boot application
configuration that you want to load with data.</simpara>
<simpara>The JSON file that contains JSON data for the "Orders" <literal>Region</literal> might appear as follows:</simpara>
<example>
<title><literal>data-orders.json</literal></title>
<programlisting language="json" linenumbering="unnumbered">[{
  "@type": "example.app.pos.model.PurchaseOrder",
  "id": 1,
  "lineItems": [
    {
      "@type": "example.app.pos.model.LineItem",
      "product": {
        "@type": "example.app.pos.model.Product",
        "name": "Apple iPad Pro",
        "price": 1499.00,
        "category": "SHOPPING"
      },
      "quantity": 1
    },
    {
      "@type": "example.app.pos.model.LineItem",
      "product": {
        "@type": "example.app.pos.model.Product",
        "name": "Apple iPhone 11 Pro Max",
        "price": 1249.00,
        "category": "SHOPPING"
      },
      "quantity": 2
    }
  ]
}, {
  "@type": "example.app.pos.model.PurchaseOrder",
  "id": 2,
  "lineItems": [
    {
      "@type": "example.app.pos.model.LineItem",
      "product": {
        "@type": "example.app.pos.model.Product",
        "name": "Starbucks Vente Carmel Macchiato",
        "price": 5.49,
        "category": "SHOPPING"
      },
      "quantity": 1
    }
  ]
}]</programlisting>
</example>
<simpara>The application entity classes that matches the JSON data from the JSON file might look something like the following
listing:</simpara>
<example>
<title>Point-of-Sale (POS) Application Domain Model Classes</title>
<programlisting language="java" linenumbering="unnumbered">@Region("Orders")
class PurchaseOrder {

	@Id
    Long id;

	List&lt;LineItem&gt; lineItems;

}

class LineItem {

	Product product;
	Integer quantity;

}

@Region("Products")
class Product {

	String name;
	Category category;
	BigDecimal price;

}</programlisting>
</example>
<simpara>As the preceding listings show, the object model and corresponding JSON can be arbitrarily complex with a hierarchy of
objects that have complex types.</simpara>
<section xml:id="geode-data-using-import-metadata">
<title>JSON metadata</title>
<simpara>We want to draw your attention to a few other details contained in the object model and JSON shown
<link linkend="geode-data-using-import">earlier</link>.</simpara>
<section xml:id="geode-data-using-import-metadata-attype">
<title>The <literal>@type</literal> metadata field</title>
<simpara>First, we declared a <literal>@type</literal> JSON metadata field. This field does not map to any specific field or property of
the application domain model class (such as <literal>PurchaseOrder</literal>). Rather, it tells the framework and Apache Geode&#8217;s JSON/PDX
converter the type of object the JSON data would map to if you were to request an object (by calling
<literal>PdxInstance.getObject()</literal>).</simpara>
<simpara>Consider the following example:</simpara>
<example>
<title>Deserializing PDX as an Object</title>
<programlisting language="java" linenumbering="unnumbered">@Repository
class OrdersRepository {

    @Resource(name = "Orders")
    Region&lt;Long, PurchaseOrder&gt; orders;

    PurchaseOrder findBy(Long id) {

        Object value = this.orders.get(id);

        return value instanceof PurchaseOrder ? (PurchaseOrder) value
            : value instanceof PdxInstance ? ((PdxInstance) value).getObject()
            : null;
    }
}</programlisting>
</example>
<simpara>Basically, the <literal>@type</literal> JSON metadata field informs the <literal>PdxInstance.getObject()</literal> method about the type of Java object
to which the JSON object maps. Otherwise, the <literal>PdxInstance.getObject()</literal> method would silently return a <literal>PdxInstance</literal>.</simpara>
<simpara>It is possible for Apache Geode&#8217;s PDX serialization framework to return a <literal>PurchaseOrder</literal> from <literal>Region.get(key)</literal> as well,
but it depends on the value of PDX&#8217;s <literal>read-serialized</literal>, cache-level configuration setting, among other factors.</simpara>
<note>
<simpara>When JSON is imported into a <literal>Region</literal> as PDX, the
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/pdx/PdxInstance.html#getClassName--"><literal>PdxInstance.getClassName()</literal></link>
does not refer to a valid Java class. It is
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/pdx/JSONFormatter.html#JSON_CLASSNAME"><literal>JSONFormatter.JSON_CLASSNAME</literal></link>.
As a result, <literal>Region</literal> data access operations, such as <literal>Region.get(key)</literal>, return a <literal>PdxInstance</literal> and not a Java object.</simpara>
</note>
<tip>
<simpara>You may need to proxy <literal>Region</literal> read data access operations (such as <literal>Region.get(key)</literal>) by setting the SBDG property
<literal>spring.boot.data.gemfire.cache.region.advice.enabled</literal> to <literal>true</literal>. When this property is set, <literal>Region</literal> instances are
proxied to wrap a <literal>PdxInstance</literal> in a <literal>PdxInstanceWrapper</literal> to appropriately handle the <literal>PdxInstance.getObject()</literal> call
in your application code.</simpara>
</tip>
</section>
<section xml:id="geode-data-using-import-metadata-id">
<title>The <literal>id</literal> field and the <literal>@identifier</literal> metadata field</title>
<simpara>Top-level objects in your JSON must have an identifier, such as an <literal>id</literal> field. This identifier is used as the identity
and key of the object (or <literal>PdxInstance</literal>) when stored in the <literal>Region</literal> (for example, <literal>Region.put(key, object)</literal>).</simpara>
<simpara>You may have noticed that the JSON for the "Orders" <literal>Region</literal> shown earlier declared an <literal>id</literal> field as the identifier:</simpara>
<example>
<title>PurchaseOrder identifier ("id")</title>
<programlisting language="text" linenumbering="unnumbered">[{
  "@type": "example.app.pos.model.PurchaseOrder",
  "id": 1,
  ...</programlisting>
</example>
<simpara>This follows the same convention used in Spring Data. Typically, Spring Data mapping infrastructure looks for a POJO
field or property annotated with <link xl:href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/annotation/Id.html"><literal>@Id</literal></link>. If no
field or property is annotated with <literal>@Id</literal>, the framework falls back to searching for a field or property named <literal>id</literal>.</simpara>
<simpara>In Spring Data for Apache Geode, this <literal>@Id</literal>-annotated or <literal>id</literal>-named field or property is used as the identifier
and as the key for the object when storing it into a <literal>Region</literal>.</simpara>
<simpara>However, what happens when an object or entity does not have a surrogate ID defined? Perhaps the application domain
model class is appropriately using natural identifiers, which is quite common in practice.</simpara>
<simpara>Consider a <literal>Book</literal> class defined as follows:</simpara>
<example>
<title>Book class</title>
<programlisting language="java" linenumbering="unnumbered">@Region("Books")
class Book {

	Author author;

	@Id
	ISBN isbn;

	LocalDate publishedDate;

	Sring title;

}</programlisting>
</example>
<simpara>As declared in the <literal>Book</literal> class, the identifier for <literal>Book</literal> is its <literal>ISBN</literal>, since the <literal>isbn</literal> field was annotated with
Spring Data&#8217;s <literal>@Id</literal> mapping annotation. However, we cannot know this by searching for an <literal>@Id</literal> annotation in JSON.</simpara>
<simpara>You might be tempted to argue that if the <literal>@type</literal> metadata field is set, we would know the class type and could load
the class definition to learn about the identifier. That is all fine until the class is not actually on the application
classpath in the first place. This is one of the reasons why SBDG&#8217;s JSON support serializes JSON to Apache Geode&#8217;s PDX
format. There might not be a class definition, which would lead to a <literal>NoClassDefFoundError</literal> or <literal>ClassNotFoundException</literal>.</simpara>
<simpara>So, what then?</simpara>
<simpara>In this case, SBDG lets you declare the <literal>@identifier</literal> JSON metadata field to inform the framework what to use as
the identifier for the object.</simpara>
<simpara>Consider the following example:</simpara>
<example>
<title>Using "@identifer"</title>
<programlisting language="json" linenumbering="unnumbered">{
  "@type": "example.app.books.model.Book",
  "@identifier": "isbn",
  "author": {
    "id": 1,
    "name": "Josh Long"
  },
  "isbn": "978-1-449-374640-8",
  "publishedDate": "2017-08-01",
  "title": "Cloud Native Java"
}</programlisting>
</example>
<simpara>The <literal>@identifier</literal> JSON metadata field informs the framework that the <literal>isbn</literal> field is the identifier for a <literal>Book</literal>.</simpara>
</section>
</section>
<section xml:id="geode-data-using-import-conditional">
<title>Conditionally Importing Data</title>
<simpara>While the Spring team recommends that users should only use this feature when developing and testing their Spring Boot
applications with Apache Geode, you may still occasionally use this feature in production.</simpara>
<simpara>You might use this feature in production to preload a (REPLICATE) Region with reference data. Reference data is largely
static, infrequently changing, and non-transactional. Preloading reference data is particularly useful when you want to
warm the cache.</simpara>
<simpara>When you use this feature for development and testing purposes, you can put your <literal>Region</literal>-specific JSON files in
<literal>src/test/resources</literal>. This ensures that the files are not included in your application artifact (such as a JAR or WAR)
when built and deployed to production.</simpara>
<simpara>However, if you must use this feature to preload data in your production environment, you can still conditionally load
data from JSON. To do so, configure the <literal>spring.boot.data.gemfire.cache.data.import.active-profiles</literal> property set to
the Spring profiles that must be active for the import to take effect.</simpara>
<simpara>Consider the following example:</simpara>
<example>
<title>Conditional Importing JSON</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties

spring.boot.data.gemfire.cache.data.import.active-profiles=DEV, QA</programlisting>
</example>
<simpara>For import to have an effect in this example, you must specifically set the <literal>spring.profiles.active</literal> property to one of
the valid, <literal>active-profiles</literal> listed in the import property (such as <literal>QA</literal>). Only one needs to match.</simpara>
<note>
<simpara>There are many ways to conditionally build application artifacts. You might prefer to handle this concern in your
Gradle or Maven build.</simpara>
</note>
</section>
</section>
<section xml:id="geode-data-using-export">
<title>Exporting Data</title>
<simpara>Certain data stored in your application&#8217;s <literal>Regions</literal> may be sensitive or confidential, and keeping the data secure is of
the utmost concern and priority. Therefore, exporting data is <emphasis role="strong">disabled</emphasis> by default.</simpara>
<simpara>However, if you use this feature for development and testing purposes, enabling the export capability may be useful to
move data from one environment to another. For example, if your QA team finds a bug in the application that uses a
particular data set, they can export the data and pass it back to the development team to import in their local
development environment to help debug the issue.</simpara>
<simpara>To enable export, set the <literal>spring.boot.data.gemfire.cache.data.export.enabled</literal> property to <literal>true</literal>:</simpara>
<example>
<title>Enable Export</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties

spring.boot.data.gemfire.cache.data.export.enabled=true</programlisting>
</example>
<simpara>SBDG is careful to export data to JSON in a format that Apache Geode expects on import and includes things such as
<literal>@type</literal> metadata fields.</simpara>
<warning>
<simpara>The <literal>@identifier</literal> metadata field is not generated automatically. While it is possible for POJOs stored in a
<literal>Region</literal> to include an <literal>@identifier</literal> metadata field when exported to JSON, it is not possible when the <literal>Region</literal> value
is a <literal>PdxInstance</literal> that did not originate from JSON. In this case, you must manually ensure that the <literal>PdxInstance</literal>
includes an <literal>@identifier</literal> metadata field before it is exported to JSON if necessary (for example, <literal>Book.isbn</literal>). This is
only necessary if your entity classes do not declare an explicit identifier field, such as with the <literal>@Id</literal> mapping
annotation, or do not have an <literal>id</literal> field. This scenario can also occur when inter-operating with native clients
that model the application domain objects differently and then serialize the objects by using PDX, storing them in
Regions on the server that are then later consumed by your Java-based, Spring Boot application.</simpara>
</warning>
<warning>
<simpara>You may need to set the <literal>-Dgemfire.disableShutdownHook</literal> JVM System property to <literal>true</literal> before your Spring
Boot application starts up when using export. Unfortunately, this Java runtime shutdown hook is registered and enabled
in Apache Geode  by default, which results in the cache and the Regions being closed before the SBDG Export
functionality can export the data, thereby resulting in a <literal>CacheClosedException</literal>. SBDG
{github-url}/spring-geode-autoconfigure/src/main/java/org/springframework/geode/boot/autoconfigure/DataImportExportAutoConfiguration.java#L173-L183[makes a best effort]
to disable the Apache Geode JVM shutdown hook when export is enabled, but it is at the mercy of the JVM <literal>ClassLoader</literal>,
since Apache Geode&#8217;s JVM shutdown hook
{apache-geode-src}/geode-core/src/main/java/org/apache/geode/distributed/internal/InternalDistributedSystem.java#L2185-L2223[registration]
is declared in a <literal>static</literal> initializer.</simpara>
</warning>
</section>
<section xml:id="geode-data-using-import-export-api-extensions">
<title>Import/Export API Extensions</title>
<simpara>The API in SBDG for import and export functionality is separated into the following concerns:</simpara>
<itemizedlist>
<listitem>
<simpara>Data Format</simpara>
</listitem>
<listitem>
<simpara>Resource Resolving</simpara>
</listitem>
<listitem>
<simpara>Resource Reading</simpara>
</listitem>
<listitem>
<simpara>Resource Writing</simpara>
</listitem>
</itemizedlist>
<simpara>By breaking each of these functions apart into separate concerns, a developer can customize each aspect of the import
and export functions.</simpara>
<simpara>For example, you could import XML from the filesystem and then export JSON to a REST-based Web Service. By default, SBDG
imports JSON from the classpath and exports JSON to the filesystem.</simpara>
<simpara>However, not all environments expose a filesystem, such as cloud environments like PCF. Therefore, giving users control
over each aspect of the import and export processes is essential for performing the functions in any environment.</simpara>
<section xml:id="geode-data-using-import-export-api-extensions-data-format">
<title>Data Format</title>
<simpara>The primary interface to import data into a <literal>Region</literal> is <literal>CacheDataImporter</literal>.</simpara>
<simpara><literal>CacheDataImporter</literal> is a <literal>@FunctionalInterface</literal> that extends Spring&#8217;s
<link xl:href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html"><literal>BeanPostProcessor</literal></link>
interface to trigger the import of data after the <literal>Region</literal> has been initialized.</simpara>
<simpara>The interface is defined as follows:</simpara>
<example>
<title><literal>CacheDataImporter</literal></title>
<programlisting language="java" linenumbering="unnumbered">interface CacheDataImporter extends BeanPostProcessor {

	Region importInto(Region region);

}</programlisting>
</example>
<simpara>You can code the <literal>importInto(:Region)</literal> method to handle any data format (JSON, XML, and others) you prefer. Register a
bean that implements the <literal>CacheDataImporter</literal> interface in the Spring container, and the importer does its job.</simpara>
<simpara>On the flip side, the primary interface to export data from a <literal>Region</literal> is the <literal>CacheDataExporter</literal>.</simpara>
<simpara><literal>CacheDataExporter</literal> is a <literal>@FunctionalInterface</literal> that extends Spring&#8217;s
<link xl:href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/DestructionAwareBeanPostProcessor.html"><literal>DestructionAwareBeanPostProcessor</literal></link>
interface to trigger the export of data before the <literal>Region</literal> is destroyed.</simpara>
<simpara>The interface is defined as follows:</simpara>
<example>
<title><literal>CacheDataExporter</literal></title>
<programlisting language="java" linenumbering="unnumbered">interface CacheDataExporter extends DestructionAwareBeanPostProcessor {

	Region exportFrom(Region region);
}</programlisting>
</example>
<simpara>You can code the <literal>exportFrom(:Region)</literal> method to handle any data format (JSON, XML, and others) you prefer. Register a
bean implementing the <literal>CacheDataExporter</literal> interface in the Spring container, and the exporter does its job.</simpara>
<simpara>For convenience, when you want to implement both import and export functionality, SBDG provides the
<literal>CacheDataImporterExporter</literal> interface, which extends both <literal>CacheDataImporter</literal> and <literal>CacheDataExporter</literal>:</simpara>
<example>
<title><literal>CacheDataImporterExporter</literal></title>
<programlisting language="java" linenumbering="unnumbered">interface CacheDataImporterExporter extends CacheDataExporter, CacheDataImporter { }</programlisting>
</example>
<simpara>For added support, SBDG also provides the <literal>AbstractCacheDataImporterExporter</literal> abstract base class to simplify
the implementation of your importer/exporter.</simpara>
<section xml:id="geode-data-using-import-export-api-extensions-data-format-lifecycle-management">
<title>Lifecycle Management</title>
<simpara>Sometimes, it is necessary to precisely control when data is imported or exported.</simpara>
<simpara>This is especially true on import, since different <literal>Region</literal> instances may be collocated or tied together through a
cache callback, such as a <literal>CacheListener</literal>. In these cases, the other <literal>Region</literal> may need to exist before the import
on the dependent <literal>Region</literal> proceeds, particularly if the dependencies were loosely defined.</simpara>
<simpara>Controlling the import is also important when you use SBDG&#8217;s <literal>@EnableClusterAware</literal> annotation to push configuration
metadata from the client to the cluster in order to define server-side <literal>Region</literal> instances that match the client-side
<literal>Region</literal> instances, especially client <literal>Region</literal> instances targeted for import. The matching <literal>Region</literal> instances on the
server side must exist before data is imported into client (<literal>PROXY</literal>) <literal>Region</literal> instances.</simpara>
<simpara>In all cases, SBDG provides the <literal>LifecycleAwareCacheDataImporterExporter</literal> class to wrap your <literal>CacheDataImporterExporter</literal>
implementation. This class implements Spring&#8217;s
<link xl:href="https://docs.spring.io/spring/docs/current/javadoc-api/https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/SmartLifecycle.html"><literal>SmartLifecycle</literal></link>
interface.</simpara>
<simpara>By implementing the <literal>SmartLifecycle</literal> interface, you can control in which <literal>phase</literal> of the Spring container the import
occurs. SBDG also exposes two more properties to control the lifecycle:</simpara>
<example>
<title>Lifecycle Management Properties</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties

spring.boot.data.gemfire.cache.data.import.lifecycle=[EAGER|LAZY]
spring.boot.data.gemfire.cache.data.import.phase=1000000</programlisting>
</example>
<simpara><literal>EAGER</literal> acts immediately, after the <literal>Region</literal> is initialized (the default behavior). <literal>LAZY</literal> delays the import until the
<literal>start()</literal> method is called, which is invoked according to the <literal>phase</literal>, thereby ordering the import relative to the other
lifecycle-aware components that are registered in the Spring container.</simpara>
<simpara>The following example shows how to make your <literal>CacheDataImporterExporter</literal> lifecycle-aware:</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@Configuration
class MyApplicationConfiguration {

	@Bean
    CacheDataImporterExporter importerExporter() {
		return new LifecycleAwareCacheDataImporterExporter(new MyCacheDataImporterExporter());
    }
}</programlisting>
</informalexample>
</section>
</section>
<section xml:id="geode-data-using-import-export-api-extensions-resource-resolution">
<title>Resource Resolution</title>
<simpara>Resolving resources used for import and export results in the creation of a Spring
<link xl:href="https://docs.spring.io/spring/docs/current/javadoc-api/https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/io/Resource.html"><literal>Resource</literal></link>
handle.</simpara>
<simpara>Resource resolution is a vital step to qualifying a resource, especially if the resource requires special logic
or permissions to access it. In this case, specific <literal>Resource</literal> handles can be returned and used by the reader
and writer of the <literal>Resource</literal> as appropriate for import or export operation.</simpara>
<simpara>SBDG encapsulates the algorithm for resolving <literal>Resources</literal> in the <literal>ResourceResolver</literal>
(<link xl:href="https://en.wikipedia.org/wiki/Strategy_pattern">Strategy</link>) interface:</simpara>
<example>
<title>ResourceResolver</title>
<programlisting language="java" linenumbering="unnumbered">@FunctionalInterface
interface ResourceResolver {

	Optional&lt;Resource&gt; resolve(String location);

	default Resouce required(String location) {
		// ...
    }
}</programlisting>
</example>
<simpara>Additionally, SBDG provides the <literal>ImportResourceResolver</literal> and <literal>ExportResourceResolver</literal> marker interfaces and the
<literal>AbstractImportResourceResolver</literal> and <literal>AbstractExportResourceResolver</literal> abstract base classes for implementing the
resource resolution logic used by both import and export operations.</simpara>
<simpara>If you wish to customize the resolution of <literal>Resources</literal> used for import or export, your <literal>CacheDataImporterExporter</literal>
implementation can extend the <literal>ResourceCapableCacheDataImporterExporter</literal> abstract base class, which provides the
aforementioned interfaces and base classes.</simpara>
<simpara>As stated earlier, SBDG resolves resources on import from the classpath and resources on export to the filesystem.</simpara>
<simpara>You can customize this behavior by providing an implementation of <literal>ImportResourceResolver</literal>, <literal>ExportResourceResolver</literal>,
or both interfaces and declare instances as beans in the Spring context:</simpara>
<example>
<title>Import &amp; Export ResourceResolver beans</title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
class MyApplicationConfiguration {

	@Bean
    ImportResourceResolver importResourceResolver() {
		return new MyImportResourceResolver();
    }

    @Bean
    ExportResourceResolver exportResourceResolver() {
		return new MyExportResourceResolver();
    }
}</programlisting>
</example>
<tip>
<simpara>If you need to customize the resource resolution process for each location (or <literal>Region</literal>) on import or export,
you can use the <link xl:href="https://en.wikipedia.org/wiki/Composite_pattern">Composite software design pattern</link>.</simpara>
</tip>
<section xml:id="geode-data-using-import-export-api-extensions-resource-resolution-default-customization">
<title>Customize Default Resource Resolution</title>
<simpara>If you are content with the provided defaults but want to target specific locations on the classpath or filesystem
used by the import or export, SBDG additionally provides the following properties:</simpara>
<example>
<title>Import/Export Resource Location Properties</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties

spring.boot.data.gemfire.cache.data.import.resource.location=...
spring.boot.data.gemfire.cache.data.export.resource.location=...</programlisting>
</example>
<simpara>The properties accept any valid resource string, as specified in the Spring
<link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#resources-resourceloader">documentation</link> (see <emphasis role="strong">Table 10. Resource strings</emphasis>).</simpara>
<simpara>This means that, even though import defaults from the classpath, you can change the location from classpath
to filesystem, or even network (for example, https://) by changing the prefix (or protocol).</simpara>
<simpara>Import/export resource location properties can refer to other properties through property placeholders, but SBDG
further lets you use SpEL inside the property values.</simpara>
<simpara>Consider the following example:</simpara>
<example>
<title>Using SpEL</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties

spring.boot.data.gemfire.cache.data.import.resource.location=\
  https://#{#env['user.name']}:#{someBean.lookupPassword(#env['user.name'])}@#{host}:#{port}/cache/#{#regionName}/data/import</programlisting>
</example>
<simpara>In this case, the import resource location refers to a rather sophisticated resource string by using a complex SpEL
expression.</simpara>
<simpara>SBDG populates the SpEL <literal>EvaluationContext</literal> with three sources of information:</simpara>
<itemizedlist>
<listitem>
<simpara>Access to the Spring <literal>BeanFactory</literal></simpara>
</listitem>
<listitem>
<simpara>Access to the Spring <literal>Environment</literal></simpara>
</listitem>
<listitem>
<simpara>Access to the current <literal>Region</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Simple Java System properties or environment variables can be accessed with the following expression:</simpara>
<informalexample>
<programlisting language="text" linenumbering="unnumbered">#{propertyName}</programlisting>
</informalexample>
<simpara>You can access more complex property names (including properties that use dot notation, such as the <literal>user.home</literal>
Java System property), directly from the <literal>Environment</literal> by using map style syntax as follows:</simpara>
<informalexample>
<programlisting language="text" linenumbering="unnumbered">#{#env['property.name']}</programlisting>
</informalexample>
<simpara>The <literal>#env</literal> variable is set in the SpEL <literal>EvaluationContext</literal> to the Spring <literal>Environment</literal>.</simpara>
<simpara>Because the SpEL <literal>EvaluationContext</literal> is evaluated with the Spring <literal>ApplicationContext</literal> as the root object, you also have
access to the beans declared and registered in the Spring container and can invoke methods on them, as shown earlier
with <literal>someBean.lookupPassword(..)</literal>. <literal>someBean</literal> must be the name of the bean as declared and registered in the Spring
container.</simpara>
<caution>
<simpara>Be careful when accessing beans declared in the Spring container with SpEL, particularly when using <literal>EAGER</literal>
import, as it may force those beans to be eagerly (or even prematurely) initialized.</simpara>
</caution>
<simpara>SBDG also sets the <literal>#regionName</literal> variable in the <literal>EvaluationContext</literal> to the name of the <literal>Region</literal>, as determined by
<link xl:href="https://geode.apache.org/releases/latest/javadoc/https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/Region.html#getName--"><literal>Region.getName()</literal></link>,
targeted for import and export.</simpara>
<simpara>This lets you not only change the location of the resource but also change the resource name (such as a filename).</simpara>
<simpara>Consider the following example:</simpara>
<example>
<title>Using <literal>#regionName</literal></title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties

spring.boot.data.gemfire.cache.data.export.resource.location=\
    file://#{#env['user.home']}/gemfire/cache/data/custom-filename-for-#{#regionName}.json</programlisting>
</example>
<note>
<simpara>By default, the exported file is stored in the working directory (<literal>System.getProperty("user.dir")</literal>)
of the Spring Boot application process.</simpara>
</note>
<tip>
<simpara>See the Spring Framework <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions">documentation</link> for more information on SpEL.</simpara>
</tip>
</section>
</section>
<section xml:id="geode-data-using-import-export-api-extensions-resource-reading-writing">
<title>Reading &amp; Writing Resources</title>
<simpara>The Spring <link xl:href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/io/Resource.html"><literal>Resource</literal></link> handle
specifies tion of a resource, not how the resource is read or written. Even the Spring
<link xl:href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/io/ResourceLoader.html"><literal>ResourceLoader</literal></link>,
which is an interface for loading <literal>Resources</literal>, does not specifically read or write any content to the <literal>Resource</literal>.</simpara>
<simpara>SBDG separates these concerns into two interfaces: <literal>ResourceReader</literal> and <literal>ResourceWriter</literal>, respectively.
The design follows the same pattern used by Java&#8217;s <literal>InputStream/OutputStream</literal> and <literal>Reader/Writer</literal> classes
in the <literal>java.io</literal> package.</simpara>
<simpara>The <literal>ResourceReader</literal> interfaces is defined as:</simpara>
<example>
<title>ResourceReader</title>
<programlisting language="java" linenumbering="unnumbered">@FunctionalInterface
interface ResourceReader {

    byte[] read(Resource resource);

}</programlisting>
</example>
<simpara>The <literal>ResourceWriter</literal> interfaces is defined as:</simpara>
<example>
<title>ResourceWriter</title>
<programlisting language="java" linenumbering="unnumbered">@FunctionalInterface
interface ResourceWriter {

    void write(Resource resource, byte[] data);

}</programlisting>
</example>
<simpara>Both interfaces provide additional methods to compose readers and writers, much like Java&#8217;s <literal>Consumer</literal> and <literal>Function</literal>
interfaces in the <literal>java.util.function</literal> package. If a particular reader or writer is used in a composition and is unable
to handle the given <literal>Resource</literal>, it should throw a <literal>UnhandledResourceException</literal> to let the next reader or writer in the
composition try to read from or write to the <literal>Resource</literal>.</simpara>
<simpara>The reader or writer are free to throw a <literal>ResourceReadException</literal> or <literal>ResourceWriteException</literal> to break the chain of
reader and writer invocations in the composition.</simpara>
<simpara>To override the default export/import reader and writer used by SBDG, you can implement the <literal>ResourceReader</literal>
or <literal>ResourceWriter</literal> interfaces as appropriate and declare instances of these classes as beans in the Spring container:</simpara>
<example>
<title>Custom <literal>ResourceReader</literal> &amp; <literal>ResourceWriter</literal> beans</title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
class MyApplicationConfiguration {

	@Bean
    ResourceReader myResourceReader() {
		return new MyResourceReader()
            .thenReadFrom(new MyOtherResourceReader());
    }

    @Bean
    ResourceWriter myResourceWriter() {
		return new MyResourceWriter();
    }
}</programlisting>
</example>
</section>
</section>
</chapter>
<chapter xml:id="geode-data-serialization">
<title>Data Serialization with PDX</title>
<simpara>Anytime data is overflowed or persisted to disk, transferred between clients and servers, transferred between peers
in a cluster or between different clusters in a multi-site WAN topology, all data stored in Apache Geode must be
serializable.</simpara>
<simpara>To serialize objects in Java, object types must implement the <literal>java.io.Serializable</literal> interface. However, if you have a
large number of application domain object types that currently do not implement <literal>java.io.Serializable</literal>, refactoring
hundreds or even thousands of class types to implement <literal>java.io.Serializable</literal> would be a tedious task just to store
and manage those objects in Apache Geode.</simpara>
<simpara>Additionally, it is not only your application domain object types you necessarily need to consider. If you used
third-party libraries in your application domain model, any types referred to by your application domain object types
stored in Apache Geode must also be serializable. This type explosion may bleed into class types for which you may have
no control over.</simpara>
<simpara>Furthermore, Java serialization is not the most efficient format, given that metadata about your types is stored with
the data itself. Therefore, even though Java serialized bytes are more descriptive, it adds a great deal of overhead.</simpara>
<simpara>Then, along came serialization using Apache Geode&#8217;s
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/data_serialization/gemfire_pdx_serialization.html">PDX</link> format.
PDX stands for Portable Data Exchange and achieves four goals:</simpara>
<itemizedlist>
<listitem>
<simpara>Separates type metadata from the data itself, streamlining the bytes during transfer. Apache Geode maintains a type
registry that stores type metadata about the objects serialized with PDX.</simpara>
</listitem>
<listitem>
<simpara>Supports versioning as your application domain types evolve. It is common to have old and new versions of the same
application deployed to production, running simultaneously, sharing data, and possibly using different versions of the
same domain types. PDX lets fields be added or removed while still preserving interoperability between old and new
application clients without loss of data.</simpara>
</listitem>
<listitem>
<simpara>Enables objects stored as PDX to be queried without being de-serialized. Constant serialization and deserialization of
data is a resource-intensive task that adds to the latency of each data request when redundancy is enabled. Since data
is replicated across peers in the cluster to preserve High Availability (HA) and must be serialized to be transferred,
keeping data serialized is more efficient when data is updated frequently, since it is likely the data will need to be
transferred again in order to maintain consistency in the face of redundancy and availability.</simpara>
</listitem>
<listitem>
<simpara>Enables interoperability between native language clients (such as C, C++ and C#) and Java language clients, with each
being able to access the same data set regardless from where the data originated.</simpara>
</listitem>
</itemizedlist>
<simpara>However, PDX does have limitations.</simpara>
<simpara>For instance, unlike Java serialization, PDX does not handle cyclic dependencies. Therefore, you must be careful how you
structure and design your application domain object types.</simpara>
<simpara>Also, PDX cannot handle field type changes.</simpara>
<simpara>Furthermore, while Apache Geode&#8217;s general <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/data_serialization/gemfire_data_serialization.html">Data Serialization</link>
handles <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/delta_propagation/chapter_overview.html">Deltas</link>, this is not achievable without
de-serializing the object, since it involves a method invocation, which defeats one of the key benefits of PDX:
preserving format to avoid the cost of serialization and deserialization.</simpara>
<simpara>However, we think the benefits of using PDX outweigh the limitations and, therefore, have enabled PDX by default.</simpara>
<simpara>You need do nothing special. You can code your domain types and rest assured that objects of those domain types are
properly serialized when overflowed and persisted to disk, transferred between clients and servers, transferred between
peers in a cluster, and even when data is transferred over the network when you use Apache Geode&#8217;s multi-site WAN
topology.</simpara>
<example>
<title>EligibilityDecision is automatically serialiable without implementing Java Serializable.</title>
<programlisting language="java" linenumbering="unnumbered">@Region("EligibilityDecisions")
class EligibilityDecision {
    // ...
}</programlisting>
</example>
<note>
<simpara>Apache Geode does <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/data_serialization/java_serialization.html">support</link> the standard
Java Serialization format.</simpara>
</note>
<section xml:id="_sdg_mappingpdxserializer_vs_apache_geodes_reflectionbasedautoserializer">
<title>SDG <literal>MappingPdxSerializer</literal> vs. Apache Geode&#8217;s <literal>ReflectionBasedAutoSerializer</literal></title>
<simpara>Under-the-hood, Spring Boot for Apache Geode <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-pdx">enables</link>
and uses Spring Data for Apache Geode&#8217;s
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/mapping/MappingPdxSerializer.html"><literal>MappingPdxSerializer</literal></link>
to serialize your application domain objects with PDX.</simpara>
<tip>
<simpara>See the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#mapping.pdx-serializer">Reference Guide</link> for more details
on the <literal>MappingPdxSerializer</literal> class.</simpara>
</tip>
<simpara>The <literal>MappingPdxSerializer</literal> class offers several advantages above and beyond Apache Geode&#8217;s own
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/pdx/ReflectionBasedAutoSerializer.html"><literal>ReflectionBasedAutoSerializer</literal></link> class.</simpara>
<tip>
<simpara>See Apache Geode&#8217;s <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/developing/data_serialization/auto_serialization.html">User Guide</link>
for more details about the <literal>ReflectionBasedAutoSerializer</literal>.</simpara>
</tip>
<simpara>The SDG <literal>MappingPdxSerializer</literal> class offers the following benefits and capabilities:</simpara>
<itemizedlist>
<listitem>
<simpara>PDX serialization is based on Spring Data&#8217;s powerful mapping infrastructure and metadata.</simpara>
</listitem>
<listitem>
<simpara>Includes support for both <literal>includes</literal> and <literal>excludes</literal> with first-class
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#mapping.pdx-serializer.type-filtering">type filtering</link>.
Additionally, you can implement type filters by using Java&#8217;s <literal>java.util.function.Predicate</literal> interface as opposed to
the limited regex capabilities provided by Apache Geode&#8217;s <literal>ReflectionBasedAutoSerializer</literal> class. By default,
<literal>MappingPdxSerializer</literal> excludes all types in the following packages: <literal>java</literal>, <literal>org.apache.geode</literal>, <literal>org.springframework</literal>
and <literal>com.gemstone.gemfire</literal>.</simpara>
</listitem>
<listitem>
<simpara>Handles <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#mapping.pdx-serializer.transient-properties">transient object fields
and properties</link> when either Java&#8217;s <literal>transient</literal> keyword or Spring Data&#8217;s <literal>@Transient</literal> annotation is used.</simpara>
</listitem>
<listitem>
<simpara>Handles <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#mapping.pdx-serializer.read-only-properties">read-only object properties</link>.</simpara>
</listitem>
<listitem>
<simpara>Automatically determines the identifier of your entities when you annotate the appropriate entity field or property
with Spring Data&#8217;s <link xl:href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/annotation/Id.html"><literal>@Id</literal></link> annotation.</simpara>
</listitem>
<listitem>
<simpara>Lets additional <literal>o.a.g.pdx.PdxSerializers</literal> be registered to
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#mapping.pdx-serializer.custom-serialization">customize the serialization</link>
of nested entity/object field and property types.</simpara>
</listitem>
</itemizedlist>
<simpara>The support for <literal>includes</literal> and <literal>excludes</literal> deserves special attention, since the <literal>MappingPdxSerializer</literal> excludes all Java,
Spring, and Apache Geode types, by default. However, what happens when you need to serialize one of those types?</simpara>
<simpara>For example, suppose you need to serialize objects of type <literal>java.security.Principal</literal>. Then you can override the excludes
by registering an <literal>include</literal> type filter:</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">package example.app;

import java.security.Principal;

@SpringBootApplication
@EnablePdx(serializerBeanName = "myCustomMappingPdxSerializer")
class SpringBootApacheGeodeClientCacheApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootApacheGeodeClientCacheApplication.class, args);
    }

    @Bean
    MappingPdxSerializer myCustomMappingPdxSerializer() {

        MappingPdxSerializer customMappingPdxSerializer =
            MappingPdxSerializer.newMappginPdxSerializer();

        customMappingPdxSerializer.setIncludeTypeFilters(
            type -&gt; Principal.class.isAssignableFrom(type));

        return customMappingPdxSerializer;
    }
}</programlisting>
</informalexample>
<tip>
<simpara>Normally, you need not explicitly declare SDG&#8217;s <literal>@EnablePdx</literal> annotation to enable and configure PDX. However,
if you want to override auto-configuration, as we have demonstrated above, you must do this.</simpara>
</tip>
</section>
</chapter>
<chapter xml:id="geode-logging">
<title>Logging</title>
<simpara>Apache Geode <literal>1.9.2</literal> was modularized to separate its use of the Apache Log4j API to log output in Apache Geode code
from the underlying implementation of logging, which uses Apache Log4j as the logging provider by default.</simpara>
<simpara>Prior to <literal>1.9.2</literal>, the Apache Log4j API (<literal>log4j-api</literal>) and the Apache Log4j service provider (<literal>log4j-core</literal>)
were automatically pulled in by Apache Geode core (<literal>org.apache.geode:geode-core</literal>), thereby making it problematic
to change logging providers when using Apache Geode in Spring Boot applications.</simpara>
<simpara>However, now, in order to get any log output from Apache Geode whatsoever, Apache Geode requires a logging provider
declared on your Spring Boot application classpath. Consequently, this also means the old Apache Geode <literal>Properties</literal>
(such as <literal>log-level</literal>) no longer have any effect, regardless of whether the property is specified in <literal>gemfire.properties</literal>,
in Spring Boot <literal>application.properties</literal>, or even as a JVM System Property (<literal>-Dgemfire.log-level</literal>).</simpara>
<tip>
<simpara>See Apache Geode&#8217;s <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/reference/topics/gemfire_properties.html">documentation</link> for a complete list
of valid <literal>Properties</literal>, including the <literal>Properties</literal> used to configure logging.</simpara>
</tip>
<simpara>Unfortunately, this also means the Spring Data for Apache Geode
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableLogging.html"><literal>@EnableLogging</literal></link>
annotation no longer has any effect on Apache Geode logging either. Consequently, it has been
<link xl:href="https://jira.spring.io/browse/DATAGEODE-299">deprecated</link>. The reason <literal>@EnableLogging</literal> no longer has any effect on logging
is because this annotation&#8217;s attributes and associated SDG properties indirectly set the corresponding Apache Geode
properties, which, again, are useless from Apache Geode <literal>1.9.2</literal> onward.</simpara>
<simpara>By way of example, and to make this concrete, <emphasis role="strong">none</emphasis> of the following approaches have any effect on Apache Geode logging:</simpara>
<example>
<title>Command-line configuration</title>
<programlisting language="txt" linenumbering="unnumbered">$ java -classpath ...:/path/to/MySpringBootApacheGeodeClientCacheApplication.jar -Dgemfire.log-level=DEBUG
    example.app.MySpringBootApacheGeodeClientCacheApplication</programlisting>
</example>
<example>
<title>Externalized configuration using Apache Geode <literal>gemfire.properties</literal></title>
<programlisting language="properties" linenumbering="unnumbered"># {geode-name} only/specific properties
log-level=INFO</programlisting>
</example>
<example>
<title>Externalized configuration using Spring Boot <literal>application.properties</literal></title>
<programlisting language="properties" linenumbering="unnumbered">spring.data.gemfire.cache.log-level=DEBUG
spring.data.gemfire.logging.level=DEBUG</programlisting>
</example>
<example>
<title>Java configuration using SDG&#8217;s <literal>@EnableLogging</literal> annotation</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableLogging(logLevel = "DEBUG")
class MySpringBootApacheGeodeClientApplication {

}</programlisting>
</example>
<simpara>None of the preceding approaches have any effect without the <emphasis role="strong">new</emphasis> SBDG logging starter.</simpara>
<section xml:id="geode-logging-configuration">
<title>Configure Apache Geode Logging</title>
<simpara>So, how do you configure logging for Apache Geode?</simpara>
<simpara>Three things are required to get Apache Geode to log output:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>You must declare a logging provider (such as Logback, or Log4j) on your Spring Boot application classpath.</simpara>
</listitem>
<listitem>
<simpara>(optional) You can declare an adapter (a bridge JAR) between Log4j and your logging provider if your declared
logging provider is not Apache Log4j.</simpara>
<simpara>For example, if you use the SLF4J API to log output from your Spring Boot application and use Logback as your
logging provider or implementation, you must include the <literal>org.apache.logging.log4j.log4j-to-slf4j</literal> adapter or
bridge JAR as well.</simpara>
<simpara>Internally, Apache Geode uses the Apache Log4j API to log output from Geode components. Therefore, you must bridge Log4j
to any other logging provider (such as Logback) that is not Log4j (<literal>log4j-core</literal>). If you use Log4j as your
logging provider, you need not declare an adapter or bridge JAR on your Spring Boot application classpath.</simpara>
</listitem>
<listitem>
<simpara>Finally, you must supply logging provider configuration to configure Loggers, Appenders, log levels, and other details.</simpara>
<simpara>For example, when you use Logback, you must provide a <literal>logback.xml</literal> configuration file on your Spring Boot application
classpath or in the filesystem. Alternatively, you can use other means to configure your logging provider and get
Apache Geode to log output.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Apache Geode&#8217;s <literal>geode-log4j</literal> module covers the required configuration for steps 1-3 above and uses Apache Log4j
(<literal>org.apache.logging.log4j:log4j-core</literal>) as the logging provider. The <literal>geode-log4j</literal> module even provides a default
<literal>log4j2.xml</literal> configuration file to configure Loggers, Appenders, and log levels for Apache Geode.</simpara>
</note>
<simpara>If you declare Spring Boot&#8217;s own <literal>org.springframework.boot:spring-boot-starter-logging</literal> on your application
classpath, it covers steps 1 and 2 above.</simpara>
<simpara>The <literal>spring-boot-starter-logging</literal> dependency declares Logback as the logging provider and automatically adapts (bridges)
<literal>java.util.logging</literal> (JUL) and Apache Log4j to SLF4J. However, you still need to supply logging provider configuration
(such as a <literal>logback.xml</literal> file for Logback) to configure logging not only for your Spring Boot application but for
Apache Geode as well.</simpara>
<note>
<simpara>If no user-specified logging configuration is supplied, Logback will apply default configuration
using the <literal>BasicConfigurator</literal>. See Logback <link xl:href="https://logback.qos.ch/manual/configuration.html#auto_configuration">documentation</link>
for complete details.</simpara>
</note>
<simpara>SBDG has simplified the setup of Apache Geode logging. You need only declare the
<literal>org.springframework.geode:spring-geode-starter-logging</literal> dependency on your Spring Boot application classpath.</simpara>
<simpara>Unlike Apache Geode&#8217;s default Log4j XML configuration file (<literal>log4j2.xml</literal> from <literal>geode-log4j</literal>), SBDG&#8217;s provided
<literal>logback.xml</literal> configuration file is properly parameterized, letting you adjust log levels, add Appenders
as well as adjust other logging settings.</simpara>
<simpara>In addition, SBDG&#8217;s provided Logback configuration uses templates so that you can compose your own logging configuration
while still including snippets from SBDG&#8217;s provided logging configuration, such as Loggers and Appenders.</simpara>
<section xml:id="geode-logging-configuration-log-levels">
<title>Configuring Log Levels</title>
<simpara>One of the most common logging tasks is to adjust the log level of one or more Loggers or the ROOT Logger. However,
you may want to only adjust the log level for specific components of your Spring Boot application, such as for
Apache Geode, by setting the log level for only the Logger that logs Apache Geode events.</simpara>
<simpara>SBDG&#8217;s Logback configuration defines three Loggers to control the log output from Apache Geode:</simpara>
<example>
<title>Apache Geode Loggers by Name</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;comfiguration&gt;
  &lt;logger name="com.gemstone.gemfire" level="${spring.boot.data.gemfire.log.level:-INFO}"/&gt;
  &lt;logger name="org.apache.geode" level="${spring.boot.data.gemfire.log.level:-INFO}"/&gt;
  &lt;logger name="org.jgroups" level="${spring.boot.data.gemfire.jgroups.log.level:-WARN}"/&gt;
&lt;/comfiguration&gt;</programlisting>
</example>
<simpara>The <literal>com.gemstone.gemfire</literal> Logger covers old GemFire components that are still present in Apache Geode for backwards
compatibility. By default, it logs output at <literal>INFO</literal>. This Logger&#8217;s use should be mostly unnecessary.</simpara>
<simpara>The <literal>org.apache.geode</literal> Logger is the primary Logger used to control log output from all Apache Geode components
during the runtime operation of Apache Geode. By default, it logs output at <literal>INFO</literal>.</simpara>
<simpara>The <literal>org.jgroups</literal> Logger is used to log output from Apache Geode&#8217;s message distribution and membership system.
Apache Geode uses JGroups for membership and message distribution between peer members (nodes) in the cluster
(distributed system). By default, JGroups logs output at <literal>WARN</literal>.</simpara>
<simpara>You can configure the log level for the <literal>com.gemstone.gemfire</literal> and <literal>org.apache.geode</literal> Loggers by setting
the <literal>spring.boot.data.gemfire.log.level</literal> property. You can independently configure the <literal>org.jgroups</literal> Logger by setting
the <literal>spring.boot.data.gemfire.jgroups.log.level</literal> property.</simpara>
<simpara>You can set the SBDG logging properties on the command line as JVM System properties when you run
your Spring Boot application:</simpara>
<example>
<title>Setting the log-level from the CLI</title>
<programlisting language="text" linenumbering="unnumbered">$ java -classpath ...:/path/to/MySpringBootApplication.jar -Dspring.boot.data.gemfire.log.level=DEBUG
    package.to.MySpringBootApplicationClass</programlisting>
</example>
<note>
<simpara>Setting JVM System properties by using
<literal>$ java -jar MySpringBootApplication.jar -Dspring.boot.data.gemfire.log.level=DEBUG</literal>
is not supported by the Java Runtime Environment (JRE).</simpara>
</note>
<simpara>Alternatively, you can configure and control Apache Geode logging in Spring Boot <literal>application.properties</literal>:</simpara>
<example>
<title>Setting the log-level in Spring Boot <literal>application.properties</literal></title>
<programlisting language="properties" linenumbering="unnumbered">spring.boot.data.gemfire.log.level=DEBUG</programlisting>
</example>
<simpara>For backwards compatibility, SBDG additionally supports the Spring Data for Apache Geode (SDG) logging properties
as well, by using either of the following properties:</simpara>
<example>
<title>Setting log-level using SDG Properties</title>
<programlisting language="properties" linenumbering="unnumbered">spring.data.gemfire.cache.log-level=DEBUG
spring.data.gemfire.logging.level=DEBUG</programlisting>
</example>
<simpara>If you previously used either of these SDG-based logging properties, they continue to work as designed in SBDG <literal>1.3</literal>
or later.</simpara>
</section>
<section xml:id="geode-logging-configuration-composition">
<title>Composing Logging Configuration</title>
<simpara>As mentioned earlier, SBDG lets you compose your own logging configuration from SBDG&#8217;s default Logback configuration
metadata.</simpara>
<simpara>SBDG conveniently bundles the Properties, Loggers and Appenders from SBDG&#8217;s logging starter into several template files
that you can include into your own custom Logback XML configuration file.</simpara>
<simpara>The Logback configuration template files are broken down into:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>org/springframework/geode/logging/slf4j/logback/properties-include.xml</literal></simpara>
</listitem>
<listitem>
<simpara><literal>org/springframework/geode/logging/slf4j/logback/loggers-include.xml</literal></simpara>
</listitem>
<listitem>
<simpara><literal>org/springframework/geode/logging/slf4j/logback/appenders-include.xml</literal></simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>As of SBDG <literal>3.0</literal>, the <literal>logback-include.xml</literal> file was removed.</simpara>
</warning>
<simpara>The <literal>properties-include.xml</literal> defines Logback "<emphasis>local</emphasis>" scoped properties or variables common to SBDG&#8217;s configuration
of Apache Geode logging.</simpara>
<example>
<title>properties-include.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;included&gt;

	&lt;property name="SPRING_BOOT_LOG_CHARSET" value="${SPRING_BOOT_LOG_CHARSET:-${file.encoding:-UTF-8}}"/&gt;
	&lt;property name="SPRING_BOOT_LOG_PATTERN" value="${SPRING_BOOT_LOG_PATTERN:-%d %5p %40.40c:%4L - %msg%n}"/&gt;
	&lt;property name="APACHE_GEODE_LOG_CHARSET" value="${APACHE_GEODE_LOG_CHARSET:-${file.encoding:-UTF-8}}"/&gt;
	&lt;property name="APACHE_GEODE_LOG_PATTERN" value="${APACHE_GEODE_LOG_PATTERN:-[%level{lowerCase=true} %date{yyyy/MM/dd HH:mm:ss.SSS z} &amp;lt;%thread&amp;gt;] %message%n%throwable%n}"/&gt;

&lt;/included&gt;</programlisting>
</example>
<simpara>The <literal>loggers-include.xml</literal> file defines the <literal>Loggers</literal> used to log output from Apache Geode components.</simpara>
<example>
<title>loggers-include.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;included&gt;

	&lt;logger name="com.gemstone.gemfire" level="${spring.boot.data.gemfire.log.level:-INFO}" additivity="false"&gt;
		&lt;appender-ref ref="${spring.geode.logging.appender-ref:-CONSOLE}"/&gt;
		&lt;appender-ref ref="delegate"/&gt;
	&lt;/logger&gt;

	&lt;logger name="org.apache.geode" level="${spring.boot.data.gemfire.log.level:-INFO}" additivity="false"&gt;
		&lt;appender-ref ref="${spring.geode.logging.appender-ref:-CONSOLE}"/&gt;
		&lt;appender-ref ref="delegate"/&gt;
	&lt;/logger&gt;

	&lt;logger name="org.jgroups" level="${spring.boot.data.gemfire.jgroups.log.level:-WARN}" additivity="false"&gt;
		&lt;appender-ref ref="${spring.geode.logging.appender-ref:-CONSOLE}"/&gt;
		&lt;appender-ref ref="delegate"/&gt;
	&lt;/logger&gt;

&lt;/included&gt;</programlisting>
</example>
<simpara>The <literal>appenders-include.xml</literal> file defines Appenders to send the log output to. If Spring Boot is on the application
classpath, then Spring Boot logging configuration will define the "CONSOLE" <literal>Appender</literal>, otherwise, SBDG will provide
a default definition.</simpara>
<simpara>The "geode" <literal>Appender</literal> defines the Apache Geode logging pattern as seen in Apache Geode&#8217;s Log4j configuration.</simpara>
<example>
<title>appenders-include.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;included&gt;

	&lt;if condition='property("bootPresent").equals("false")'&gt;
		&lt;then&gt;
			&lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt;
				&lt;encoder&gt;
					&lt;charset&gt;${SPRING_BOOT_LOG_CHARSET}&lt;/charset&gt;
					&lt;pattern&gt;${SPRING_BOOT_LOG_PATTERN}&lt;/pattern&gt;
				&lt;/encoder&gt;
			&lt;/appender&gt;
		&lt;/then&gt;
	&lt;/if&gt;

	&lt;appender name="delegate" class="org.springframework.geode.logging.slf4j.logback.DelegatingAppender"/&gt;

	&lt;appender name="geode" class="ch.qos.logback.core.ConsoleAppender"&gt;
		&lt;encoder&gt;
			&lt;charset&gt;${APACHE_GEODE_LOG_CHARSET}&lt;/charset&gt;
			&lt;pattern&gt;${APACHE_GEODE_LOG_PATTERN}&lt;/pattern&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;

&lt;/included&gt;</programlisting>
</example>
<simpara>Then you can include any of SBDG&#8217;S Logback configuration metadata files as needed in your application-specific
Logback XML configuration file, as follows:</simpara>
<example>
<title>application-specific logback.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration&gt;

	&lt;include resource="org/springframework/geode/logging/slf4j/logback/properties-include.xml"/&gt;
	&lt;include resource="org/springframework/geode/logging/slf4j/logback/appender-include.xml"/&gt;

	&lt;logger name="org.apache.geode" level="INFO" additivity="false"&gt;
		&lt;appender-ref ref="geode"/&gt;
	&lt;/logger&gt;

	&lt;root level="${logback.root.log.level:-INFO}"&gt;
		&lt;appender-ref ref="CONSOLE"/&gt;
		&lt;appender-ref ref="delegate"/&gt;
	&lt;/root&gt;

&lt;/configuration&gt;</programlisting>
</example>
</section>
<section xml:id="geode-logging-configuration-customizing">
<title>Customizing Logging Configuration</title>
<simpara>It is now possible to customize the configuration of Apache Geode logging using properties defined in
a <literal>spring-geode-logging.properties</literal> file included on the Spring Boot application classpath.</simpara>
<simpara>Any of the properties defined in <literal>org/springframework/geode/logging/slf4j/logback/properties-include.xml</literal> (shown above),
such as <literal>APACHE_GEODE_LOG_PATTERN</literal>, or the <literal>spring.geode.logging.appender-ref</literal> property, can be set.</simpara>
<simpara>For instance, and by default, Apache Geode components log output using the Spring Boot log pattern. However, if you
prefer the fine-grained details of Apache Geode&#8217;s logging behavior, you can change the <literal>Appender</literal> used by
the Apache Geode <literal>Logger&#8217;s</literal> to use the pre-defined "geode" <literal>Appender</literal> instead. Simply set
the <literal>spring-geode.logging.appender-ref</literal> property to "geode" in a <literal>spring-geode-logging.properties</literal> file
on your Spring Boot application classpath, as follows:</simpara>
<example>
<title>spring-geode-logging.properties</title>
<programlisting language="properties" linenumbering="unnumbered"># spring-geode-logging.properties
spring.geode.logging.appender-ref=geode</programlisting>
</example>
<simpara>Alternatively, if you want to configure the log output of your entire Spring Boot application, including log output
from all Apache Geode components, then you can set the <literal>SPRING_BOOT_LOG_PATTERN</literal> property, or Spring Boot&#8217;s
<literal>CONSOLE_LOG_PATTERN</literal> property, in <literal>spring-geode-logging.properties</literal>, as follows:</simpara>
<example>
<title>spring-geode-logging.properties</title>
<programlisting language="properties" linenumbering="unnumbered"># spring-geode-logging.properties
CONSOLE_LOG_PATTERN=TEST - %msg%n</programlisting>
</example>
<note>
<simpara>The <literal>spring-geode-logging.properties</literal> file is only recognized when the <literal>spring-geode-starter-logging</literal> module
is used.</simpara>
</note>
</section>
</section>
<section xml:id="geode-logging-slf4j-logback-api-support">
<title>SLF4J and Logback API Support</title>
<simpara>SBDG provides additional support when working with the SLF4J and Logback APIs. This support is available when you
declare the <literal>org.springframework.geode:spring-geode-starter-logging</literal> dependency on your Spring Boot application
classpath.</simpara>
<simpara>One of the main supporting classes from the <literal>spring-geode-starter-logger</literal>
is the <literal>org.springframework.geode.logging.slf4j.logback.LogbackSupport</literal> class. This class provides methods to:</simpara>
<itemizedlist>
<listitem>
<simpara>Resolve a reference to the Logback <literal>LoggingContext</literal>.</simpara>
</listitem>
<listitem>
<simpara>Resolve the SLF4J ROOT <literal>Logger</literal> as a Logback <literal>Logger</literal>.</simpara>
</listitem>
<listitem>
<simpara>Look up <literal>Appenders</literal> by name and required type.</simpara>
</listitem>
<listitem>
<simpara>Add or remove <literal>Appenders</literal> to <literal>Loggers</literal>.</simpara>
</listitem>
<listitem>
<simpara>Reset the state of the Logback logging system, which can prove to be most useful during testing.</simpara>
</listitem>
</itemizedlist>
<simpara><literal>LogbackSupport</literal> can even suppress the auto-configuration of Logback performed by Spring Boot on startup, which is
another useful utility during automated testing.</simpara>
<simpara>In addition to the <literal>LogbackSupport</literal> class, SBDG also provides some custom Logback <literal>Appenders</literal>.</simpara>
<section xml:id="geode-logging-slf4j-logback-api-support-appender-composite">
<title>CompositeAppender</title>
<simpara>The <literal>org.springframework.geode.logging.slf4j.logback.CompositeAppender</literal> class is an implementation of the Logback
<literal>Appender</literal> interface and the <link xl:href="https://en.wikipedia.org/wiki/Composite_pattern">Composite software design pattern</link>.</simpara>
<simpara><literal>CompositeAppender</literal> lets developers compose multiple Appenders and use them as if they were a single <literal>Appender</literal>.</simpara>
<simpara>For example, you could compose both the Logback <literal>ConsoleAppender</literal> and <literal>FileAppender</literal> into one <literal>Appender</literal>:</simpara>
<example>
<title>Composing multiple <literal>Appenders</literal></title>
<programlisting language="java" linenumbering="unnumbered">class LoggingConfiguration {

  Appender&lt;ILoggingEvent&gt; compositeAppender() {

    ConsoleAppender&lt;ILoggingEvent&gt; consoleAppender = new ConsoleAppender&lt;&gt;();

    FileAppender&lt;ILoggingEvent&gt; fileAppender = new FileApender&lt;&gt;();

    Appender&lt;ILoggingEvent&gt; compositeAppender = CompositeAppender.compose(consoleAppender, fileAppender);

    return compositeAppender;
  }
}

// do something with the compositeAppender</programlisting>
</example>
<simpara>You could then add the <literal>CompositeAppender</literal> to a named <literal>Logger</literal>:</simpara>
<example>
<title>Register <literal>CompositeAppender</literal> on "named" <literal>Logger</literal></title>
<programlisting language="java" linenumbering="unnumbered">class LoggerConfiguration {

  void registerAppenderOnLogger() {

    Logger namedLogger = LoggerFactory.getLogger("loggerName");

    LogbackSupport.toLogbackLogger(namedLogger)
      .ifPresent(it -&gt; LogbackSupport.addAppender(it, compositeAppender));
  }
}</programlisting>
</example>
<simpara>In this case, the named <literal>Logger</literal> logs events (or log messages) to both the console and file Appenders.</simpara>
<simpara>You can compose an array or <literal>Iterable</literal> of <literal>Appenders</literal> by using either the
<literal>CompositeAppender.compose(:Appender&lt;T&gt;[])</literal> method or the <literal>CompositeAppender.compose(:Iterable&lt;Appender&lt;T&gt;&gt;)</literal> method.</simpara>
</section>
<section xml:id="geode-logging-slf4j-logback-api-support-appender-delegate">
<title>DelegatingAppender</title>
<simpara>The <literal>org.springframework.geode.logging.slf4j.logback.DelegatingAppender</literal> is a pass-through Logback <literal>Appender</literal>
implementation that wraps another Logback <literal>Appender</literal> or collection of <literal>Appenders</literal>, such as the <literal>ConsoleAppender</literal>,
a <literal>FileAppender</literal>, a <literal>SocketAppender</literal>, or others. By default, the <literal>DelegatingAppender</literal> delegates to the <literal>NOPAppender</literal>,
thereby doing no actual work.</simpara>
<simpara>By default, SBDG registers the <literal>org.springframework.geode.logging.slfj4.logback.DelegatingAppender</literal> with the ROOT
<literal>Logger</literal>, which can be useful for testing purposes.</simpara>
<simpara>With a reference to a <literal>DelegatingAppender</literal>, you can add any <literal>Appender</literal> (even a <literal>CompositeAppender</literal>) as the delegate:</simpara>
<example>
<title>Add <literal>ConsoleAppender</literal> as the "delegate" for the <literal>DelegatingAppender</literal></title>
<programlisting language="java" linenumbering="unnumbered">class LoggerConfiguration {

  void setupDelegation() {

    ConsoleAppender consoleAppender = new ConsoleAppender();

    LogbackSupport.resolveLoggerContext().ifPresent(consoleAppender::setContext);

    consoleAppender.setImmediateFlush(true);
    consoleAppender.start();

    LogbackSupport.resolveRootLogger()
      .flatMap(LogbackSupport::toLogbackLogger)
      .flatMap(rootLogger -&gt; LogbackSupport.resolveAppender(rootLogger,
        LogbackSupport.DELEGATE_APPENDER_NAME, DelegatingAppender.class))
      .ifPresent(delegateAppender -&gt; delegateAppender.setAppender(consoleAppender));
  }
}</programlisting>
</example>
</section>
<section xml:id="geode-logging-slf4j-logback-api-support-appender-string">
<title>StringAppender</title>
<simpara>The <literal>org.springframework.geode.logging.slf4j.logback.StringAppender</literal> stores a log message in-memory, appended to
a <literal>String</literal>.</simpara>
<simpara>The <literal>StringAppender</literal> is useful for testing purposes. For instance, you can use the <literal>StringAppender</literal> to assert that
a <literal>Logger</literal> used by certain application components logged messages at the appropriately configured log level
while other log messages were not logged.</simpara>
<simpara>Consider the following example:</simpara>
<example>
<title><literal>StringAppender</literal> in Action</title>
<programlisting language="java" linenumbering="unnumbered">class ApplicationComponent {

	private final Logger logger = LoggerFactory.getLogger(getClass());

	public void someMethod() {
		logger.debug("Some debug message");
		// ...
	}

	public void someOtherMethod() {
		logger.info("Some info message");
	}
}

// Assuming the ApplicationComponent Logger was configured with log-level 'INFO', then...
class ApplicationComponentUnitTests {

	private final ApplicationComponent applicationComponent = new ApplicationComponent();

	private final Logger logger = LoggerFactory.getLogger(ApplicationComponent.class);

	private StringAppender stringAppender;

	@Before
    public void setup() {

        LogbackSupport.toLogbackLogger(logger)
            .map(Logger::getLevel)
            .ifPresent(level -&gt; assertThat(level).isEqualTo(Level.INFO));

        stringAppender = new StringAppender.Builder()
            .applyTo(logger)
            .build();
    }

    @Test
    public void someMethodDoesNotLogDebugMessage() {

        applicationComponent.someMethod();

        assertThat(stringAppender.getLogOutput).doesNotContain("Some debug message");
    }

    @Test
    public void someOtherMethodLogsInfoMessage() {

        applicationComponent.someOtherMethod();

        assertThat(stringAppender.getLogOutput()).contains("Some info message");
    }
}</programlisting>
</example>
<simpara>There are many other uses for the <literal>StringAppender</literal> and you can use it safely in a multi-Threaded context by calling
<literal>StringAppender.Builder.useSynchronization()</literal>.</simpara>
<simpara>When combined with other SBDG provided <literal>Appenders</literal> in conjunction with the <literal>LogbackSupport</literal> class, you have a lot of
power both in application code as well as in your tests.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="geode-security">
<title>Security</title>
<simpara>This chapter covers security configuration for Apache Geode, which includes both authentication and authorization
(collectively, auth) as well as Transport Layer Security (TLS) using SSL.</simpara>
<note>
<simpara>Securing data at rest is not supported by Apache Geode.</simpara>
</note>
<tip>
<simpara>See the corresponding sample <link xl:href="guides/boot-security.html">guide</link> and {github-samples-url}/boot/security[code]
to see Spring Boot Security for Apache Geode in action.</simpara>
</tip>
<section xml:id="geode-security-auth">
<title>Authentication and Authorization</title>
<simpara>Apache Geode employs username- and password-based <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/managing/security/authentication_overview.html">authentication</link>
and role-based <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/managing/security/authorization_overview.html">authorization</link> to secure your client to
server data exchanges and operations.</simpara>
<simpara>Spring Data for Apache Geode provides <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-security">first-class support</link>
for Apache Geode&#8217;s Security framework, which is based on the
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/security/SecurityManager.html"><literal>SecurityManager</literal></link> interface.
Additionally, Apache Geode&#8217;s Security framework is integrated with <link xl:href="https://shiro.apache.org/">Apache Shiro</link>.</simpara>
<note>
<simpara>SBDG will eventually provide support for and integration with
<link xl:href="https://spring.io/projects/spring-security">Spring Security</link>.</simpara>
</note>
<simpara>When you use Spring Boot for Apache Geode, which builds Spring Data for Apache Geode, it makes short work of
enabling auth in both your clients and servers.</simpara>
<section xml:id="geode-security-auth-servers">
<title>Auth for Servers</title>
<simpara>The easiest and most standard way to enable auth in the servers of your cluster is to simply define one or more
Apache Shiro <link xl:href="https://shiro.apache.org/realm.html">Realms</link> as beans in the Spring <literal>ApplicationContext</literal>.</simpara>
<simpara>Consider the following example:</simpara>
<example>
<title>Declaring an Apache Shiro Realm</title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
class ApacheGeodeSecurityConfiguration {

    @Bean
    DefaultLdapRealm ldapRealm() {
        return new DefaultLdapRealm();
    }

    // ...
}</programlisting>
</example>
<simpara>When an Apache Shiro Realm (such as <literal>DefaultLdapRealm</literal>) is declared and registered in the Spring <literal>ApplicationContext</literal>
as a Spring bean, Spring Boot automatically detects this <literal>Realm</literal> bean (or <literal>Realm</literal> beans if more than one is configured),
and the servers in the Apache Geode cluster are automatically configured with authentication and authorization enabled.</simpara>
<simpara>Alternatively, you can provide a custom, application-specific implementation of Apache Geode&#8217;s
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/security/SecurityManager.html"><literal>SecurityManager</literal></link> interface,
declared and registered as a bean in the Spring <literal>ApplicationContext</literal>:</simpara>
<example>
<title>Declaring a custom Apache Geode <literal>SecurityManager</literal></title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
class ApacheGeodeSecurityConfiguration {

    @Bean
    CustomSecurityManager customSecurityManager() {
        return new CustomSecurityManager();
    }

    // ...
}</programlisting>
</example>
<simpara>Spring Boot discovers your custom, application-specific <literal>SecurityManager</literal> implementation and configures the servers
in the Apache Geode cluster with authentication and authorization enabled.</simpara>
<tip>
<simpara>The Spring team recommends that you use Apache Shiro to manage the authentication and authorization of your
servers over implementing Apache Geode&#8217;s <literal>SecurityManager</literal> interface.</simpara>
</tip>
</section>
<section xml:id="geode-security-auth-clients">
<title>Auth for Clients</title>
<simpara>When servers in an Apache Geode cluster have been configured with authentication and authorization enabled, clients
must authenticate when connecting.</simpara>
<simpara>Spring Boot for Apache Geode makes this easy, regardless of whether you run your Spring Boot <literal>ClientCache</literal> applications
in a local, non-managed environment or run in a cloud-managed environment.</simpara>
<section xml:id="geode-security-auth-clients-non-managed">
<title>Non-Managed Auth for Clients</title>
<simpara>To enable auth for clients that connect to a secure Apache Geode cluster, you need only set a username and password
in Spring Boot <literal>application.properties</literal>:</simpara>
<example>
<title>Spring Boot <literal>application.properties</literal> for the client</title>
<programlisting language="txt" linenumbering="unnumbered"># Spring Boot client application.properties

spring.data.gemfire.security.username = jdoe
spring.data.gemfire.security.password = p@55w0rd</programlisting>
</example>
<simpara>Spring Boot for Apache Geode handles the rest.</simpara>
</section>
<section xml:id="geode-secuirty-auth-clients-managed">
<title>Managed Auth for Clients</title>
<simpara>Enabling auth for clients that connect to a VMware Tanzu GemFire for VMs service instance (PCC)
in VMware Tanzu Application Service (TAS) (PCF) is even easier: You need do nothing.</simpara>
<simpara>If your Spring Boot application uses SBDG and is bound to PCC, when you deploy (that is, <literal>cf push</literal>) your application
to PCF, Spring Boot for Apache Geode extracts the required auth credentials from the environment that you set up when
you provisioned a PCC service instance in your PCF organization and space. PCC automatically assigns two users with
roles of <literal>cluster_operator</literal> and <literal>developer</literal>, respectively, to any Spring Boot application bound to the PCC service
instance.</simpara>
<simpara>By default, SBDG auto-configures your Spring Boot application to run with the user that has the <literal>cluster_operator</literal> role.
This ensures that your Spring Boot application has the necessary permission (authorization) to perform all data access
operations on the servers in the PCC cluster, including, for example, pushing configuration metadata from the client
to the servers in the PCC cluster.</simpara>
<simpara>See the <link linkend="cloudfoundry-cloudcache-security-auth-runtime-user-configuration">Running Spring Boot applications as a specific user</link> section
in the <link linkend="cloudfoundry">Pivotal CloudFoundry</link> chapter for additional details on user authentication and authorization.</simpara>
<simpara>See the <link linkend="cloudfoundry">chapter</link> (titled <quote>Pivotal CloudFoundry</quote>) for more general details.</simpara>
<simpara>See the <link xl:href="https://docs.pivotal.io/p-cloud-cache/{pivotal-cloudcache-doc-version}/security.html">Pivotal Cloud Cache documentation</link> for security details
when you use PCC and PCF.</simpara>
</section>
</section>
</section>
<section xml:id="geode-security-ssl">
<title>Transport Layer Security using SSL</title>
<simpara>Securing data in motion is also essential to the integrity of your Spring [Boot] applications.</simpara>
<simpara>For instance, it would not do much good to send usernames and passwords over plain text socket connections
between your clients and servers nor to send other sensitive data over those same connections.</simpara>
<simpara>Therefore, Apache Geode supports SSL between clients and servers, between JMX clients (such as Gfsh) and the Manager,
between HTTP clients when you use the Developer REST API or Pulse, between peers in the cluster, and when you use
the WAN Gateway to connect multiple sites (clusters).</simpara>
<simpara>Spring Data for Apache Geode provides
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-ssl">first-class support</link>
for configuring and enabling SSL as well. Still, Spring Boot makes it even easier to configure and enable SSL,
especially during development.</simpara>
<simpara>Apache Geode requires certain properties to be configured. These properties translate to the appropriate
<literal>javax.net.ssl.*</literal> properties required by the JRE to create secure socket connections by using
<link xl:href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html">JSSE</link>.</simpara>
<simpara>However, ensuring that you have set all the required SSL properties correctly is an error prone and tedious task.
Therefore, Spring Boot for Apache Geode applies some basic conventions for you.</simpara>
<simpara>You can create a <literal>trusted.keystore</literal> as a JKS-based <literal>KeyStore</literal> file and place it in one of three well-known locations:</simpara>
<itemizedlist>
<listitem>
<simpara>In your application JAR file at the root of the classpath.</simpara>
</listitem>
<listitem>
<simpara>In your Spring Boot application&#8217;s working directory.</simpara>
</listitem>
<listitem>
<simpara>In your user home directory (as defined by the <literal>user.home</literal> Java System property).</simpara>
</listitem>
</itemizedlist>
<simpara>When this file is named <literal>trusted.keystore</literal> and is placed in one of these three well-known locations, Spring Boot
for Apache Geode automatically configures your client to use SSL socket connections.</simpara>
<simpara>If you use Spring Boot to configure and bootstrap an Apache Geode server:</simpara>
<example>
<title>Spring Boot configured and bootstrapped Apache Geode server</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@CacheServerApplication
class SpringBootApacheGeodeCacheServerApplication {
    // ...
}</programlisting>
</example>
<simpara>Then Spring Boot also applies the same procedure to enable SSL on the servers (between peers).</simpara>
<tip>
<simpara>During development, it is convenient to <emphasis role="strong">not</emphasis> set a <literal>trusted.keystore</literal> password when accessing the keys in the JKS
file. However, it is highly recommended that you secure the <literal>trusted.keystore</literal> file when deploying your application to
a production environment.</simpara>
</tip>
<simpara>If your <literal>trusted.keystore</literal> file is secured with a password, you need to additionally specify the following property:</simpara>
<example>
<title>Accessing a secure <literal>trusted.keystore</literal></title>
<programlisting language="txt" linenumbering="unnumbered"># Spring Boot application.properties

spring.data.gemfire.security.ssl.keystore.password=p@55w0rd!</programlisting>
</example>
<simpara>You can also configure the location of the keystore and truststore files, if they are separate and have not been placed
in one of the default, well-known locations searched by Spring Boot:</simpara>
<example>
<title>Accessing a secure <literal>trusted.keystore</literal> by location</title>
<programlisting language="txt" linenumbering="unnumbered"># Spring Boot application.properties

spring.data.gemfire.security.ssl.keystore = /absolute/file/system/path/to/keystore.jks
spring.data.gemfire.security.ssl.keystore.password = keystorePassword
spring.data.gemfire.security.ssl.truststore = /absolute/file/system/path/to/truststore.jks
spring.data.gemfire.security.ssl.truststore.password = truststorePassword</programlisting>
</example>
<simpara>See the SDG <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html"><literal>EnableSsl</literal></link>
annotation for all the configuration attributes and the corresponding properties expressed in <literal>application.properties</literal>.</simpara>
</section>
<section xml:id="geode-security-encryption">
<title>Securing Data at Rest</title>
<simpara>Currently, neither Apache Geode nor Spring Boot nor Spring Data for Apache Geode offer any support for securing your
data while at rest (for example, when your data has been overflowed or persisted to disk).</simpara>
<simpara>To secure data at rest when using Apache Geode, with or without Spring, you must employ third-party solutions, such as
disk encryption, which is usually highly contextual and technology-specific.</simpara>
<simpara>For example, to secure data at rest when you use Amazon EC2, see
<link xl:href="https://aws.amazon.com/blogs/security/how-to-protect-data-at-rest-with-amazon-ec2-instance-store-encryption/">Instance Store Encryption</link>.</simpara>
</section>
</chapter>
<chapter xml:id="geode-testing">
<title>Testing</title>
<simpara>Spring Boot for Apache Geode (SBDG), with help from <link xl:href="https://github.com/spring-projects/spring-test-data-geode">Spring Test for Apache Geode (STDG)</link>, offers
first-class support for both unit and integration testing with Apache Geode in your Spring Boot applications.</simpara>
<tip>
<simpara>See the Spring Test for Apache Geode (STDG) <link xl:href="https://github.com/spring-projects/spring-test-data-geode/#stdg-in-a-nutshell">documentation</link> for more details.</simpara>
</tip>
<section xml:id="geode-testing-unit">
<title>Unit Testing</title>
<simpara>Unit testing with Apache Geode using mock objects in a Spring Boot Test requires only that you declare the STDG
<literal>@EnableGemFireMockObjects</literal> annotation in your test configuration:</simpara>
<example>
<title>Unit Test with Apache Geode using Spring Boot</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootTest
@RunWith(SpringRunner.class)
public class SpringBootApacheGeodeUnitTest extends IntegrationTestsSupport {

	@Autowired
	private UserRepository userRepository;

	@Test
	public void saveAndFindUserIsSuccessful() {

		User jonDoe = User.as("jonDoe");

		assertThat(this.userRepository.save(jonDoe)).isNotNull();

		User jonDoeFoundById = this.userRepository.findById(jonDoe.getName()).orElse(null);

		assertThat(jonDoeFoundById).isEqualTo(jonDoe);
	}

	@SpringBootApplication
	@EnableGemFireMockObjects
	@EnableEntityDefinedRegions(basePackageClasses = User.class)
	static class TestConfiguration { }

}

@Getter
@ToString
@EqualsAndHashCode
@RequiredArgsConstructor(staticName = "as")
@Region("Users")
class User {

	@Id
	@lombok.NonNull
	private String name;

}

interface UserRepository extends CrudRepository&lt;User, String&gt; { }</programlisting>
</example>
<simpara>This test class is not a <quote>pure</quote> unit test, particularly since it bootstraps an actual Spring <literal>ApplicationContext</literal>
using Spring Boot. However, it does mock all Apache Geode objects, such as the <literal>Users</literal> <literal>Region</literal> declared by the <literal>User</literal>
application entity class, which was annotated with SDG&#8217;s <literal>@Region</literal> mapping annotation.</simpara>
<simpara>This test class conveniently uses Spring Boot&#8217;s auto-configuration to auto-configure an Apache Geode <literal>ClientCache</literal>
instance. In addition, SDG&#8217;s <literal>@EnableEntityDefinedRegions</literal> annotation was used to conveniently create the Apache Geode
"Users` <literal>Region</literal> to store instances of <literal>User</literal>.</simpara>
<simpara>Finally, Spring Data&#8217;s Repository abstraction was used to conveniently perform basic CRUD (such as <literal>save</literal>)  and simple
(OQL) query (such as <literal>findById</literal>) data access operations on the <literal>Users</literal> <literal>Region</literal>.</simpara>
<simpara>Even though the Apache Geode objects (such as the <literal>Users</literal> <literal>Region</literal>) are <quote>mock objects</quote>, you can still perform many of
the data access operations required by your Spring Boot application&#8217;s components in an Apache Geode API-agnostic way&#8201;&#8212;&#8201;that is, by using Spring&#8217;s powerful programming model and constructs.</simpara>
<tip>
<simpara>By extending STDG&#8217;s <literal>org.springframework.data.gemfire.tests.integration.IntegrationTestSupport</literal> class, you ensure
that all Apache Geode mock objects and resources are properly released after the test class runs, thereby preventing
any interference with downstream tests.</simpara>
</tip>
<simpara>While STDG tries to <link xl:href="https://github.com/spring-projects/spring-test-data-geode/#mock-regions-with-data">mock the functionality and behavior</link> for many <literal>Region</literal>
operations, it is not pragmatic to mock them all. For example, it would not be practical to mock <literal>Region</literal> query
operations involving complex OQL statements that have sophisticated predicates.</simpara>
<simpara>If such functional testing is required, the test might be better suited as an integration test. Alternatively, you can
follow the advice in this section about <link xl:href="https://github.com/spring-projects/spring-test-data-geode/#mocking-unsupported-region-operations">unsupported Region operations</link>.</simpara>
<simpara>In general, STDG provides the following capabilities when mocking Apache Geode objects:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/spring-projects/spring-test-data-geode#mock-object-scope&#8212;&#8203;lifecycle-management">Mock Object Scope &amp; Lifecycle Management</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/spring-projects/spring-test-data-geode#mock-regions-with-data">Support for Mock Regions with Data</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/spring-projects/spring-test-data-geode#mock-region-callbacks">Support for Mocking Region Callbacks</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/spring-projects/spring-test-data-geode#mocking-unsupported-region-operations">Support for Mocking Unsupported Region Operations</link></simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>See the documentation on <link xl:href="https://github.com/spring-projects/spring-test-data-geode/#unit-testing-with-stdg">Unit Testing with STDG</link> for more details.</simpara>
</tip>
</section>
<section xml:id="geode-testing-integration">
<title>Integration Testing</title>
<simpara>Integration testing with Apache Geode in a Spring Boot Test is as simple as <emphasis role="strong">not</emphasis> declaring STDG&#8217;s
<literal>@EnableGemFireMockObjects</literal> annotation in your test configuration. You may then want to use SBDG&#8217;s <literal>@EnableClusterAware</literal>
annotation to conditionally detect the presence of a Apache Geode cluster:</simpara>
<example>
<title>Using <literal>@EnableClusterAware</literal> in test configuration</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableClusterAware
@EnableEntityDefinedRegions(basePackageClasses = User.class)
static class TestConfiguration { }</programlisting>
</example>
<simpara>The SBDG <literal>@EnableClusterAware</literal> annotation conveniently toggles your auto-configured <literal>ClientCache</literal> instance between
local-only mode and client/server. It even pushes configuration metadata (such as <literal>Region</literal> definitions) up to
the servers in the cluster that are required by the application to store data.</simpara>
<simpara>In most cases, in addition to testing with <quote>live</quote> Apache Geode objects (such as Regions), we also want to test in
a client/server capacity. This unlocks the full capabilities of the Apache Geode data management system in a Spring
context and gets you as close as possible to production from the comfort of your IDE.</simpara>
<simpara>Building on our example from the section on <xref linkend="geode-testing-unit"/>, you can modify the test to use <quote>live</quote> Apache Geode
objects in a client/server topology as follows:</simpara>
<example>
<title>Integration Test with Apache Geode using Spring Boot</title>
<programlisting language="java" linenumbering="unnumbered">@ActiveProfiles("client")
@RunWith(SpringRunner.class)
@SpringBootTest(properties = "spring.data.gemfire.management.use-http=false")
public class SpringBootApacheGeodeIntegrationTest extends ForkingClientServerIntegrationTestsSupport {

	@BeforeClass
	public static void startGeodeServer() throws IOException {
		startGemFireServer(TestGeodeServerConfiguration.class);
	}

	@Autowired
	private UserRepository userRepository;

	@Test
	public void saveAndFindUserIsSuccessful() {

		User jonDoe = User.as("jonDoe");

		assertThat(this.userRepository.save(jonDoe)).isNotNull();

		User jonDoeFoundById = this.userRepository.findById(jonDoe.getName()).orElse(null);

		assertThat(jonDoeFoundById).isEqualTo(jonDoe);
		assertThat(jonDoeFoundById).isNotSameAs(jonDoe);
	}

	@SpringBootApplication
	@EnableClusterAware
	@EnableEntityDefinedRegions(basePackageClasses = User.class)
	@Profile("client")
	static class TestGeodeClientConfiguration { }

	@CacheServerApplication
	@Profile("server")
	static class TestGeodeServerConfiguration {

		public static void main(String[] args) {

			new SpringApplicationBuilder(TestGeodeServerConfiguration.class)
				.web(WebApplicationType.NONE)
				.profiles("server")
				.build()
				.run(args);
		}
	}
}

@Getter
@ToString
@EqualsAndHashCode
@RequiredArgsConstructor(staticName = "as")
@Region("Users")
class User {

	@Id
	@lombok.NonNull
	private String name;

}

interface UserRepository extends CrudRepository&lt;User, String&gt; { }</programlisting>
</example>
<simpara>The application client/server-based integration test class extend STDG&#8217;s
<literal>org.springframework.data.gemfire.tests.integration.ForkingClientServerIntegrationTestsSupport</literal> class.
This ensures that all Apache Geode objects and resources are properly cleaned up after the test class runs. In addition,
it coordinates the client and server components of the test (for example connecting the client to the server using a
random port).</simpara>
<simpara>The Apache Geode server is started in a <literal>@BeforeClass</literal> setup method:</simpara>
<formalpara>
<title>Start the Apache Geode server</title>
<para>
<programlisting language="java" linenumbering="unnumbered">class SpringBootApacheGeodeIntegrationTest extends ForkingClientServerIntegrationTestsSupport {

  @BeforeClass
  public static void startGeodeServer() throws IOException {
    startGemFireServer(TestGeodeServerConfiguration.class);
  }
}</programlisting>
</para>
</formalpara>
<simpara>STDG lets you configure the Apache Geode server with Spring configuration, specified in
the <literal>TestGeodeServerConfiguration</literal> class. The Java class needs to provide a <literal>main</literal> method. It uses
the <literal>SpringApplicationBuilder</literal> to bootstrap the Apache Geode <literal>CacheServer</literal> application:</simpara>
<example>
<title>Apache Geode server configuration</title>
<programlisting language="java" linenumbering="unnumbered">@CacheServerApplication
@Profile("server")
static class TestGeodeServerConfiguration {

  public static void main(String[] args) {

    new SpringApplicationBuilder(TestGeodeServerConfiguration.class)
      .web(WebApplicationType.NONE)
      .profiles("server")
      .build()
      .run(args);
  }
}</programlisting>
</example>
<simpara>In this case, we provide minimal configuration, since the configuration is determined and pushed up to the server
by the client. For example, we do not need to explicitly create the <literal>Users</literal> <literal>Region</literal> on the server since it is
implicitly handled for you by the SBDG/STDG frameworks from the client.</simpara>
<simpara>We take advantage of Spring profiles in the test setup to distinguish between the client and server configuration.
Keep in mind that the test is the <quote>client</quote> in this arrangement.</simpara>
<simpara>The STDG framework does what the supporting class demands: <quote>forking</quote> the Spring Boot-based, Apache Geode <literal>CacheServer</literal>
application in a separate JVM process. Subsequently, the STDG framework stops the server upon completion of the tests
in the test class.</simpara>
<simpara>You are free to start your servers or cluster however you choose. STDG provides this capability as a convenience for you,
since it is a common concern.</simpara>
<simpara>This test class is simple. STDG can handle much more complex test scenarios.</simpara>
<tip>
<simpara>Review SBDG&#8217;s test suite to witness the full power and functionality of the STDG framework for yourself.</simpara>
</tip>
<note>
<simpara>See the documentation on <link xl:href="https://github.com/spring-projects/spring-test-data-geode/#integration-testing-with-stdg">Integration Testing with STDG</link>
for more details.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="geode-api-extensions">
<title>Apache Geode API Extensions</title>
<simpara>When using the Spring programming model and abstractions, it should not be necessary to use Apache Geode
<link xl:href="https://geode.apache.org/releases/latest/javadoc">APIs</link> at all&#8201;&#8212;&#8201;for example, when using the Spring Cache Abstraction for caching
or the Spring Data Repository abstraction for DAO development. There are many more examples.</simpara>
<simpara>For certain use cases, users may require low level access to fine-grained functionally. Spring Boot for Apache Geode&#8217;s
<literal>org.springframework.geode:apache-geode-extensions</literal> module and library builds on Apache Geode&#8217;s APIs by including
several extensions with enhanced functionality to offer an experience familiar to Spring users inside a Spring context.</simpara>
<tip>
<simpara>Spring Data for Apache Geode (SDG) also <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#apis">includes</link> additional extensions to
Apache Geode&#8217;s APIs.</simpara>
</tip>
<section xml:id="geode-api-extensions-cacheresolver">
<title><literal>SimpleCacheResolver</literal></title>
<simpara>In some cases, it is necessary to acquire a reference to the cache instance in your application components at runtime.
For example, you might want to create a temporary <literal>Region</literal> on the fly to aggregate data for analysis.</simpara>
<simpara>Typically, you already know the type of cache your application is using, since you must declare your application to be
either a client (<literal>ClientCache</literal>) in the <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/topologies_and_comm/cs_configuration/chapter_overview.html">client/server topology</link>,
or a <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/topologies_and_comm/p2p_configuration/chapter_overview.html">peer member or node</link> (<literal>Cache</literal>) in
the cluster on startup. This is expressed in configuration when creating the cache instance required to interact with
the Apache Geode data management system. In most cases, your application will be a client. SBDG makes this decision easy,
since it auto-configures a <literal>ClientCache</literal> instance, <link linkend="geode-clientcache-applications">by default</link>.</simpara>
<simpara>In a Spring context, the cache instance created by the framework is a managed bean in the Spring container.
You can inject a reference to the <link xl:href="https://en.wikipedia.org/wiki/Singleton_pattern"><emphasis>Singleton</emphasis></link> cache bean
into any other managed application component:</simpara>
<example>
<title>Autowired Cache Reference using Dependency Injection (DI)</title>
<programlisting language="java" linenumbering="unnumbered">@Service
class CacheMonitoringService {

	@Autowired
    ClientCache clientCache;

    // use the clientCache object reference to monitor the cache as necessary

}</programlisting>
</example>
<simpara>However, in cases where your application component or class is not managed by Spring and you need a reference to the
cache instance at runtime, SBDG provides the abstract <literal>org.springframework.geode.cache.SimpleCacheResolver</literal> class
(see its <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/cache/SimpleCacheResolver.html">Javadoc</link>).</simpara>
<example>
<title><literal>SimpleCacheResolver</literal> API</title>
<programlisting language="java" linenumbering="unnumbered">package org.springframework.geode.cache;

abstract class SimpleCacheResolver {

	&lt;T extends GemFireCache&gt; T require() { }

	&lt;T extends GemFireCache&gt; Optional&lt;T&gt; resolve() { }

	Optional&lt;ClientCache&gt; resolveClientCache() { }

	Optional&lt;Cache&gt; resolvePeerCache() { }

}</programlisting>
</example>
<simpara><literal>SimpleCacheResolver</literal> adheres to <link xl:href="https://en.wikipedia.org/wiki/SOLID">SOLID OO Principles</link>. This class is abstract
and extensible so that you can change the algorithm used to resolve client or peer cache instances as well as mock
its methods in unit tests.</simpara>
<simpara>Additionally, each method is precise. For example, <literal>resolveClientCache()</literal> resolves a reference to a cache only if
the cache instance is a <quote>client.</quote> If a cache exists but is a <quote>peer</quote> cache instance, <literal>resolveClientCache()</literal>
returns <literal>Optional.EMPTY</literal>. The behavior of <literal>resolvePeerCache()</literal> is similar.</simpara>
<simpara><literal>require()</literal> returns a non-<literal>Optional</literal> reference to a cache instance and throws an <literal>IllegalStateException</literal> if a cache
is not present.</simpara>
</section>
<section xml:id="geode-api-extensions-cacheutils">
<title><literal>CacheUtils</literal></title>
<simpara>Under the hood, <literal>SimpleCacheResolver</literal> delegates some of its functions to the
<link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/util/CacheUtils.html"><literal>CacheUtils</literal></link>
abstract utility class, which provides additional, convenient capabilities when you use a cache.</simpara>
<simpara>While there are utility methods to determine whether a cache instance (that is, a <literal>GemFireCache</literal>) or Region is a client
or a peer, one of the more useful functions is to extract all the values from a Region.</simpara>
<simpara>To extract all the values stored in a Region, call <literal>CacheUtils.collectValues(:Region&lt;?, T&gt;)</literal>. This method returns a
<literal>Collection&lt;T&gt;</literal> that contains all the values stored in the given <literal>Region</literal>. The method is smart and knows how to handle
the <literal>Region</literal> appropriately regardless of whether the <literal>Region</literal> is a client or a peer. This distinction is important,
since client <literal>PROXY</literal> Regions store no values.</simpara>
<warning>
<simpara>Caution is advised when you get all values from a Region. While getting filtered reference values from a
non-transactional, reference data only [<literal>REPLICATE</literal>] Region is quite useful, getting all values from a transactional,
[<literal>PARTITION</literal>] Region can prove quite detrimental, especially in production. Getting all values from a Region can be
useful during testing.</simpara>
</warning>
</section>
<section xml:id="geode-api-extensions-membership">
<title><literal>MembershipListenerAdapter</literal> and <literal>MembershipEvent</literal></title>
<simpara>Another useful API hidden by Apache Geode is the membership events and listener interface. This API is especially useful
on the server side when your Spring Boot application serves as a peer member of an Apache Geode distributed system.</simpara>
<simpara>When a peer member is disconnected from the distributed system, perhaps due to a network failure, the member is forcibly
removed from the cluster. This node immediately enters a reconnecting state, trying to establish a connection back to
the cluster. Once reconnected, the peer member must rebuild all cache objects (<literal>Cache</literal>, <literal>Region</literal> instances, <literal>Index</literal>
instances, <literal>DiskStore</literal> instances, and so on). All previous cache objects are now invalid, and their references are stale.</simpara>
<simpara>In a Spring context, this is particularly problematic since most Apache Geode objects are <emphasis>Singleton</emphasis> beans declared in
and managed by the Spring container. Those beans may be injected and used in other framework and application components.
For instance, <literal>Region</literal> instances are injected into SDG&#8217;s <literal>GemfireTemplate</literal>, Spring Data Repositories and possibly
application-specific data access objects (<link xl:href="https://en.wikipedia.org/wiki/Data_access_object">DAOs</link>).</simpara>
<simpara>If references to those cache objects become stale on a forced disconnect event, there is no way to auto-wire fresh
object references into the dependent application or framework components when the peer member is reconnected, unless the
Spring <literal>ApplicationContext</literal> is <quote>refreshed</quote>. In fact, there is no way to even know that this event has occurred, since
the Apache Geode <literal>MembershipListener</literal> API and corresponding events are <quote>internal</quote>.</simpara>
<note>
<simpara>The Spring team explored the idea of creating proxies for all types of cache objects (<literal>Cache</literal>, <literal>Region</literal>, <literal>Index</literal>,
<literal>DiskStore</literal>, <literal>AsyncEventQueue</literal>, <literal>GatewayReceiver</literal>, <literal>GatewaySender</literal>, and others) used by Spring. The proxies would know
how to obtain a fresh reference on a reconnect event. However, this turns out to be more problematic than it is worth.
It is easier to <quote>refresh</quote> the Spring <literal>ApplicationContext</literal>, although doing so is no less expensive. Neither way is
ideal. See <link xl:href="https://jira.spring.io/browse/SGF-921">SGF-921</link> and <link xl:href="https://jira.spring.io/browse/SGF-227">SGF-227</link>
for further details.</simpara>
</note>
<simpara>In the case where membership events are useful to the Spring Boot application, SBDG provides the following
<link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/distributed/event/package-frame.html">API</link>:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/distributed/event/MembershipListenerAdapter.html"><literal>MembershipListenerAdapter</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/distributed/event/MembershipEvent.html"><literal>MembershipEvent</literal></link></simpara>
</listitem>
</itemizedlist>
<simpara>The abstract <literal>MembershipListenerAdapter</literal> class implements Apache Geode&#8217;s <literal>org.apache.geode.distributed.internal.MembershipListener</literal>
interface to simplify the event handler method signatures by using an appropriate <literal>MembershipEvent</literal> type to encapsulate
the actors in the event.</simpara>
<simpara>The abstract <literal>MembershipEvent</literal> class is further subclassed to represent specific membership event types that occur
within the Apache Geode system:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/distributed/event/support/MemberDepartedEvent.html"><literal>MemberDepartedEvent</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/distributed/event/support/MemberJoinedEvent.html"><literal>MemberJoinedEvent</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/distributed/event/support/MemberSuspectEvent.html"><literal>MemberSuspectEvent</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/distributed/event/support/QuorumLostEvent.html"><literal>QuorumLostEvent</literal></link></simpara>
</listitem>
</itemizedlist>
<simpara>The API is depicted in the following UML diagram:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/membership-api-uml.png"/>
</imageobject>
<textobject><phrase>membership api uml</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The membership event type is further categorized with an appropriate enumerated value,
<link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/distributed/event/MembershipEvent.Type.html"><literal>MembershipEvent.Type</literal></link>,
as a property of the <literal>MembershipEvent</literal> itself (see <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/distributed/event/MembershipEvent.html#getType--"><literal>getType()</literal></link>).</simpara>
<simpara>The type hierarchy is useful in <literal>instanceof</literal> expressions, while the <literal>Enum</literal> is useful in <literal>switch</literal> statements.</simpara>
<simpara>You can see one particular implementation of the <literal>MembershipListenerAdapter</literal> with the
<link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/distributed/event/ApplicationContextMembershipListener.html"><literal>ApplicationContextMembershipListener</literal></link> class,
which does exactly as we described earlier, handling forced-disconnect/auto-reconnect membership events inside a
Spring container in order to refresh the Spring <literal>ApplicationContext</literal>.</simpara>
</section>
<section xml:id="geode-api-extensions-pdx">
<title>PDX</title>
<simpara>Apache Geode&#8217;s PDX serialization framework is yet another API that falls short of a complete stack.</simpara>
<simpara>For instance, there is no easy or direct way to serialize an object as PDX bytes. It is also not possible to modify an
existing <literal>PdxInstance</literal> by adding or removing fields, since doing so would require a new PDX type. In this case, you must
create a new <literal>PdxInstance</literal> and copy from an existing <literal>PdxInstance</literal>. Unfortunately, the Apache Geode API offers no help
in this regard. It is also not possible to use PDX in a client, local-only mode without a server, since the PDX type
registry is only available and managed on servers in a cluster.</simpara>
<section xml:id="geode-api-extensions-pdx-builder">
<title><literal>PdxInstanceBuilder</literal></title>
<simpara>In such cases, SBDG conveniently provides the
<link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/pdx/PdxInstanceBuilder.html"><literal>PdxInstanceBuilder</literal></link> class,
appropriately named after the <link xl:href="https://en.wikipedia.org/wiki/Builder_pattern">Builder software design pattern</link>.
The <literal>PdxInstanceBuilder</literal> also offers a fluent API for constructing <literal>PdxInstances</literal>:</simpara>
<example>
<title><literal>PdxInstanceBuilder</literal> API</title>
<programlisting language="java" linenumbering="unnumbered">class PdxInstanceBuilder {

	PdxInstanceFactory copy(PdxInstance pdx);

	Factory from(Object target);

}</programlisting>
</example>
<simpara>For example, you could serialize an application domain object as PDX bytes with the following code:</simpara>
<example>
<title>Serializing an Object to PDX</title>
<programlisting language="java" linenumbering="unnumbered">@Component
class CustomerSerializer {

	PdxInstance serialize(Customer customer) {

		return PdxInstanceBuilder.create()
            .from(customer)
            .create();
	}
}</programlisting>
</example>
<simpara>You could then modify the <literal>PdxInstance</literal> by copying from the original:</simpara>
<example>
<title>Copy <literal>PdxInstance</literal></title>
<programlisting language="java" linenumbering="unnumbered">@Component
class CustomerDecorator {

	@Autowired
    CustomerSerializer serializer;

	PdxIntance decorate(Customer customer) {

		PdxInstance pdxCustomer = serializer.serialize(customer);

		return PdxInstanceBuilder.create()
            .copy(pdxCustomer)
            .writeBoolean("vip", isImportant(customer))
            .create();
	}
}</programlisting>
</example>
</section>
<section xml:id="geode-api-extensions-pdx-wrapper">
<title><literal>PdxInstanceWrapper</literal></title>
<simpara>SBDG also provides the <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/pdx/PdxInstanceWrapper.html"><literal>PdxInstanceWrapper</literal></link>
class to wrap an existing <literal>PdxInstance</literal> in order to provide more control during the conversion from PDX to JSON and from
JSON back into a POJO. Specifically, the wrapper gives you more control over the configuration of Jackson&#8217;s
<literal>ObjectMapper</literal>.</simpara>
<simpara>The <literal>ObjectMapper</literal> constructed by Apache Geode&#8217;s own <literal>PdxInstance</literal> implementation (<literal>PdxInstanceImpl</literal>) is not
configurable, nor was it configured correctly. Unfortunately, since <literal>PdxInstance</literal> is not extensible, the <literal>getObject()</literal>
method fails when converting the JSON generated from PDX back into a POJO for any practical application domain model
type.</simpara>
<simpara>The following example wraps an existing <literal>PdxInstance</literal>:</simpara>
<example>
<title>Wrapping an existing <literal>PdxInstance</literal></title>
<programlisting language="java" linenumbering="unnumbered">PdxInstanceWrapper wrapper = PdxInstanceWrapper.from(pdxInstance);</programlisting>
</example>
<simpara>For all operations on <literal>PdxInstance</literal> except <literal>getObject()</literal>, the wrapper delegates to the underlying <literal>PdxInstance</literal> method
implementation called by the user.</simpara>
<simpara>In addition to the decorated <literal>getObject()</literal> method, the <literal>PdxInstanceWrapper</literal> provides a thorough implementation of the
<literal>toString()</literal> method. The state of the <literal>PdxInstance</literal> is output in a JSON-like <literal>String</literal>.</simpara>
<simpara>Finally, the <literal>PdxInstanceWrapper</literal> class adds a <literal>getIdentifier()</literal> method. Rather than put the burden on the user to have
to iterate the field names of the <literal>PdxInstance</literal> to determine whether a field is the identity field and then call
<literal>getField(name)</literal> with the field name to get the ID (value)&#8201;&#8212;&#8201;assuming an identity field was marked in the first place&#8201;&#8212;&#8201;the <literal>PdxInstanceWrapper</literal> class provides the <literal>getIdentifier()</literal> method to return the ID of the <literal>PdxInstance</literal> directly.</simpara>
<simpara>The <literal>getIdentifier()</literal> method is smart in that it first iterates the fields of the <literal>PdxInstance</literal>, asking each field if it
is the identity field. If no field was marked as the identity field, the algorithm searches for a field named <literal>id</literal>. If
no field with the name <literal>id</literal> exists, the algorithm searches for a metadata field called <literal>@identifier</literal>, which refers to
the field that is the identity field of the <literal>PdxInstance</literal>.</simpara>
<simpara>The <literal>@identifier</literal> metadata field is useful in cases where the <literal>PdxInstance</literal> originated from JSON and the application
domain object uses a natural identifier, rather than a surrogate ID, such as <literal>Book.isbn</literal>.</simpara>
<note>
<simpara>Apache Geode&#8217;s <literal>JSONFormatter</literal> class is not capable of marking the identity field of a <literal>PdxInstance</literal> originating
from JSON.</simpara>
</note>
<warning>
<simpara>It is not currently possible to implement the <literal>PdxInstance</literal> interface and store instances of this type as a
value in a Region. Apache Geode assumes all <literal>PdxInstance</literal> objects are an implementation created by Apache Geode itself
(that is, <literal>PdxInstanceImpl</literal>), which has a tight coupling to the PDX type registry. An <literal>Exception</literal> is thrown if you try
to store instances of your own <literal>PdxInstance</literal> implementation.</simpara>
</warning>
</section>
<section xml:id="geode-api-extensions-pdx-adapter">
<title><literal>ObjectPdxInstanceAdapter</literal></title>
<simpara>In rare cases, you may need to treat an <literal>Object</literal> as a <literal>PdxInstance</literal>, depending on the context without incurring
the overhead of serializing an <literal>Object</literal> to PDX. For such cases, SBDG offers the <literal>ObjectPdxInstanceAdapter</literal> class.</simpara>
<simpara>This might be true when calling a method with a parameter expecting an argument of, or returning an instance of,
type <literal>PdxInstance</literal>, particularly when Apache Geode&#8217;s <literal>read-serialized</literal> PDX configuration property is set to <literal>true</literal>
and only an object is available in the current context.</simpara>
<simpara>Under the hood, SBDG&#8217;s <literal>ObjectPdxInstanceAdapter</literal> class uses Spring&#8217;s
<link xl:href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/BeanWrapper.html"><literal>BeanWrapper</literal></link> class along with Java&#8217;s
introspection and reflection functionality to adapt the given <literal>Object</literal> and access it with the full
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/pdx/PdxInstance.html"><literal>PdxInstance</literal></link> API. This includes the use of the
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/pdx/WritablePdxInstance.html"><literal>WritablePdxInstance</literal></link> API, obtained from
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/pdx/PdxInstance.html#createWriter--"><literal>PdxInstance.createWriter()</literal></link>, to modify
the underlying <literal>Object</literal> as well.</simpara>
<simpara>Like the <literal>PdxInstanceWrapper</literal> class, <literal>ObjectPdxInstanceAdapter</literal> contains special logic to resolve the identity field
and ID of the <literal>PdxInstance</literal>, including consideration for Spring Data&#8217;s
<link xl:href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/annotation/Id.html"><literal>@Id</literal></link> mapping annotation,
which can be introspected in this case, given that the underlying <literal>Object</literal> backing the <literal>PdxInstance</literal> is a POJO.</simpara>
<simpara>The <literal>ObjectPdxInstanceAdapter.getObject()</literal> method returns the wrapped <literal>Object</literal> used to construct
the <literal>ObjectPdxInstanceAdapter</literal> and is, therefore, automatically deserializable, as determined by the
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/pdx/PdxInstance.html#isDeserializable--"><literal>PdxInstance.isDeseriable()</literal></link> method,
which always returns <literal>true</literal>.</simpara>
<simpara>You can adapt any <literal>Object</literal> as a <literal>PdxInstance</literal>:</simpara>
<example>
<title>Adapt an <literal>Object</literal> as a <literal>PdxInstance</literal></title>
<programlisting language="java" linenumbering="unnumbered">class OfflineObjectToPdxInstanceConverter {

	@NonNull PdxInstance convert(@NonNull Object target) {
		return ObjectPdxInstanceAdapter.from(target);
	}
}</programlisting>
</example>
<simpara>Once the <link xl:href="https://en.wikipedia.org/wiki/Adapter_pattern">Adapter</link> is created, you can use it to access data
on the underlying <literal>Object</literal>.</simpara>
<simpara>Consider the following example of a <literal>Customer</literal> class:</simpara>
<example>
<title><literal>Customer</literal> class</title>
<programlisting language="java" linenumbering="unnumbered">@Region("Customers")
class Customer {

	@Id
    private Long id;

	String name;

	// constructors, getters and setters omitted

}</programlisting>
</example>
<simpara>Then you can access an instance of <literal>Customer</literal> by using the <literal>PdxInstance</literal> API:</simpara>
<example>
<title>Accessing an <literal>Object</literal> using the <literal>PdxInstance</literal> API</title>
<programlisting language="java" linenumbering="unnumbered">class ObjectPdxInstanceAdapterTest {

	@Test
    public void getAndSetObjectProperties() {

		Customer jonDoe = new Customer(1L, "Jon Doe");

		PdxInstance adapter = ObjectPdxInstanceAdapter.from(jonDoe);

		assertThat(jonDoe.getName()).isEqualTo("Jon Doe");
		assertThat(adapter.getField("name")).isEqualTo("Jon Doe");

		adapter.createWriter().setField("name", "Jane Doe");

		assertThat(adapter.getField("name")).isEqualTo("Jane Doe");
		assertThat(jonDoe.getName()).isEqualTo("Jane Doe");
    }
}</programlisting>
</example>
</section>
</section>
<section xml:id="geode-api-extensions-security">
<title>Security</title>
<simpara>For testing purposes, SBDG provides a test implementation of
Apache Geode&#8217;s <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/security/SecurityManager.html"><literal>SecurityManager</literal></link> interface,
which expects the password to match the username (case-sensitive) when authenticating.</simpara>
<simpara>By default, all operations are authorized.</simpara>
<simpara>To match the expectations of SBDG&#8217;s <literal>TestSecurityManager</literal>, SBDG additionally provides a test implementation of
Apache Geode&#8217;s <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/security/AuthInitialize.html"><literal>AuthInitialize</literal></link> interface,
which supplies matching credentials for both the username and password.</simpara>
</section>
</chapter>
<chapter xml:id="actuator">
<title>Spring Boot Actuator</title>
<simpara>Spring Boot for Apache Geode (SBDG) adds <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready.html">Spring Boot Actuator</link> support
and dedicated <literal>HealthIndicators</literal> for Apache Geode. Equally, the provided <literal>HealthIndicators</literal> even work with Tanzu Cache
(which is backed by VMware Tanzu GemFire) when you push your Spring Boot applications using Apache Geode
to {VMware Tanzu Application Service (TAS)} platform.</simpara>
<simpara>Spring Boot <literal>HealthIndicators</literal> provide details about the runtime operation and behavior of your Apache Geode-based
Spring Boot applications. For instance, by querying the right <literal>HealthIndicator</literal> endpoint, you can get the current
hit/miss count for your <literal>Region.get(key)</literal> data access operations.</simpara>
<simpara>In addition to vital health information, SBDG provides basic, pre-runtime configuration metadata about the
Apache Geode components that are monitored by Spring Boot Actuator. This makes it easier to see how
the application was configured all in one place, rather than in properties files, Spring configuration, XML,
and so on.</simpara>
<simpara>The provided Spring Boot <literal>HealthIndicators</literal> fall into three categories:</simpara>
<itemizedlist>
<listitem>
<simpara>Base <literal>HealthIndicators</literal> that apply to all Apache Geode, Spring Boot applications, regardless of cache type,
such as <literal>Regions</literal>, <literal>Indexes</literal>, and <literal>DiskStores</literal>.</simpara>
</listitem>
<listitem>
<simpara>Peer <literal>Cache</literal>-based <literal>HealthIndicators</literal> that apply only to peer <literal>Cache</literal> applications, such as <literal>AsyncEventQueues</literal>,
<literal>CacheServers</literal>, <literal>GatewayReceivers</literal>, and <literal>GatewaySenders</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>ClientCache</literal>-based <literal>HealthIndicators</literal> that apply only to <literal>ClientCache</literal> applications, such as <literal>ContinuousQuery</literal>
and connection <literal>Pools</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The following sections give a brief overview of all the available Spring Boot <literal>HealthIndicators</literal> provided for
Apache Geode.</simpara>
<tip>
<simpara>See the corresponding sample <link xl:href="guides/boot-actuator.html">guide</link> and {github-samples-url}/boot/actuator[code]
to see Spring Boot Actuator for Apache Geode in action.</simpara>
</tip>
<section xml:id="actuator-base-healthindicators">
<title>Base HealthIndicators</title>
<simpara>This section covers Spring Boot <literal>HealthIndicators</literal> that apply to both Apache Geode peer <literal>Cache</literal> and <literal>ClientCache</literal>,
Spring Boot applications. That is, these <literal>HealthIndicators</literal> are not specific to the cache type.</simpara>
<simpara>In Apache Geode, the cache instance is either a peer <literal>Cache</literal> instance (which makes your Spring Boot application
part of a Apache Geode cluster) or, more commonly, a <literal>ClientCache</literal> instance (which talks to an existing cluster).
Your Spring Boot application can only be one cache type or the other and can only have a single instance of
that cache type.</simpara>
<section xml:id="actuator-base-healthindicators-cache">
<title>GeodeCacheHealthIndicator</title>
<simpara><literal>GeodeCacheHealthIndicator</literal> provides essential details about the (single) cache instance (client or peer)
and the underlying <literal>DistributedSystem</literal>, the <literal>DistributedMember</literal> and configuration details of the <literal>ResourceManager</literal>.</simpara>
<simpara>When your Spring Boot application creates an instance of a peer <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/Cache.html"><literal>Cache</literal></link>,
the <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/distributed/DistributedMember.html"><literal>DistributedMember</literal></link> object represents
your application as a peer member or node of the <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/distributed/DistributedSystem.html"><literal>DistributedSystem</literal></link>.
The distributed system (that is, the cluster) is formed from a collection of connected peers, to which your application
also has <link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/GemFireCache.html#getDistributedSystem--">access</link>&#8201;&#8212;&#8201;indirectly,
through the cache instance.</simpara>
<simpara>This is no different for a <literal>ClientCache</literal> even though the client is technically not part of the peer/server cluster.
However, it still creates instances of the <literal>DistributedSystem</literal> and <literal>DistributedMember</literal> objects, respectively.</simpara>
<simpara>Each object has the following configuration metadata and health details:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Cache Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.cache.name</simpara></entry>
<entry align="left" valign="top"><simpara>Name of the member in the distributed system.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.closed</simpara></entry>
<entry align="left" valign="top"><simpara>Determines whether the cache has been closed.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.cancel-in-progress</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether cancellation of operations is in progress.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>DistributedMember Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.distributed-member.id</simpara></entry>
<entry align="left" valign="top"><simpara><literal>DistributedMember</literal> identifier (used in logs internally).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.distributed-member.name</simpara></entry>
<entry align="left" valign="top"><simpara>Name of the member in the distributed system.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.distributed-members.groups</simpara></entry>
<entry align="left" valign="top"><simpara>Configured groups to which the member belongs.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.distributed-members.host</simpara></entry>
<entry align="left" valign="top"><simpara>Name of the machine on which the member is running.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.distributed-members.process-id</simpara></entry>
<entry align="left" valign="top"><simpara>Identifier of the JVM process (PID).</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>DistributedSystem Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.distributed-system.connected</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the member is currently connected to
the cluster.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.distributed-system.member-count</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of members in the cluster (1 for clients).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.distributed-system.reconnecting</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the member is in a reconnecting state,
which happens when a network partition occurs and the member gets disconnected from the cluster.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.distributed-system.properties-location</simpara></entry>
<entry align="left" valign="top"><simpara>Location of the
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/topics/gemfire_properties.html">standard configuration properties</link>.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.distributed-system.security-properties-location</simpara></entry>
<entry align="left" valign="top"><simpara>Location of the
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/topics/gemfire_properties.html">security configuration properties</link>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>ResourceManager Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.resource-manager.critical-heap-percentage</simpara></entry>
<entry align="left" valign="top"><simpara>Percentage of heap at which the cache is in danger of
becoming inoperable.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.resource-manager.critical-off-heap-percentage</simpara></entry>
<entry align="left" valign="top"><simpara>Percentage of off-heap at which the cache is in danger of
becoming inoperable.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.resource-manager.eviction-heap-percentage</simpara></entry>
<entry align="left" valign="top"><simpara>Percentage of heap at which eviction begins on Regions
configured with a heap LRU eviction policy.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.resource-manager.eviction-off-heap-percentage</simpara></entry>
<entry align="left" valign="top"><simpara>Percentage of off-heap at which eviction begins on Regions
configured with a heap LRU eviction policy.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="actuator-base-healthindicators-regions">
<title>GeodeRegionsHealthIndicator</title>
<simpara><literal>GeodeRegionsHealthIndicator</literal> provides details about all the configured and known <literal>Regions</literal> in the cache.
If the cache is a client, details include all <literal>LOCAL</literal>, <literal>PROXY</literal>, and <literal>CACHING_PROXY</literal> <literal>Regions</literal>. If the cache is a peer
then details include all <literal>LOCAL</literal>, <literal>PARTITION</literal>, and <literal>REPLICATE</literal> <literal>Region</literal> instances.</simpara>
<simpara>The following table describes the essential details and basic performance metrics:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Region Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.cloning-enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Whether Region values are cloned on read (for example, <literal>cloning-enabled</literal>
is <literal>true</literal> when cache transactions are used to prevent in-place modifications).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.data-policy</simpara></entry>
<entry align="left" valign="top"><simpara>Policy used to manage data in the Region (<literal>PARTITION</literal>, <literal>REPLICATE</literal>,
and others).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.initial-capacity</simpara></entry>
<entry align="left" valign="top"><simpara>Initial number of entries that can be held by a Region before it needs
to be resized.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.load-factor</simpara></entry>
<entry align="left" valign="top"><simpara>Load factor used to determine when to resize the Region when it nears
capacity.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.key-constraint</simpara></entry>
<entry align="left" valign="top"><simpara>Type constraint for Region keys.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.off-heap</simpara></entry>
<entry align="left" valign="top"><simpara>Determines whether this Region stores values in off-heap memory
(NOTE: Keys are always kept on the JVM heap).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.pool-name</simpara></entry>
<entry align="left" valign="top"><simpara>If this Region is a client Region, this property determines
the configured connection <literal>Pool</literal>. (NOTE: Regions can have and use dedicated <literal>Pools</literal> for their data access operations.)</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.pool-name</simpara></entry>
<entry align="left" valign="top"><simpara>Determines the <literal>Scope</literal> of the Region, which plays a factor in
the Region&#8217;s consistency-level, as it pertains to acknowledgements for writes.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.value-constraint</simpara></entry>
<entry align="left" valign="top"><simpara>Type constraint for Region values.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The following details also apply when the Region is a peer <literal>Cache</literal> <literal>PARTITION</literal> Region:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Partition Region Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.partition.collocated-with</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether this Region is collocated with
another <literal>PARTITION</literal> Region, which is necessary when performing equi-joins queries (NOTE: distributed joins
are not supported).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.partition.local-max-memory</simpara></entry>
<entry align="left" valign="top"><simpara>Total amount of heap memory allowed to be used by
this Region on this node.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.partition.redundant-copies</simpara></entry>
<entry align="left" valign="top"><simpara>Number of replicas for this <literal>PARTITION</literal> Region,
which is useful in high availability (HA) use cases.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.partition.total-max-memory</simpara></entry>
<entry align="left" valign="top"><simpara>Total amount of heap memory allowed to be used by
this Region across all nodes in the cluster hosting this Region.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.partition.total-number-of-buckets</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of buckets (shards) into which this Region
is divided (defaults to 113).</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Finally, when statistics are enabled (for example, when you use <literal>@EnableStatistics</literal>&#8201;&#8212;&#8201;(see <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-statistics">doc</link> for more details),
the following metadata is available:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Region Statistic Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.statistics.hit-count</simpara></entry>
<entry align="left" valign="top"><simpara>Number of hits for a region entry.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.statistics.hit-ratio</simpara></entry>
<entry align="left" valign="top"><simpara>Ratio of hits to the number of <literal>Region.get(key)</literal> calls.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.statistics.last-accessed-time</simpara></entry>
<entry align="left" valign="top"><simpara>For an entry, indicates the last time it was accessed
with <literal>Region.get(key)</literal>.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.statistics.last-modified-time</simpara></entry>
<entry align="left" valign="top"><simpara>For an entry, indicates the time when a Region&#8217;s entry
value was last modified.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.regions.&lt;name&gt;.statistics.miss-count</simpara></entry>
<entry align="left" valign="top"><simpara>Returns the number of times that a <literal>Region.get</literal>
was performed and no value was found locally.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="actuator-base-healthindicators-indexes">
<title>GeodeIndexesHealthIndicator</title>
<simpara><literal>GeodeIndexesHealthIndicator</literal> provides details about the configured Region <literal>Indexes</literal> used by OQL query data access
operations.</simpara>
<simpara>The following details are covered:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Index Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.index.&lt;name&gt;.from-clause</simpara></entry>
<entry align="left" valign="top"><simpara>Region from which data is selected.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.index.&lt;name&gt;.indexed-expression</simpara></entry>
<entry align="left" valign="top"><simpara>Region value fields and properties used in the Index expression.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.index.&lt;name&gt;.projection-attributes</simpara></entry>
<entry align="left" valign="top"><simpara>For <literal>Map</literal> <literal>Indexes</literal>, returns either <literal><emphasis role="strong"></literal> or the specific Map keys
that were indexed. For all other <literal>Indexes</literal>, returns <literal></emphasis></literal>.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.index.&lt;name&gt;.region</simpara></entry>
<entry align="left" valign="top"><simpara>Region to which the Index is applied.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Additionally, when statistics are enabled (for example, when you use <literal>@EnableStatistics</literal>&#8201;&#8212;&#8201;see <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-statistics">Configuring Statistics</link> for more details),
the following metadata is available:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Index Statistic Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.index.&lt;name&gt;.statistics.number-of-bucket-indexes</simpara></entry>
<entry align="left" valign="top"><simpara>Number of bucket Indexes created in a PARTITION Region.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.index.&lt;name&gt;.statistics.number-of-keys</simpara></entry>
<entry align="left" valign="top"><simpara>Number of keys in this Index.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.index.&lt;name&gt;.statistics.number-of-map-indexed-keys</simpara></entry>
<entry align="left" valign="top"><simpara>Number of keys in this Index at the highest level.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.index.&lt;name&gt;.statistics.number-of-values</simpara></entry>
<entry align="left" valign="top"><simpara>Number of values in this Index.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.index.&lt;name&gt;.statistics.number-of-updates</simpara></entry>
<entry align="left" valign="top"><simpara>Number of times this Index has been updated.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.index.&lt;name&gt;.statistics.read-lock-count</simpara></entry>
<entry align="left" valign="top"><simpara>Number of read locks taken on this Index.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.index.&lt;name&gt;.statistics.total-update-time</simpara></entry>
<entry align="left" valign="top"><simpara>Total amount of time (ns) spent updating this Index.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.index.&lt;name&gt;.statistics.total-uses</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of times this Index has been accessed by
an OQL query.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="actuator-base-healthindicators-diskstores">
<title>GeodeDiskStoresHealthIndicator</title>
<simpara>The <literal>GeodeDiskStoresHealthIndicator</literal> provides details about the configured <literal>DiskStores</literal> in the system or application.
Remember, <literal>DiskStores</literal> are used to overflow and persist data to disk, including type metadata tracked by PDX when the
values in the Regions have been serialized with PDX and the Regions are persistent.</simpara>
<simpara>Most of the tracked health information pertains to configuration:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>DiskStore Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.disk-store.&lt;name&gt;.allow-force-compaction</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether manual compaction of the DiskStore
is allowed.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.disk-store.&lt;name&gt;.auto-compact</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether compaction occurs automatically.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.disk-store.&lt;name&gt;.compaction-threshold</simpara></entry>
<entry align="left" valign="top"><simpara>Percentage at which the oplog becomes compactible.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.disk-store.&lt;name&gt;.disk-directories</simpara></entry>
<entry align="left" valign="top"><simpara>Location of the oplog disk files.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.disk-store.&lt;name&gt;.disk-directory-sizes</simpara></entry>
<entry align="left" valign="top"><simpara>Configured and allowed sizes (MB) for the disk directory
that stores the disk files.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.disk-store.&lt;name&gt;.disk-usage-critical-percentage</simpara></entry>
<entry align="left" valign="top"><simpara>Critical threshold of disk usage proportional to
the total disk volume.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.disk-store.&lt;name&gt;.disk-usage-warning-percentage</simpara></entry>
<entry align="left" valign="top"><simpara>Warning threshold of disk usage proportional to
the total disk volume.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.disk-store.&lt;name&gt;.max-oplog-size</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum size (MB) allowed for a single oplog file.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.disk-store.&lt;name&gt;.queue-size</simpara></entry>
<entry align="left" valign="top"><simpara>Size of the queue used to batch writes that are flushed
to disk.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.disk-store.&lt;name&gt;.time-interval</simpara></entry>
<entry align="left" valign="top"><simpara>Time to wait (ms) before writes are flushed to disk
from the queue if the size limit has not be reached.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.disk-store.&lt;name&gt;.uuid</simpara></entry>
<entry align="left" valign="top"><simpara>Universally unique identifier for the DiskStore across a
distributed system.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.disk-store.&lt;name&gt;.write-buffer-size</simpara></entry>
<entry align="left" valign="top"><simpara>Size the of write buffer the DiskStore uses to write data
to disk.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="actuator-clientcache-healthindicators">
<title><literal>ClientCache</literal> <literal>HealthIndicators</literal></title>
<simpara>The <literal>ClientCache</literal>-based <literal>HealthIndicators</literal> provide additional details specifically for Spring Boot, cache client
applications. These <literal>HealthIndicators</literal> are available only when the Spring Boot application creates a <literal>ClientCache</literal>
instance (that is, the application is a cache client), which is the default.</simpara>
<section xml:id="actuator-clientcache-healthindicators-cq">
<title>GeodeContinuousQueriesHealthIndicator</title>
<simpara><literal>GeodeContinuousQueriesHealthIndicator</literal> provides details about registered client Continuous Queries (CQs). CQs let
client applications receive automatic notification about events that satisfy some criteria. That criteria can be easily
expressed by using the predicate of an OQL query (for example, <literal>SELECT * FROM /Customers c WHERE c.age &gt; 21</literal>).
When data is inserted or updated and the data matches the criteria specified in the OQL query predicate
(data of interests), an event is sent to the registered client.</simpara>
<simpara>The following details are covered for CQs by name:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Continuous Query (CQ) Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.&lt;name&gt;.oql-query-string</simpara></entry>
<entry align="left" valign="top"><simpara>OQL query constituting the CQ.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.&lt;name&gt;.closed</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the CQ has been closed.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.&lt;name&gt;.closing</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the CQ is in the process of closing.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.&lt;name&gt;.durable</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the CQ events are remembered
between client sessions.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.&lt;name&gt;.running</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the CQ is currently running.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.&lt;name&gt;.stopped</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the CQ has been stopped.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>In addition, the following CQ query and statistical data is covered:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Continuous Query (CQ), Query Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.&lt;name&gt;.query.number-of-executions</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of times the query has been executed.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.&lt;name&gt;.query.total-execution-time</simpara></entry>
<entry align="left" valign="top"><simpara>Total amount of time (ns) spent executing the query.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Continuous Query(CQ), Statistic Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.&lt;name&gt;.statistics.number-of-deletes</simpara></entry>
<entry align="left" valign="top"><simpara>Number of delete events qualified by this CQ.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.&lt;name&gt;.statistics.number-of-events</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of events qualified by this CQ.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.&lt;name&gt;.statistics.number-of-inserts</simpara></entry>
<entry align="left" valign="top"><simpara>Number of insert events qualified by this CQ.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.&lt;name&gt;.statistics.number-of-updates</simpara></entry>
<entry align="left" valign="top"><simpara>Number of update events qualified by this CQ.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The Apache Geode Continuous Query system is also tracked with the following additional details on the client:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Continuous Query (CQ), Additional Statistic Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.count</simpara></entry>
<entry align="left" valign="top"><simpara>Total count of CQs.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.number-of-active</simpara></entry>
<entry align="left" valign="top"><simpara>Number of currently active CQs (if available).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.number-of-closed</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of closed CQs (if available).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.number-of-created</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of created CQs (if available).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.number-of-stopped</simpara></entry>
<entry align="left" valign="top"><simpara>Number of currently stopped CQs (if available).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.continuous-query.number-on-client</simpara></entry>
<entry align="left" valign="top"><simpara>Number of CQs that are currently active or stopped
(if available).</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="actuator-clientcache-healthindicators-pools">
<title>GeodePoolsHealthIndicator</title>
<simpara><literal>GeodePoolsHealthIndicator</literal> provides details about all the configured client connection <literal>Pools</literal>. This <literal>HealthIndicator</literal>
primarily provides configuration metadata for all the configured <literal>Pools</literal>.</simpara>
<simpara>The following details are covered:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Pool Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.pool.count</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of client connection pools.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.destroyed</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the pool has been destroyed.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.free-connection-timeout</simpara></entry>
<entry align="left" valign="top"><simpara>Configured amount of time to wait for a free connection
from the Pool.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.idle-timeout</simpara></entry>
<entry align="left" valign="top"><simpara>The amount of time to wait before closing unused, idle
connections, not exceeding the configured number of minimum required connections.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.load-conditioning-interval</simpara></entry>
<entry align="left" valign="top"><simpara>How frequently the Pool checks to see whether a connection
to a given server should be moved to a different server to improve the load balance.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.locators</simpara></entry>
<entry align="left" valign="top"><simpara>List of configured Locators.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.max-connections</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum number of connections obtainable from the Pool.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.min-connections</simpara></entry>
<entry align="left" valign="top"><simpara>Minimum number of connections contained by the Pool.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.multi-user-authentication</simpara></entry>
<entry align="left" valign="top"><simpara>Determines whether the Pool can be used by multiple
authenticated users.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.online-locators</simpara></entry>
<entry align="left" valign="top"><simpara>Returns a list of living Locators.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.pending-event-count</simpara></entry>
<entry align="left" valign="top"><simpara>Approximate number of pending subscription events maintained
at the server for this durable client Pool at the time it (re)connected to the server.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.ping-interval</simpara></entry>
<entry align="left" valign="top"><simpara>How often to ping the servers to verify they are still alive.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.pr-single-hop-enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Whether the client acquires a direct connection to
the server.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.read-timeout</simpara></entry>
<entry align="left" valign="top"><simpara>Number of milliseconds to wait for a response from a server
before timing out the operation and trying another server (if any are available).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.retry-attempts</simpara></entry>
<entry align="left" valign="top"><simpara>Number of times to retry a request after a timeout
or an exception.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.server-group</simpara></entry>
<entry align="left" valign="top"><simpara>All servers must belong to the same group, and this value
sets the name of that group.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.servers</simpara></entry>
<entry align="left" valign="top"><simpara>List of configured servers.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.socket-buffer-size</simpara></entry>
<entry align="left" valign="top"><simpara>Socket buffer size for each connection made in this pool.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.statistic-interval</simpara></entry>
<entry align="left" valign="top"><simpara>How often to send client statistics to the server.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.subscription-ack-interval</simpara></entry>
<entry align="left" valign="top"><simpara>Interval in milliseconds to wait before sending
acknowledgements to the cache server for events received from the server subscriptions.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.subscription-enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled server-to-client subscriptions.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.subscription-message-tracking-timeout</simpara></entry>
<entry align="left" valign="top"><simpara>Time-to-Live (TTL) period (ms) for subscription events
the client has received from the server.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.subscription-redundancy</simpara></entry>
<entry align="left" valign="top"><simpara>Redundancy level for this Pool&#8217;s server-to-client
subscriptions, which is used to ensure clients do not miss potentially important events.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.pool.&lt;name&gt;.thread-local-connections</simpara></entry>
<entry align="left" valign="top"><simpara>Thread local connection policy for this Pool.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="actuator-peercache-healthindicators">
<title>Peer Cache HealthIndicators</title>
<simpara>The peer <literal>Cache</literal>-based <literal>HealthIndicators</literal> provide additional details specifically for Spring Boot peer cache member
applications. These <literal>HealthIndicators</literal> are available only when the Spring Boot application creates a peer <literal>Cache</literal>
instance.</simpara>
<note>
<simpara>The default cache instance created by Spring Boot for Apache Geode is a <literal>ClientCache</literal> instance.</simpara>
</note>
<tip>
<simpara>To control what type of cache instance is created, such as a <quote>peer</quote>, you can explicitly declare either the
<literal>@PeerCacheApplication</literal> or, alternatively, the <literal>@CacheServerApplication</literal> annotation on your
<literal>@SpringBootApplication</literal>-annotated class.</simpara>
</tip>
<section xml:id="actuator-peercache-healthindicators-cacheservers">
<title>GeodeCacheServersHealthIndicator</title>
<simpara>The <literal>GeodeCacheServersHealthIndicator</literal> provides details about the configured Apache Geode <literal>CacheServer</literal> instances.
<literal>CacheServer</literal> instances are required to enable clients to connect to the servers in the cluster.</simpara>
<simpara>This <literal>HealthIndicator</literal> captures basic configuration metadata and the runtime behavior and characteristics of
the configured <literal>CacheServer</literal> instances:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>CacheServer Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.count</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of configured <literal>CacheServer</literal> instances
on this peer member.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.bind-address</simpara></entry>
<entry align="left" valign="top"><simpara>IP address of the NIC to which the <literal>CacheServer</literal> <literal>ServerSocket</literal>
is bound (useful when the system contains multiple NICs).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.hostname-for-clients</simpara></entry>
<entry align="left" valign="top"><simpara>Name of the host used by clients to connect to the <literal>CacheServer</literal>
(useful with DNS).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.load-poll-interval</simpara></entry>
<entry align="left" valign="top"><simpara>How often (ms) to query the load probe on the <literal>CacheServer</literal>.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.max-connections</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum number of connections allowed to this <literal>CacheServer</literal>.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.max-message-count</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum number of messages that can be put in a client queue.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.max-threads</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum number of threads allowed in this <literal>CacheServer</literal>
to service client requests.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.max-time-between-pings</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum time between client pings.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.message-time-to-live</simpara></entry>
<entry align="left" valign="top"><simpara>Time (seconds) in which the client queue expires.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.port</simpara></entry>
<entry align="left" valign="top"><simpara>Network port to which the CacheServer <literal>ServerSocket</literal> is bound
and on which it listens for client connections.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.running</simpara></entry>
<entry align="left" valign="top"><simpara>Determines whether this <literal>CacheServer</literal> is currently running
and accepting client connections.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.socket-buffer-size</simpara></entry>
<entry align="left" valign="top"><simpara>Configured buffer size of the socket connection used by
this CacheServer.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.tcp-no-delay</simpara></entry>
<entry align="left" valign="top"><simpara>Configures the TCP/IP <literal>TCP_NO_DELAY</literal> setting on outgoing sockets.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>In addition to the configuration settings shown in the preceding table, the <literal>ServerLoadProbe</literal> of the <literal>CacheServer</literal>
tracks additional details about the runtime characteristics of the <literal>CacheServer</literal>:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>CacheServer Metrics and Load Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.load.connection-load</simpara></entry>
<entry align="left" valign="top"><simpara>Load on the server due to client-to-server
connections.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.load.load-per-connection</simpara></entry>
<entry align="left" valign="top"><simpara>Estimate of how much load each new connection
adds to this server.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.load.subscription-connection-load</simpara></entry>
<entry align="left" valign="top"><simpara>Load on the server due to subscription connections.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.load.load-per-subscription-connection</simpara></entry>
<entry align="left" valign="top"><simpara>Estimate of how much load each new subscriber adds
to this server.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.metrics.client-count</simpara></entry>
<entry align="left" valign="top"><simpara>Number of connected clients.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.metrics.max-connection-count</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum number of connections made to this
<literal>CacheServer</literal>.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.metrics.open-connection-count</simpara></entry>
<entry align="left" valign="top"><simpara>Number of open connections to this <literal>CacheServer</literal>.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.cache.server.&lt;index&gt;.metrics.subscription-connection-count</simpara></entry>
<entry align="left" valign="top"><simpara>Number of subscription connections to this
<literal>CacheServer</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="actuator-peercache-healthindicators-aeq">
<title>GeodeAsyncEventQueuesHealthIndicator</title>
<simpara><literal>GeodeAsyncEventQueuesHealthIndicator</literal> provides details about the configured <literal>AsyncEventQueues</literal>. AEQs can be attached to
Regions to configure asynchronous write-behind behavior.</simpara>
<simpara>This <literal>HealthIndicator</literal> captures configuration metadata and runtime characteristics for all AEQs:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>AsyncEventQueue Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.count</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of configured AEQs.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.batch-conflation-enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether batch events are conflated when sent.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.batch-size</simpara></entry>
<entry align="left" valign="top"><simpara>Size of the batch that gets delivered over this AEQ.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.batch-time-interval</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum time interval that can elapse before a batch is sent.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.disk-store-name</simpara></entry>
<entry align="left" valign="top"><simpara>Name of the disk store used to overflow and persist events.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.disk-synchronous</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether disk writes are synchronous or asynchronous.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.dispatcher-threads</simpara></entry>
<entry align="left" valign="top"><simpara>Number of threads used to dispatch events.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.forward-expiration-destroy</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether expiration destroy operations
are forwarded to <literal>AsyncEventListener</literal>.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.max-queue-memory</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum memory used before data needs to be overflowed
to disk.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.order-policy</simpara></entry>
<entry align="left" valign="top"><simpara>Order policy followed while dispatching the events to
<literal>AsyncEventListeners</literal>.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.parallel</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether this queue is parallel (higher throughput)
or serial.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.persistent</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether this queue stores events to disk.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.primary</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether this queue is primary or secondary.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.async-event-queue.&lt;id&gt;.size</simpara></entry>
<entry align="left" valign="top"><simpara>Number of entries in this queue.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="actuator-peercache-healthindicators-gateway-receivers">
<title>GeodeGatewayReceiversHealthIndicator</title>
<simpara><literal>GeodeGatewayReceiversHealthIndicator</literal> provides details about the configured (WAN) <literal>GatewayReceivers</literal>,
which are capable of receiving events from remote clusters when using Apache Geode&#8217;s
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/topologies_and_comm/multi_site_configuration/chapter_overview.html">multi-site, WAN topology</link>.</simpara>
<simpara>This <literal>HealthIndicator</literal> captures configuration metadata along with the running state for each <literal>GatewayReceiver</literal>:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>GatewayReceiver Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-receiver.count</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of configured <literal>GatewayReceiver</literal> instances.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-receiver.&lt;index&gt;.bind-address</simpara></entry>
<entry align="left" valign="top"><simpara>IP address of the NIC to which the <literal>GatewayReceiver</literal>
<literal>ServerSocket</literal> is bound (useful when the system contains multiple NICs).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-receiver.&lt;index&gt;.end-port</simpara></entry>
<entry align="left" valign="top"><simpara>End value of the port range from which the port of
the <literal>GatewayReceiver</literal> is chosen.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-receiver.&lt;index&gt;.host</simpara></entry>
<entry align="left" valign="top"><simpara>IP address or hostname that Locators tell clients (that is,
<literal>GatewaySender</literal> instances) on which this <literal>GatewayReceiver</literal> listens.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-receiver.&lt;index&gt;.max-time-between-pings</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum amount of time between client pings.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-receiver.&lt;index&gt;.port</simpara></entry>
<entry align="left" valign="top"><simpara>Port on which this <literal>GatewayReceiver</literal> listens for clients
(that is, <literal>GatewaySender</literal> instances).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-receiver.&lt;index&gt;.running</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether this <literal>GatewayReceiver</literal> is running
and accepting client connections (from <literal>GatewaySender</literal> instances).</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-receiver.&lt;index&gt;.socket-buffer-size</simpara></entry>
<entry align="left" valign="top"><simpara>Configured buffer size for the socket connections used by
this <literal>GatewayReceiver</literal>.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-receiver.&lt;index&gt;.start-port</simpara></entry>
<entry align="left" valign="top"><simpara>Start value of the port range from which the port of
the <literal>GatewayReceiver</literal> is chosen.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="actuator-peercache-healthindicators-gateway-senders">
<title>GeodeGatewaySendersHealthIndicator</title>
<simpara>The <literal>GeodeGatewaySendersHealthIndicator</literal> provides details about the configured <literal>GatewaySenders</literal>. <literal>GatewaySender</literal>
instances are attached to Regions in order to send Region events to remote clusters in Apache Geode&#8217;s
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/topologies_and_comm/multi_site_configuration/chapter_overview.html">multi-site, WAN topology</link>.</simpara>
<simpara>This <literal>HealthIndicator</literal> captures essential configuration metadata and runtime characteristics for each <literal>GatewaySender</literal>:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>GatewaySender Details</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="88.2691*"/>
<colspec colname="col_2" colwidth="294.2308*"/>
<thead>
<row>
<entry align="center" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.count</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of configured <literal>GatewaySender</literal> instances.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.alert-threshold</simpara></entry>
<entry align="left" valign="top"><simpara>Alert threshold (ms) for entries in this
<literal>GatewaySender</literal> instances queue.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.batch-conflation-enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether batch events are conflated
when sent.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.batch-size</simpara></entry>
<entry align="left" valign="top"><simpara>Size of the batches sent.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.batch-time-interval</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum time interval that can elapse before a batch
is sent.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.disk-store-name</simpara></entry>
<entry align="left" valign="top"><simpara>Name of the <literal>DiskStore</literal> used to overflow and persist
queued events.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.disk-synchronous</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether disk writes are synchronous
or asynchronous.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.dispatcher-threads</simpara></entry>
<entry align="left" valign="top"><simpara>Number of threads used to dispatch events.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.max-parallelism-for-replicated-region</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.max-queue-memory</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum amount of memory (MB) usable for this
<literal>GatewaySender</literal> instance&#8217;s queue.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.order-policy</simpara></entry>
<entry align="left" valign="top"><simpara>Order policy followed while dispatching the events
to <literal>GatewayReceiver</literal> instances.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.parallel</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether this <literal>GatewaySender</literal> is parallel
(higher throughput) or serial.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.paused</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether this <literal>GatewaySender</literal> is paused.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.persistent</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether this <literal>GatewaySender</literal> persists
queue events to disk.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.remote-distributed-system-id</simpara></entry>
<entry align="left" valign="top"><simpara>Identifier for the remote distributed system.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.running</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether this <literal>GatewaySender</literal>
is currently running.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.socket-buffer-size</simpara></entry>
<entry align="left" valign="top"><simpara>Configured buffer size for the socket connections
between this <literal>GatewaySender</literal> and the receiving <literal>GatewayReceiver</literal>.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>geode.gateway-sender.&lt;id&gt;.socket-read-timeout</simpara></entry>
<entry align="left" valign="top"><simpara>Amount of time (ms) that a socket read between this
sending <literal>GatewaySender</literal> and the receiving <literal>GatewayReceiver</literal> blocks.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
</chapter>
<chapter xml:id="geode-session">
<title>Spring Session</title>
<simpara>This chapter covers auto-configuration of Spring Session for Apache Geode to manage (HTTP) session state in a reliable
(consistent), highly available (replicated), and clustered manner.</simpara>
<simpara><link xl:href="https://spring.io/projects/spring-session">Spring Session</link> provides an API and several implementations for managing a user&#8217;s session
information. It has the ability to replace the <literal>javax.servlet.http.HttpSession</literal> in an application container-neutral way
and provide session IDs in HTTP headers to work with RESTful APIs.</simpara>
<simpara>Furthermore, Spring Session provides the ability to keep the <literal>HttpSession</literal> alive even when working with <literal>WebSockets</literal>
and reactive Spring WebFlux <literal>WebSessions</literal>.</simpara>
<simpara>A complete discussion of Spring Session is beyond the scope of this document. You can learn more by reading
the <link xl:href="https://docs.spring.io/spring-session/docs/current/reference/html5">docs</link> and reviewing the <link xl:href="https://docs.spring.io/spring-session/docs/current/reference/html5/#samples">samples</link>.</simpara>
<simpara>Spring Boot for Apache Geode provides auto-configuration support to configure Apache Geode as the session management
provider and store when <link xl:href="https://spring.io/projects/spring-session-data-geode">Spring Session for Apache Geode</link> is on your Spring Boot
application&#8217;s classpath.</simpara>
<tip>
<simpara>You can learn more about Spring Session for Apache Geode in the <link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/reference/html5">docs</link>.</simpara>
</tip>
<tip>
<simpara>See the corresponding sample <link xl:href="guides/caching-http-session.html.html">guide</link>
and {github-samples-url}/caching/http-session[code] to see Spring Session for Apache Geode in action.</simpara>
</tip>
<section xml:id="geode-session-configuration">
<title>Configuration</title>
<simpara>You need do nothing special to use Apache Geode as a Spring Session provider implementation, managing the (HTTP) session
state of your Spring Boot application.</simpara>
<simpara>To do so, include the appropriate Spring Session dependency on your Spring Boot application&#8217;s classpath:</simpara>
<example>
<title>Maven dependency declaration</title>
<programlisting language="xml" linenumbering="unnumbered">  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
    &lt;artifactId&gt;spring-session-data-geode&lt;/artifactId&gt;
    &lt;version&gt;{spring-session-data-geode-version}&lt;/version&gt;
  &lt;/dependency&gt;</programlisting>
</example>
<simpara>Alternatively, you may declare the provided <literal>spring-geode-starter-session</literal> dependency in your Spring Boot application
Maven POM (shown here) or Gradle build file:</simpara>
<example>
<title>Maven dependency declaration</title>
<programlisting language="xml" linenumbering="unnumbered">  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.geode&lt;/groupId&gt;
    &lt;artifactId&gt;spring-geode-starter-session&lt;/artifactId&gt;
    &lt;version&gt;{version}&lt;/version&gt;
  &lt;/dependency&gt;</programlisting>
</example>
<simpara>After declaring the required Spring Session dependency, you can begin your Spring Boot application as you normally would:</simpara>
<example>
<title>Spring Boot Application</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
public class MySpringBootApplication {

  public static void main(String[] args) {
    SpringApplication.run(MySpringBootApplication.class, args);
  }

  // ...
}</programlisting>
</example>
<simpara>You can then create application-specific Spring Web MVC <literal>Controllers</literal> to interact with the <literal>HttpSession</literal> as needed
by your application:</simpara>
<example>
<title>Spring Boot Application <literal>Controller</literal> using <literal>HttpSession</literal></title>
<programlisting language="java" linenumbering="unnumbered">@Controller
class MyApplicationController {

  @GetRequest("...")
  public String processGet(HttpSession session) {
    // interact with HttpSession
  }
}</programlisting>
</example>
<simpara>The <literal>HttpSession</literal> is replaced by a Spring managed <literal>Session</literal> that is stored in Apache Geode.</simpara>
</section>
<section xml:id="geode-session-configuration-custom">
<title>Custom Configuration</title>
<simpara>By default, Spring Boot for Apache Geode (SBDG) applies reasonable and sensible defaults when configuring Apache Geode
as the provider in Spring Session.</simpara>
<simpara>For instance, by default, SBDG sets the session expiration timeout to 30 minutes. It also uses a
<literal>ClientRegionShortcut.PROXY</literal> as the data management policy for the Apache Geode client Region that managing the (HTTP)
session state when the Spring Boot application is using a <literal>ClientCache</literal>, which it does
by <link linkend="geode-clientcache-applications">default</link>.</simpara>
<simpara>However, what if the defaults are not sufficient for your application requirements?</simpara>
<simpara>In that case, see the next section.</simpara>
<section xml:id="geode-session-configuration-custom-properties">
<title>Custom Configuration using Properties</title>
<simpara>Spring Session for Apache Geode publishes
<link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/reference/html5/#httpsession-gemfire-configuration-properties">well-known configuration properties</link>
for each of the various Spring Session configuration options when you use Apache Geode as the (HTTP) session state
management provider.</simpara>
<simpara>You can specify any of these properties in Spring Boot <literal>application.properties</literal> to adjust Spring Session&#8217;s configuration
when using Apache Geode.</simpara>
<simpara>In addition to the properties provided in and by Spring Session for Apache Geode, Spring Boot for Apache Geode also
recognizes and respects the <literal>spring.session.timeout</literal> property and the <literal>server.servlet.session.timeout</literal> property, as
discussed <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-session.html">the Spring Boot documentation</link>.</simpara>
<tip>
<simpara><literal>spring.session.data.gemfire.session.expiration.max-inactive-interval-seconds</literal> takes precedence over
<literal>spring.session.timeout</literal>, which takes precedence over <literal>server.servlet.session.timeout</literal> when any combination of
these properties have been simultaneously configured in the Spring <literal>Environment</literal> of your application.</simpara>
</tip>
</section>
<section xml:id="geode-session-configuration-custom-configurer">
<title>Custom Configuration using a Configurer</title>
<simpara>Spring Session for Apache Geode also provides the
<link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/api/org/springframework/session/data/gemfire/config/annotation/web/http/support/SpringSessionGemFireConfigurer.html"><literal>SpringSessionGemFireConfigurer</literal></link>
callback interface, which you can declare in your Spring <literal>ApplicationContext</literal> to programmatically control
the configuration of Spring Session when you use Apache Geode.</simpara>
<simpara>The <literal>SpringSessionGemFireConfigurer</literal>, when declared in the Spring <literal>ApplicationContext</literal>, takes precedence over any of
the Spring Session (for Apache Geode) configuration properties and effectively overrides them when both are present.</simpara>
<simpara>More information on using the <literal>SpringSessionGemFireConfigurer</literal> can be found in the
<link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/reference/html5/#httpsession-gemfire-configuration-configurer">docs</link>.</simpara>
</section>
</section>
<section xml:id="geode-session-disable">
<title>Disabling Session State Caching</title>
<simpara>There may be cases where you do not want your Spring Boot application to manage (HTTP) session state by using
Apache Geode.</simpara>
<simpara>In certain cases, you may be using another Spring Session provider implementation, such as Redis, to cache and manage
your Spring Boot application&#8217;s (HTTP) session state. In other cases, you do not want to use Spring Session to manage
your (HTTP) session state at all. Rather, you prefer to use your Web Server&#8217;s (such as Tomcat&#8217;s) built-in <literal>HttpSession</literal>
state management capabilities.</simpara>
<simpara>Either way, you can specifically call out your Spring Session provider implementation by using
the <literal>spring.session.store-type</literal> property in Spring Boot <literal>application.properties</literal>:</simpara>
<example>
<title>Use Redis as the Spring Session Provider Implementation</title>
<programlisting language="txt" linenumbering="unnumbered">#application.properties

spring.session.store-type=redis
...</programlisting>
</example>
<simpara>If you prefer not to use Spring Session to manage your Spring Boot application&#8217;s (HTTP) session state at all, you can do
the following:</simpara>
<example>
<title>Use Web Server Session State Management</title>
<programlisting language="txt" linenumbering="unnumbered">#application.properties

spring.session.store-type=none
...</programlisting>
</example>
<simpara>Again, see the Spring Boot <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-session.html">documentation</link> for more detail.</simpara>
<tip>
<simpara>You can include multiple provider implementations on the classpath of your Spring Boot application. For instance,
you might use Redis to cache your application&#8217;s (HTTP) session state while using Apache Geode as your application&#8217;s
transactional persistent store (System of Record).</simpara>
</tip>
<note>
<simpara>Spring Boot does not properly recognize <literal>spring.session.store-type=[gemfire|geode]</literal> even though
Spring Boot for Apache Geode is set up to handle either of these property values
(that is, either <literal>gemfire</literal> or <literal>geode</literal>).</simpara>
</note>
</section>
<section xml:id="geode-session-pcc">
<title>Using Spring Session with VMware Tanzu GemFire for VMs (PCC)</title>
<simpara>Whether you use Spring Session in a Spring Boot, Apache Geode <literal>ClientCache</literal> application to connect to an standalone,
externally managed cluster of Apache Geode servers or to connect to a cluster of servers in a VMware Tanzu GemFire for VMs service
instance managed by a VMware Tanzu Application Service (TAS) environment, the setup is the same.</simpara>
<simpara>Spring Session for Apache Geode expects there to be a cache Region in the cluster that can store and manage (HTTP)
session state when your Spring Boot application is a <literal>ClientCache</literal> application in the client/server topology.</simpara>
<simpara>By default, the cache Region used to store and manage (HTTP) session state is called <literal>ClusteredSpringSessions</literal>.</simpara>
<simpara>We recommend that you configure the cache Region name by using the well-known and documented property
in Spring Boot <literal>application.properties</literal>:</simpara>
<example>
<title>Using properties</title>
<programlisting language="properties" linenumbering="unnumbered">spring.session.data.gemfire.session.region.name=MySessions</programlisting>
</example>
<simpara>Alternatively, you can set the name of the cache Region used to store and manage (HTTP) session state by explicitly
declaring the <literal>@EnableGemFireHttpSession</literal> annotation on your main <literal>@SpringBootApplication</literal> class:</simpara>
<example>
<title>Using `@EnableGemfireHttpSession</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableGemFireHttpSession(regionName = "MySessions")
class MySpringBootSpringSessionApplication {
	// ...
}</programlisting>
</example>
<simpara>Once you decide on the cache Region name used to store and manage (HTTP) sessions, you must create the cache Region
in the cluster somehow.</simpara>
<simpara>On the client, doing so is simple, since SBDG&#8217;s auto-configuration automatically creates the client <literal>PROXY</literal> Region
that is used to send and receive (HTTP) session state between the client and server for you when either Spring Session
is on the application classpath (for example, <literal>spring-geode-starter-session</literal>) or you explicitly declare
the <literal>@EnableGemFireHttpSession</literal> annotation on your main <literal>@SpringBootApplication</literal> class.</simpara>
<simpara>However, on the server side, you currently have a couple of options.</simpara>
<simpara>First, you can manually create the cache Region by using Gfsh:</simpara>
<example>
<title>Create the Sessions Region using Gfsh</title>
<programlisting language="txt" linenumbering="unnumbered">gfsh&gt; create region --name=MySessions --type=PARTITION --entry-idle-time-expiration=1800
        --entry-idle-time-expiration-action=INVALIDATE</programlisting>
</example>
<simpara>You must create the cache Region with the appropriate name and an expiration policy.</simpara>
<simpara>In this case, we created an idle expiration policy with a timeout of <literal>1800</literal> seconds (30 minutes), after which the entry
(session object) is <literal>invalidated</literal>.</simpara>
<note>
<simpara>Session expiration is managed by the Expiration Policy set on the cache Region that is used to store session state.
The Servlet container&#8217;s (HTTP) session expiration configuration is not used, since Spring Session replaces the Servlet
container&#8217;s session management capabilities with its own, and Spring Session delegates this behavior to the individual
providers, such as Apache Geode.</simpara>
</note>
<simpara>Alternatively, you could send the definition for the cache Region from your Spring Boot <literal>ClientCache</literal> application
to the cluster by using the SBDG <link xl:href="https://docs.spring.io/spring-boot-data-geode-build/current/api//org/springframework/geode/config/annotation/EnableClusterAware.html"><literal>@EnableClusterAware</literal></link> annotation,
which is meta-annotated with SDG&#8217;s <literal>@EnableClusterConfiguration</literal> annotation:</simpara>
<example>
<title>Using <literal>@EnableClusterAware</literal></title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableClusterAware
class MySpringBootSpringSessionApacheGeodeApplication {
	// ...
}</programlisting>
</example>
<tip>
<simpara>See the <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableClusterConfiguration.html">Javadoc</link>
on the <literal>@EnableClusterConfiguration</literal> annotation and the <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-cluster">documentation</link>
for more detail.</simpara>
</tip>
<simpara>However, you cannot currently send expiration policy configuration metadata to the cluster. Therefore, you must manually
alter the cache Region to set the expiration policy:</simpara>
<example>
<title>Using Gfsh to Alter Region</title>
<programlisting language="txt" linenumbering="unnumbered">gfsh&gt; alter region --name=MySessions --entry-idle-time-expiration=1800
        --entry-idle-time-expiration-action=INVALIDATE</programlisting>
</example>
<simpara>Now your Spring Boot <literal>ClientCache</literal> application that uses Spring Session in a client/server topology is configured to
store and manage user (HTTP) session state in the cluster. This works for either standalone, externally managed
Apache Geode clusters or when you use PCC running in a VMware Tanzu Application Service (TAS) environment.</simpara>
</section>
</chapter>
<chapter xml:id="cloudfoundry">
<title>Pivotal CloudFoundry</title>
<note>
<simpara>As of the VMware, Inc. acquisition of Pivotal Software, Inc., Pivotal CloudFoundry (PCF) is now known as VMware Tanzu
Application Service (TAS) for VMs. Also, Pivotal Cloud Cache (PCC) has been rebranded as VMware Tanzu GemFire for VMS.
This documentation will eventually be updated to reflect the rebranding.</simpara>
</note>
<simpara>In most cases, when you deploy (that is, <literal>cf push</literal>) your Spring Boot applications to Pivotal CloudFoundry (PCF), you bind
your application to one or more instances of the Pivotal Cloud Cache (PCC) service.</simpara>
<simpara>In a nutshell, <link xl:href="https://pivotal.io/pivotal-cloud-cache">Pivotal Cloud Cache</link> (PCC) is a managed version of
<link xl:href="https://pivotal.io/pivotal-gemfire">VMware Tanzu GemFire</link> that runs in <link xl:href="https://pivotal.io/platform">Pivotal CloudFoundry</link> (PCF).
When running in or across cloud environments (such as AWS, Azure, GCP, or PWS), PCC with PCF offers several advantages
over trying to run and manage your own standalone Apache Geode clusters. It handles many of the infrastructure-related,
operational concerns so that you need not do so.</simpara>
<section xml:id="cloudfoundry-cloudcache-security-auth-runtime-user-configuration">
<title>Running a Spring Boot application as a specific user</title>
<simpara>By default, Spring Boot applications run as a <literal>cluster_operator</literal> role-based user in Pivotal CloudFoundry when the application
is bound to a Pivotal Cloud Cache service instance.</simpara>
<simpara>A <literal>cluster_operator</literal> has full system privileges (that is, authorization) to do whatever that user wishes to involving
the PCC service instance. A <literal>cluster_operator</literal> has read and write access to all the data, can modify the schema (for
example, create and destroy Regions, add and remove Indexes, change eviction or expiration policies, and so on), start
and stop servers in the PCC cluster, or even modify permissions.</simpara>
<sidebar>
<title>About cluster_operator as the default user</title>
<simpara>One of the reasons why Spring Boot applications default to running as a <literal>cluster_operator</literal> is to allow configuration
metadata to be sent from the client to the server. Enabling configuration metadata to be sent from the client to the
server is a useful development-time feature and is as simple as annotating your main <literal>@SpringBootApplication</literal> class
with the <literal>@EnableClusterConfiguration</literal> annotation:</simpara>
<example>
<title>Using <literal>@EnableClusterConfiguration</literal></title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableClusterConfiguration(useHttp = true)
class SpringBootApacheGeodeClientCacheApplication {  }</programlisting>
</example>
<simpara>With <literal>@EnableClusterConfiguration</literal>, Region and OQL Index configuration metadata that is defined on the client can be
sent to servers in the PCC cluster. Apache Geode requires matching Regions by name on both the client and the servers
in order for clients to send and receive data to and from the cluster.</simpara>
<simpara>For example, when you declare the Region where an application entity is persisted by using the <literal>@Region</literal> mapping
annotation and declare the <literal>@EnableEntityDefinedRegions</literal> annotation on the main <literal>@SpringBootApplication</literal> class
in conjunction with the <literal>@EnableClusterConfiguration</literal> annotation, not only does SBDG create the required client Region,
but it also sends the configuration metadata for this Region to the servers in the cluster to create the matching,
required server Region, where the data for your application entity is managed.</simpara>
</sidebar>
<simpara>However&#8230;&#8203;</simpara>
<blockquote>
<simpara>With great power comes great responsibility. - Uncle Ben</simpara>
</blockquote>
<simpara>Not all Spring Boot applications using PCC need to change the schema or even modify data. Rather, certain applications
may need only read access. Therefore, it is ideal to be able to configure your Spring Boot applications to run with
a different user at runtime other than the auto-configured <literal>cluster_operator</literal>, by default.</simpara>
<simpara>A prerequisite for running a Spring Boot application in PCC with a specific user is to create a user with restricted
permissions by using Pivotal CloudFoundry AppsManager while provisioning the PCC service instance to which the Spring Boot
application is bound.</simpara>
<simpara>Configuration metadata for the PCC service instance might appear as follows:</simpara>
<example>
<title>Pivotal Cloud Cache configuration metadata</title>
<programlisting language="json" linenumbering="unnumbered">{
  "p-cloudcache":[{
    "credentials": {
      "distributed_system_id": "0",
      "locators": [ "localhost[55221]" ],
      "urls": {
        "gfsh": "https://cloudcache-12345.services.cf.pws.com/gemfire/v1",
        "pulse": "https://cloudcache-12345.services.cf.pws.com/pulse"
      },
      "users": [{
        "password": "*****",
        "roles": [ "cluster_operator" ],
        "username": "cluster_operator_user"
      }, {
        "password": "*****",
        "roles": [ "developer" ],
        "username": "developer_user"
      }, {
        "password": "*****",
        "roles": [ "read-only-user" ],
        "username": "guest"
      }],
      "wan": {
        "sender_credentials": {
          "active": {
            "password": "*****",
            "username": "gateway-sender-user"
          }
        }
      }
    },
    "name": "jblum-pcc",
    "plan": "small",
    "tags": [ "gemfire", "cloudcache", "database", "pivotal" ]
  }]
}</programlisting>
</example>
<simpara>In the PCC service instance configuration metadata shown in the preceding example, we see a <literal>guest</literal> user with
the <literal>read-only-user</literal> role. If the <literal>read-only-user</literal> role is properly configured with read-only permissions as the name
implies, we could configure our Spring Boot application to run as <literal>guest</literal> with read-only access:</simpara>
<example>
<title>Configuring a Spring Boot application to run as a specific user</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties for PCF when using PCC

spring.data.gemfire.security.username=guest</programlisting>
</example>
<tip>
<simpara>The <literal>spring.data.gemfire.security.username</literal> property corresponds directly to the SDG <literal>@EnableSecurity</literal> annotation&#8217;s
<literal>securityUsername</literal> attribute. See the
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSecurity.html#securityUsername--">Javadoc</link>
for more details.</simpara>
</tip>
<simpara>The <literal>spring.data.gemfire.security.username</literal> property is the same property used by Spring Data for Apache Geode (SDG) to
configure the runtime user of your Spring Data application when you connect to an externally managed Apache Geode
cluster.</simpara>
<simpara>In this case, SBDG uses the configured username to look up the authentication credentials of the user to set
the username and password used by the Spring Boot <literal>ClientCache</literal> application when connecting to PCC while running in PCF.</simpara>
<simpara>If the username is not valid, an <literal>IllegalStateException</literal> is thrown.</simpara>
<simpara>By using <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/#boot-features-profiles">Spring profiles</link>, it would be a simple matter to configure
the Spring Boot application to run with a different user depending on environment.</simpara>
<simpara>See the Pivotal Cloud Cache documentation on <link xl:href="https://docs.pivotal.io/p-cloud-cache/{pivotal-cloudcache-doc-version}/security.html">security</link> for configuring users with
assigned roles and permissions.</simpara>
<section xml:id="cloudfoundry-cloudcache-security-auth-autoconfiguration-override">
<title>Overriding Authentication Auto-configuration</title>
<simpara>It should be understood that auto-configuration for client authentication is available only for managed environments,
such as Pivotal CloudFoundry. When running in externally managed environments, you must explicitly set a username and password
to authenticate, as described in <xref linkend="geode-security-auth-clients-non-managed"/>.</simpara>
<simpara>To completely override the auto-configuration of client authentication, you can set both a username and a password:</simpara>
<example>
<title>Overriding Security Authentication Auto-configuration with explicit username and password</title>
<programlisting language="txt" linenumbering="unnumbered"># Spring Boot application.properties

spring.data.gemfire.security.username=MyUser
spring.data.gemfire.security.password=MyPassword</programlisting>
</example>
<simpara>In this case, SBDG&#8217;s auto-configuration for authentication is effectively disabled and security credentials are not
extracted from the environment.</simpara>
</section>
</section>
<section xml:id="cloudfoundry-cloudcache-serviceinstance-targeting">
<title>Targeting Specific Pivotal Cloud Cache Service Instances</title>
<simpara>It is possible to provision multiple instances of the Pivotal Cloud Cache service in your Pivotal CloudFoundry environment. You can then
bind multiple PCC service instances to your Spring Boot application.</simpara>
<simpara>However, Spring Boot for Apache Geode (SBDG) only auto-configures one PCC service instance for your Spring Boot
application. This does not mean that it is not possible to use multiple PCC service instances with your Spring Boot
application, just that SBDG only auto-configures one service instance for you.</simpara>
<simpara>You must select which PCC service instance your Spring Boot application automatically auto-configures for you when
you have multiple instances and want to target a specific PCC service instance to use.</simpara>
<simpara>To do so, declare the following SBDG property in Spring Boot <literal>application.properties</literal>:</simpara>
<example>
<title>Spring Boot application.properties targeting a specific PCC service instance by name</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot application.properties

spring.boot.data.gemfire.cloud.cloudfoundry.service.cloudcache.name=pccServiceInstanceTwo</programlisting>
</example>
<simpara>The <literal>spring.boot.data.gemfire.cloud.cloudfoundry.service.cloudcache.name</literal> property tells SBDG which PCC service instance
to auto-configure.</simpara>
<simpara>If the PCC service instance identified by the property does not exist, SBDG throws an <literal>IllegalStateException</literal>
stating the PCC service instance by name could not be found.</simpara>
<simpara>If you did not set the property and your Spring Boot application is bound to multiple PCC service instances,
SBDG auto-configures the first PCC service instance it finds by name, alphabetically.</simpara>
<simpara>If you did not set the property and no PCC service instance is found, SBDG logs a warning.</simpara>
</section>
<section xml:id="cloudfoundry-cloudcache-multiinstance-using">
<title>Using Multiple Pivotal Cloud Cache Service Instances</title>
<simpara>If you want to use multiple PCC service instances with your Spring Boot application, you need to configure multiple
connection <literal>Pools</literal> connected to each PCC service instance used by your Spring Boot application.</simpara>
<simpara>The configuration would be similar to the following:</simpara>
<example>
<title>Multiple Pivotal Cloud Cache Service Instance Configuration</title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@EnablePools(pools = {
  @EnablePool(name = "PccOne"),
  @EnablePool(name = "PccTwo"),
  ...,
  @EnablePool(name = "PccN")
})
class PccConfiguration {
  // ...
}</programlisting>
</example>
<simpara>You would then externalize the configuration for the individually declared <literal>Pools</literal> in Spring Boot
<literal>application.properties</literal>:</simpara>
<example>
<title>Configuring Locator-based Pool connections</title>
<programlisting language="properties" linenumbering="unnumbered"># Spring Boot `application.properties`

spring.data.gemfire.pool.pccone.locators=pccOneHost1[port1], pccOneHost2[port2], ..., pccOneHostN[portN]

spring.data.gemfire.pool.pcctwo.locators=pccTwoHost1[port1], pccTwoHost2[port2], ..., pccTwoHostN[portN]</programlisting>
</example>
<note>
<simpara>Though less common, you can also configure the <literal>Pool</literal> of connections to target specific servers in the cluster
by setting the <literal>spring.data.gemfire.pool.&lt;named-pool&gt;.severs</literal> property.</simpara>
</note>
<tip>
<simpara>Keep in mind that properties in Spring Boot <literal>application.properties</literal> can refer to other properties:
<literal>property=${otherProperty}</literal>. This lets you further externalize properties by using Java System properties
or environment variables.</simpara>
</tip>
<simpara>A client Region is then assigned the Pool of connections that are used to send data to and from the specific
PCC service instance (cluster):</simpara>
<example>
<title>Assigning a Pool to a client Region</title>
<programlisting language="java" linenumbering="unnumbered">@Configuration
class GeodeConfiguration {

  @Bean("Example")
  ClientRegionFactoryBean exampleRegion(GemFireCache gemfireCache,
      @Qualifier("PccTwo") Pool poolForPccTwo) {

    ClientRegionFactoryBean exampleRegion = new ClientRegionFactoryBean();

    exampleRegion.setCache(gemfireCache);
    exampleRegion.setPool(poolForPccTwo);
    exampleRegion.setShortcut(ClientRegionShortcut.PROXY);

    return exampleRegion;
  }
}</programlisting>
</example>
<simpara>You can configure as many Pools and client Regions as your application needs. Again, the <literal>Pool</literal> determines
the Pivotal Cloud Cache service instance and cluster in which the data for the client Region resides.</simpara>
<note>
<simpara>By default, SBDG configures all <literal>Pools</literal> declared in a Spring Boot <literal>ClientCache</literal> application to connect to
and use a single PCC service instance. This may be a targeted PCC service instance when you use the
<literal>spring.boot.data.gemfire.cloud.cloudfoundry.service.cloudcache.name</literal> property
as discussed <link linkend="cloudfoundry-cloudcache-multiinstance-using">earlier</link>.</simpara>
</note>
</section>
<section xml:id="cloudfoundry-geode">
<title>Hybrid Pivotal CloudFoundry and Apache Geode Spring Boot Applications</title>
<simpara>Sometimes, it is desirable to deploy (that is, <literal>cf push</literal>) and run your Spring Boot applications in Pivotal CloudFoundry
but still connect your Spring Boot applications to an externally managed, standalone Apache Geode cluster.</simpara>
<simpara>Spring Boot for Apache Geode (SBDG) makes this a non-event and honors its "<emphasis>little to no code or configuration changes
necessary</emphasis>" goal. Regardless of your runtime choice, it should just work!</simpara>
<simpara>To help guide you through this process, we cover the following topics:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install and Run PCFDev.</simpara>
</listitem>
<listitem>
<simpara>Start an Apache Geode cluster.</simpara>
</listitem>
<listitem>
<simpara>Create a User-Provided Service (CUPS).</simpara>
</listitem>
<listitem>
<simpara>Push and Bind a Spring Boot application.</simpara>
</listitem>
<listitem>
<simpara>Run the Spring Boot application.</simpara>
</listitem>
</orderedlist>
<section xml:id="cloudfoundry-geode-pcfdev">
<title>Running PCFDev</title>
<simpara>For this exercise, we use <link xl:href="https://docs.pivotal.io/pcf-dev/install-osx.html">PCF Dev</link>.</simpara>
<simpara>PCF Dev, much like PCF, is an elastic application runtime for deploying, running, and managing your Spring Boot
applications. However, it does so in the confines of your local development environment&#8201;&#8212;&#8201;that is, your workstation.</simpara>
<simpara>Additionally, PCF Dev provides several services, such as MySQL, Redis, and RabbitMQ. You Spring Boot application
can bind to and use these services to accomplish its tasks.</simpara>
<simpara>However, PCF Dev lacks the Pivotal Cloud Cache service that is available in PCF. This is actually ideal for this exercise since
we are trying to build and run Spring Boot applications in a PCF environment but connect to an externally managed,
standalone Apache Geode cluster.</simpara>
<simpara>As a prerequisite, you need to follow the steps outlined in the
<link xl:href="https://pivotal.io/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry-dev/introduction">tutorial</link>
to get PCF Dev set up and running on your workstation.</simpara>
<simpara>To run PCF Dev, execute the following <literal>cf</literal> CLI command, replacing the path to the TGZ file with the file you acquired
from the <link xl:href="https://network.pivotal.io/products/pcfdev">download</link>:</simpara>
<example>
<title>Start PCF Dev</title>
<programlisting language="txt" linenumbering="unnumbered">$ cf dev start -f ~/Downloads/Pivotal/CloudFoundry/Dev/pcfdev-v1.2.0-darwin.tgz</programlisting>
</example>
<simpara>You should see output similar to the following:</simpara>
<example>
<title>Running PCF Dev</title>
<programlisting language="txt" linenumbering="unnumbered">Downloading Network Helper...
Progress: |====================&gt;| 100.0%
Installing cfdevd network helper (requires administrator privileges)...
Password:
Setting up IP aliases for the BOSH Director &amp; CF Router (requires administrator privileges)
Downloading Resources...
Progress: |====================&gt;| 100.0%
Setting State...
WARNING: PCF Dev requires 8192 MB of RAM to run. This machine may not have enough free RAM.
Creating the VM...
Starting VPNKit...
Waiting for the VM...
Deploying the BOSH Director...

Deploying PAS...
  Done (14m34s)
Deploying Apps-Manager...
  Done (1m41s)

 	 ██████╗  ██████╗███████╗██████╗ ███████╗██╗   ██╗
 	 ██╔══██╗██╔════╝██╔════╝██╔══██╗██╔════╝██║   ██║
 	 ██████╔╝██║     █████╗  ██║  ██║█████╗  ██║   ██║
 	 ██╔═══╝ ██║     ██╔══╝  ██║  ██║██╔══╝  ╚██╗ ██╔╝
 	 ██║     ╚██████╗██║     ██████╔╝███████╗ ╚████╔╝
 	 ╚═╝      ╚═════╝╚═╝     ╚═════╝ ╚══════╝  ╚═══╝
 	             is now running!

 	To begin using PCF Dev, please run:
 	    cf login -a https://api.dev.cfdev.sh --skip-ssl-validation

 	Admin user =&gt; Email: admin / Password: admin
 	Regular user =&gt; Email: user / Password: pass

 	To access Apps Manager, navigate here: https://apps.dev.cfdev.sh

 	To deploy a particular service, please run:
 	    cf dev deploy-service &lt;service-name&gt; [Available services: mysql,redis,rabbitmq,scs]</programlisting>
</example>
<simpara>To use the <literal>cf</literal> CLI tool, you must login to the PCF Dev environment:</simpara>
<example>
<title>Login to PCF Dev using <literal>cf</literal> CLI</title>
<programlisting language="txt" linenumbering="unnumbered">$ cf login -a https://api.dev.cfdev.sh --skip-ssl-validation</programlisting>
</example>
<simpara>You can also access the <link xl:href="https://apps.dev.cfdev.sh/">PCF Dev Apps Manager</link> tool from your Web browser at the following URL:</simpara>
<simpara><link xl:href="https://apps.dev.cfdev.sh/">apps.dev.cfdev.sh/</link></simpara>
<simpara>Apps Manager provides a nice UI to manage your org, space, services and apps. It lets you push and update apps,
create services, bind apps to the services, and start and stop your deployed applications, among many other things.</simpara>
</section>
<section xml:id="cloudfoundry-geode-cluster">
<title>Running an Apache Geode Cluster</title>
<simpara>Now that PCF Dev is set up and running, you need to start an external, standalone Apache Geode cluster to which our
Spring Boot application connects and uses to manage its data.</simpara>
<simpara>You need to install a <link xl:href="https://geode.apache.org//releases/">distribution</link> of Apache Geode on your computer. Then you must
set the <literal>$GEODE</literal> environment variable. It is also convenient to add <literal>$GEODE/bin</literal> to your system <literal>$PATH</literal>.</simpara>
<simpara>Afterward, you can launch the Geode Shell (<emphasis>Gfsh</emphasis>) tool:</simpara>
<example>
<title>Running Gfsh</title>
<programlisting language="txt" linenumbering="unnumbered">$ echo $GEODE
/Users/jblum/pivdev/apache-geode-1.6.0

$ gfsh
    _________________________     __
   / _____/ ______/ ______/ /____/ /
  / /  __/ /___  /_____  / _____  /
 / /__/ / ____/  _____/ / /    / /
/______/_/      /______/_/    /_/    1.6.0

Monitor and Manage Apache Geode
gfsh&gt;</programlisting>
</example>
<simpara>We have provided the Gfsh shell script that you can use to start the Apache Geode cluster:</simpara>
<example>
<title>Gfsh shell script to start the Apache Geode cluster</title>
<programlisting language="txt" linenumbering="unnumbered">#!/bin/gfsh
# Gfsh shell script to configure and bootstrap an Apache Geode cluster.

start locator --name=LocatorOne --log-level=config --classpath=@project-dir@/apache-geode-extensions/build/libs/apache-geode-extensions-@project-version@.jar --J=-Dgemfire.security-manager=org.springframework.geode.security.TestSecurityManager --J=-Dgemfire.http-service-port=8080

start server --name=ServerOne --log-level=config --user=admin --password=admin --classpath=@project-dir@/apache-geode-extensions/build/libs/apache-geode-extensions-@project-version@.jar</programlisting>
</example>
<simpara>The <literal>start-cluster.gfsh</literal> shell script starts one Geode Locator and one Geode server.</simpara>
<simpara>A Locator is used by clients to discover and connect to servers in a cluster to manage its data. A Locator is also used
by new servers that join a cluster as peer members, which lets the cluster be elastically scaled out (or scaled down,
as needed). A Geode server stores the data for the application.</simpara>
<simpara>You can start as many Locators or servers as necessary to meet the availability and load demands of your application.
The more Locators and servers your cluster has, the more resilient it is to failure. However, you should size your
cluster accordingly, based on your application&#8217;s needs, since there is overhead relative to the cluster size.</simpara>
<simpara>You see output similar to the following when starting the Locator and server:</simpara>
<example>
<title>Starting the Apache Geode cluster</title>
<programlisting language="txt" linenumbering="unnumbered">gfsh&gt;start locator --name=LocatorOne --log-level=config --classpath=/Users/jblum/pivdev/spring-boot-data-geode/apache-geode-extensions/build/libs/apache-geode-extensions-1.1.0.BUILD-SNAPSHOT.jar --J=-Dgemfire.security-manager=org.springframework.geode.security.TestSecurityManager --J=-Dgemfire.http-service-port=8080
Starting a Geode Locator in /Users/jblum/pivdev/lab/LocatorOne...
..
Locator in /Users/jblum/pivdev/lab/LocatorOne on 10.99.199.24[10334] as LocatorOne is currently online.
Process ID: 14358
Uptime: 1 minute 1 second
Geode Version: 1.6.0
Java Version: 1.8.0_192
Log File: /Users/jblum/pivdev/lab/LocatorOne/LocatorOne.log
JVM Arguments: -Dgemfire.enable-cluster-configuration=true -Dgemfire.load-cluster-configuration-from-dir=false -Dgemfire.log-level=config -Dgemfire.security-manager=org.springframework.geode.security.TestSecurityManager -Dgemfire.http-service-port=8080 -Dgemfire.launcher.registerSignalHandlers=true -Djava.awt.headless=true -Dsun.rmi.dgc.server.gcInterval=9223372036854775806
Class-Path: /Users/jblum/pivdev/apache-geode-1.6.0/lib/geode-core-1.6.0.jar:/Users/jblum/pivdev/spring-boot-data-geode/apache-geode-extensions/build/libs/apache-geode-extensions-1.1.0.BUILD-SNAPSHOT.jar:/Users/jblum/pivdev/apache-geode-1.6.0/lib/geode-dependencies.jar

Security Manager is enabled - unable to auto-connect. Please use "connect --locator=10.99.199.24[10334] --user --password" to connect Gfsh to the locator.

Authentication required to connect to the Manager.

gfsh&gt;connect
Connecting to Locator at [host=localhost, port=10334] ..
Connecting to Manager at [host=10.99.199.24, port=1099] ..
user: admin
password: *****
Successfully connected to: [host=10.99.199.24, port=1099]

gfsh&gt;start server --name=ServerOne --log-level=config --user=admin --password=admin --classpath=/Users/jblum/pivdev/spring-boot-data-geode/apache-geode-extensions/build/libs/apache-geode-extensions-1.1.0.BUILD-SNAPSHOT.jar
Starting a Geode Server in /Users/jblum/pivdev/lab/ServerOne...
....
Server in /Users/jblum/pivdev/lab/ServerOne on 10.99.199.24[40404] as ServerOne is currently online.
Process ID: 14401
Uptime: 3 seconds
Geode Version: 1.6.0
Java Version: 1.8.0_192
Log File: /Users/jblum/pivdev/lab/ServerOne/ServerOne.log
JVM Arguments: -Dgemfire.default.locators=10.99.199.24[10334] -Dgemfire.security-username=admin -Dgemfire.start-dev-rest-api=false -Dgemfire.security-password=******** -Dgemfire.use-cluster-configuration=true -Dgemfire.log-level=config -XX:OnOutOfMemoryError=kill -KILL %p -Dgemfire.launcher.registerSignalHandlers=true -Djava.awt.headless=true -Dsun.rmi.dgc.server.gcInterval=9223372036854775806
Class-Path: /Users/jblum/pivdev/apache-geode-1.6.0/lib/geode-core-1.6.0.jar:/Users/jblum/pivdev/spring-boot-data-geode/apache-geode-extensions/build/libs/apache-geode-extensions-1.1.0.BUILD-SNAPSHOT.jar:/Users/jblum/pivdev/apache-geode-1.6.0/lib/geode-dependencies.jar</programlisting>
</example>
<simpara>Once the cluster has been started successfully, you can list the members:</simpara>
<example>
<title>List members of the cluster</title>
<programlisting language="txt" linenumbering="unnumbered">gfsh&gt;list members
   Name    | Id
---------- | -----------------------------------------------------------------
LocatorOne | 10.99.199.24(LocatorOne:14358:locator)&lt;ec&gt;&lt;v0&gt;:1024 [Coordinator]
ServerOne  | 10.99.199.24(ServerOne:14401)&lt;v1&gt;:1025</programlisting>
</example>
<simpara>Currently, we have not defined any Regions in which to store our application&#8217;s data:</simpara>
<example>
<title>No Application Regions</title>
<programlisting language="txt" linenumbering="unnumbered">gfsh&gt;list regions
No Regions Found</programlisting>
</example>
<simpara>This is deliberate, since we are going to let the application drive its schema structure, both on the client
(application) as well as on the server-side (cluster). We cover this in more detail later in this chapter.</simpara>
</section>
<section xml:id="cloudfoundry-geode-cups">
<title>Creating a User-Provided Service</title>
<simpara>Now that we have PCF Dev and a small Apache Geode cluster up and running, it is time to create a user-provided service
to the external, standalone Apache Geode cluster that we started in <link linkend="cloudfoundry-geode-cluster">step 2</link>.</simpara>
<simpara>As mentioned, PCF Dev offers MySQL, Redis and RabbitMQ services (among others). However, to use Apache Geode in the same
capacity as you would Pivotal Cloud Cache when running in a production-grade PCF environment, you need to create a user-provided
service for the standalone Apache Geode cluster.</simpara>
<simpara>To do so, run the following <literal>cf</literal> CLI command:</simpara>
<example>
<title>cf cups command</title>
<programlisting language="txt" linenumbering="unnumbered">$ cf cups &lt;service-name&gt; -t "gemfire, cloudcache, database, pivotal" -p '&lt;service-credentials-in-json&gt;'</programlisting>
</example>
<note>
<simpara>It is important that you specify the tags (<literal>gemfire</literal>, <literal>cloudcache</literal>, <literal>database</literal>, <literal>pivotal</literal>) exactly as shown
in the preceding <literal>cf</literal> CLI command.</simpara>
</note>
<simpara>The argument passed to the <literal>-p</literal> command-line option is a JSON document (object) containing the credentials for our
user-provided service.</simpara>
<simpara>The JSON object is as follows:</simpara>
<example>
<title>User-Provided Service Crendentials JSON</title>
<programlisting language="json" linenumbering="unnumbered">{
	"locators": [ "&lt;hostname&gt;[&lt;port&gt;]" ],
	"urls": { "gfsh": "https://&lt;hostname&gt;/gemfire/v1" },
	"users": [{ "password": "&lt;password&gt;", "roles": [ "cluster_operator" ], "username": "&lt;username&gt;" }]
}</programlisting>
</example>
<simpara>The complete <literal>cf</literal> CLI command would be similar to the following:</simpara>
<example>
<title>Example <literal>cf cups</literal> command</title>
<programlisting language="txt" linenumbering="unnumbered">cf cups apacheGeodeService -t "gemfire, cloudcache, database, pivotal" \
  -p '{ "locators": [ "10.99.199.24[10334]" ], "urls": { "gfsh": "https://10.99.199.24/gemfire/v1" }, "users": [{ "password": "admin", "roles": [ "cluster_operator" ], "username": "admin" }] }'</programlisting>
</example>
<simpara>We replaced the <literal>&lt;hostname&gt;</literal> placeholder with the IP address of our standalone Apache Geode Locator. You can find
the IP address in the Gfsh <literal>start locator</literal> command output shown in the preceding example.</simpara>
<simpara>Additionally, the <literal>&lt;port&gt;</literal> placeholder has been replaced with the default Locator port, <literal>10334</literal>,</simpara>
<simpara>Finally, we set the <literal>username</literal> and <literal>password</literal> accordingly.</simpara>
<tip>
<simpara>Spring Boot for Apache Geode (SBDG) provides template files in the <literal>{docs-dir}/src/main/resources</literal> directory.</simpara>
</tip>
<simpara>Once the service has been created, you can query the details of the service from the <literal>cf</literal> CLI:</simpara>
<example>
<title>Query the CF Dev Services</title>
<programlisting language="txt" linenumbering="unnumbered">$ cf services
Getting services in org cfdev-org / space cfdev-space as admin...

name                 service         plan   bound apps      last operation   broker
apacheGeodeService   user-provided          boot-pcc-demo


$ cf service apacheGeodeService
Showing info of service apacheGeodeService in org cfdev-org / space cfdev-space as admin...

name:      apacheGeodeService
service:   user-provided
tags:      gemfire, cloudcache, database, pivotal

bound apps:
name            binding name   status             message
boot-pcc-demo                  create succeeded</programlisting>
</example>
<simpara>You can also view the "apacheGeodeService" from Apps Manager, starting from the <literal>Service</literal> tab in your org and space:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/pcfdev-appsmanager-org-space-services.png"/>
</imageobject>
<textobject><phrase>pcfdev appsmanager org space services</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>By clicking on the "apacheGeodeService" service entry in the table, you can get all the service details, such as
the bound apps:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/pcfdev-appsmanager-org-space-service-boundapps.png"/>
</imageobject>
<textobject><phrase>pcfdev appsmanager org space service boundapps</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>You can also view and set the configuration:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/pcfdev-appsmanager-org-space-service-configuration.png"/>
</imageobject>
<textobject><phrase>pcfdev appsmanager org space service configuration</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This brief section did not cover all the capabilities of the Apps Manager. We suggest you explore its UI to see all
that is possible.</simpara>
<tip>
<simpara>You can learn more about CUPS in the
<link xl:href="https://docs.pivotal.io/platform/application-service/2-11/devguide/services/user-provided.html">PCF documentation</link>.</simpara>
</tip>
</section>
<section xml:id="cloudfoundry-geode-app">
<title>Push and Bind a Spring Boot application</title>
<simpara>Now it is time to push a Spring Boot application to PCF Dev and bind the application to the <literal>apacheGeodeService</literal>.</simpara>
<simpara>Any Spring Boot <literal>ClientCache</literal> application that uses SBDG works for this purpose. For this example, we use the
<link xl:href="https://github.com/jxblum/PCCDemo/tree/sbdg-doc-ref">PCCDemo</link> application, which is available in GitHub.</simpara>
<simpara>After cloning the project to your computer, you must run a build to produce the artifact to push to PCF Dev:</simpara>
<example>
<title>Build the PCCDemo application</title>
<programlisting language="txt" linenumbering="unnumbered">$ mvn clean package</programlisting>
</example>
<simpara>Then you can push the application to PCF Dev with the following <literal>cf</literal> CLI command:</simpara>
<example>
<title>Push the application to PCF Dev</title>
<programlisting language="txt" linenumbering="unnumbered">$ cf push boot-pcc-demo -u none --no-start -p target/client-0.0.1-SNAPSHOT.jar</programlisting>
</example>
<simpara>Once the application has been successfully deployed to PCF Dev, you can get the application details:</simpara>
<example>
<title>Get details for the deployed application</title>
<programlisting language="txt" linenumbering="unnumbered">$ cf apps
Getting apps in org cfdev-org / space cfdev-space as admin...
OK

name            requested state   instances   memory   disk   urls
boot-pcc-demo   stopped           0/1         768M     1G     boot-pcc-demo.dev.cfdev.sh


$ cf app boot-pcc-demo
Showing health and status for app boot-pcc-demo in org cfdev-org / space cfdev-space as admin...

name:              boot-pcc-demo
requested state:   stopped
routes:            boot-pcc-demo.dev.cfdev.sh
last uploaded:     Tue 02 Jul 00:34:09 PDT 2019
stack:             cflinuxfs3
buildpacks:        https://github.com/cloudfoundry/java-buildpack.git

type:           web
instances:      0/1
memory usage:   768M
     state   since                  cpu    memory   disk     details
#0   down    2019-07-02T21:48:25Z   0.0%   0 of 0   0 of 0

type:           task
instances:      0/0
memory usage:   256M

There are no running instances of this process.</programlisting>
</example>
<simpara>You can bind the PPCDemo application to the <literal>apacheGeodeService</literal> using the <literal>cf</literal> CLI command:</simpara>
<example>
<title>Bind application to <literal>apacheGeodeService</literal> using CLI</title>
<programlisting language="txt" linenumbering="unnumbered">cf bind-service boot-pcc-demo apacheGeodeService</programlisting>
</example>
<simpara>Alternatively, you can create a YAML file (<literal>manifest.yml</literal> in <literal>src/main/resources</literal>) that contains
the deployment descriptor:</simpara>
<example>
<title>Example YAML deployment descriptor</title>
<programlisting language="yml" linenumbering="unnumbered">\---
applications:
  - name: boot-pcc-demo
    memory: 768M
    instances: 1
    path: ./target/client-0.0.1-SNAPSHOT.jar
    services:
      - apacheGeodeService
    buildpacks:
      - https://github.com/cloudfoundry/java-buildpack.git</programlisting>
</example>
<simpara>You can also use Apps Manager to view application details and bind and unbind additional services.
Start by navigating to the <literal>App</literal> tab under your org and space:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/pcfdev-appsmanager-org-space-apps.png"/>
</imageobject>
<textobject><phrase>pcfdev appsmanager org space apps</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>From there, you can click on the desired application and navigate to the <literal>Overview</literal>:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/pcfdev-appsmanager-org-space-app-overview.png"/>
</imageobject>
<textobject><phrase>pcfdev appsmanager org space app overview</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>You can also review the application <literal>Settings</literal>. Specifically, we are looking at the configuration of the applicatinon
once it is bound to the <literal>apacheGeodeService</literal>, as seen in the <literal>VCAP_SERVICES</literal> environment variable:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/pcfdev-appsmanager-org-space-app-settings-envvars.png"/>
</imageobject>
<textobject><phrase>pcfdev appsmanager org space app settings envvars</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This JSON document structure is not unlike the configuration used to bind your Spring Boot <literal>ClientCache</literal> application
to the Pivotal Cloud Cache service when deploying the same application to Pivotal CloudFoundry. This is actually key if you want to
minimize the amount of boilerplate code and configuration changes when you migrate between different CloudFoundry
environments, even <link xl:href="https://www.cloudfoundry.org/">Open Source CloudFoundry</link>.</simpara>
<simpara>Again, SBDG&#8217;s goal is to simply the effort for you to build, run, and manage your application, in whatever context
your application lands, even if it changes later. If you follow the steps in this documentation, you can realize
that goal.</simpara>
</section>
<section xml:id="cloudfoundry-geode-app-run">
<title>Running the Spring Boot application</title>
<simpara>All that is left to do now is run the application.</simpara>
<simpara>You can start the PCCDemo application from the <literal>cf</literal> CLI by using the following command:</simpara>
<example>
<title>Start the Spring Boot application</title>
<programlisting language="txt" linenumbering="unnumbered">$ cf start boot-pcc-demo</programlisting>
</example>
<simpara>Alternatively, you can also start the application from Apps Manager. This is convenient, since you can then tail
and monitor the application log file.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/pcfdev-appsmanager-org-space-app-logs.png"/>
</imageobject>
<textobject><phrase>pcfdev appsmanager org space app logs</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Once the application has started, you can click the <link xl:href="https://boot-pcc-demo.dev.cfdev.sh/">VIEW APP</link> link
in the upper right corner of the <literal>APP</literal> screen.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/PCCDemo-app-screenshot.png"/>
</imageobject>
<textobject><phrase>PCCDemo app screenshot</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>You can navigate to any of the application Web Service, Controller endpoints.  For example, if you know the ISBN
of a book, you can access it from your Web browser:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/PCCDemo-app-book-by-isbn-screenshot.png"/>
</imageobject>
<textobject><phrase>PCCDemo app book by isbn screenshot</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>You can also access the same data from the Gfsh command-line tool. However, the first thing to observe is that our
application informed the cluster that it needed a Region called <literal>Books</literal>:</simpara>
<example>
<title>Books Region</title>
<programlisting language="txt" linenumbering="unnumbered">gfsh&gt;list regions
List of regions
---------------
Books


gfsh&gt;describe region --name=/Books
..........................................................
Name            : Books
Data Policy     : partition
Hosting Members : ServerOne

Non-Default Attributes Shared By Hosting Members

 Type  |    Name     | Value
------ | ----------- | ---------
Region | size        | 1
       | data-policy | PARTITION</programlisting>
</example>
<simpara>The PCCDemo app creates fake data on startup, which we can query in Gfsh:</simpara>
<example>
<title>Query Books</title>
<programlisting language="txt" linenumbering="unnumbered">gfsh&gt;query --query="SELECT book.isbn, book.title FROM /Books book"
Result : true
Limit  : 100
Rows   : 1

    isbn      | title
------------- | ---------------------
1235432BMF342 | The Torment of Others</programlisting>
</example>
</section>
</section>
<section xml:id="cloudfoundry-geode-summary">
<title>Summary</title>
<simpara>The ability to deploy Spring Boot, Apache Geode <literal>ClientCache</literal> applications to Pivotal CloudFoundry yet connect your application to
an externally managed, standalone Apache Geode cluster is powerful.</simpara>
<simpara>Indeed, this is a useful arrangement and stepping stone for many users as they begin their journey towards Cloud-Native
platforms such as Pivotal CloudFoundry and using services such as Pivotal Cloud Cache.</simpara>
<simpara>Later, when you need to work with real (rather than sample) applications, you can migrate your Spring Boot applications
to a fully managed and production-grade Pivotal CloudFoundry environment, and SBDG figures out what to do, leaving you to focus
entirely on your application.</simpara>
</section>
</chapter>
<chapter xml:id="geode-docker">
<title>Docker</title>
<simpara>The state of modern software application development is moving towards <link xl:href="https://www.docker.com/resources/what-container">containerization</link>.
Containers offer a controlled environment to predictably build (compile, configure and package), run, and manage your
applications in a reliable and repeatable manner, regardless of context. In many situations, the intrinsic benefit of
using containers is obvious.</simpara>
<simpara>Understandably, <link xl:href="https://www.docker.com/">Docker&#8217;s</link> popularity took off like wildfire, given its highly powerful and simplified
model for creating, using and managing containers to run packaged applications.</simpara>
<simpara>Docker&#8217;s ecosystem is also quite impressive, with the advent of <link xl:href="https://www.testcontainers.org">Testcontainers</link> and Spring Boot&#8217;s
now <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#building-docker-images">dedicated support</link> to create packaged
Spring Boot applications in <link xl:href="https://docs.docker.com/get-started/overview/#docker-objects">Docker images</link> that are then later
run in a Docker container.</simpara>
<tip>
<simpara>See also <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/deployment.html#containers-deployment"><quote>Deploying to Containers</quote></link> to learn more.</simpara>
</tip>
<simpara>Apache Geode can also run in a controlled, containerized environment. The goal of this chapter is to get you started
running Apache Geode in a container and interfacing to a containerized Apache Geode cluster from your Spring Boot,
Apache Geode client applications.</simpara>
<simpara>This chapter does not cover how to run your Spring Boot, Apache Geode client applications in a container, since that is
already covered by Spring Boot (again, see the Spring Boot documentation for
<link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#building-docker-images">Docker images</link>
and <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/deployment.html#containers-deployment">container deployment</link>,
along with Docker&#8217;s <link xl:href="https://docs.docker.com/get-started/overview/">documentation</link>).
Instead, our focus is on how to run an Apache Geode cluster in a container and connect to it from a Spring Boot,
Apache Geode client application, regardless of whether the application runs in a container or not.</simpara>
<section xml:id="geode-docker-image">
<title>Acquiring the Apache Geode Docker Image</title>
<simpara>To run an Apache Geode cluster inside a Docker container, you must first acquire the Docker image. You can get
the Apache Geode Docker image from <link xl:href="https://hub.docker.com/r/apachegeode/geode/">Docker Hub</link>.</simpara>
<simpara>While Apache Geode&#8217;s <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}">official documentation</link> is less than clear on how to use Apache Geode in Docker,
we find a bit of relief in the <link xl:href="https://cwiki.apache.org/confluence/display/GEODE/How+to+use+Geode+on+Docker">Wiki</link>. However, for a complete
and comprehensive write up, see the instructions in
the <link xl:href="https://github.com/markito/geode-docker#building-the-container-image">README</link>
from this <link xl:href="https://github.com/markito/geode-docker">GitHub Repo</link>.</simpara>
<note>
<simpara>You must have <link xl:href="https://docs.docker.com/get-docker">Docker</link> installed on your computer to complete the following steps.</simpara>
</note>
<simpara>Effectively, the high-level steps are as follows:</simpara>
<simpara>1) Acquire the Apache Geode Docker image from Docker Hub by using the <literal>docker pull</literal> command (shown with typical output)
from the command-line:</simpara>
<example>
<title>Download/Install the Apache Geode Docker Image</title>
<programlisting language="text" linenumbering="unnumbered">$ docker pull apachegeode/geode
Using default tag: latest
latest: Pulling from apachegeode/geode
Digest: sha256:6a6218f22a2895bb706175727c7d76f654f9162acac22b2d950d09a2649f9cf4
Status: Image is up to date for apachegeode/geode:latest
docker.io/apachegeode/geode:latest</programlisting>
</example>
<simpara>Instead of pulling from the <literal>nightly</literal> tag as suggested, the Spring team highly recommends that you pull from
the <literal>latest</literal> tag, which pulls a stable, production-ready Apache Geode Docker image based on the latest Apache Geode
GA version.</simpara>
<simpara>2) Verify that the Apache Geode Docker image was downloaded and installed successfully:</simpara>
<informalexample>
<programlisting language="text" linenumbering="unnumbered">$ docker image ls
REPOSITORY                       TAG                          IMAGE ID            CREATED             SIZE
apachegeode/geode                latest                       a2e210950712        2 months ago        224MB
cloudfoundry/run                 base-cnb                     3a7d172559c2        8 weeks ago         71.2MB
open-liberty                     19.0.0.9-webProfile8         dece75feff1a        3 months ago        364MB
tomee                            11-jre-8.0.0-M3-webprofile   0d03e4d395e6        3 months ago        678MB
...</programlisting>
</informalexample>
<simpara>Now you are ready to run Apache Geode in a Docker container.</simpara>
</section>
<section xml:id="geode-docker-container">
<title>Running Apache Geode in a Docker Container</title>
<simpara>Now that you have acquired the Apache Geode Docker image, you can run Apache Geode in a Docker container.
Use the following <literal>docker run</literal> command to start Apache Geode in a Docker container:</simpara>
<example>
<title>Start the Apache Geode Docker Container</title>
<programlisting language="text" linenumbering="unnumbered">$ docker run -it -p 10334:10334 -p 40404:40404 -p 1099:1099 -p 7070:7070 -p 7575:7575 apachegeode/geode
    _________________________     __
   / _____/ ______/ ______/ /____/ /
  / /  __/ /___  /_____  / _____  /
 / /__/ / ____/  _____/ / /    / /
/______/_/      /______/_/    /_/    1.12.0

Monitor and Manage Apache Geode
gfsh&gt;</programlisting>
</example>
<simpara>Since the Apache Geode Docker container was started in interactive mode, you must open a separate command-line shell
to verify that the Apache Geode Docker container is in fact running:</simpara>
<example>
<title>Verify the Apache Geode Docker Container is Running</title>
<programlisting language="text" linenumbering="unnumbered">$ docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                                                                                                                                  NAMES
3b30b9ffc5dc        apachegeode/geode   "gfsh"              44 seconds ago      Up 43 seconds       0.0.0.0:1099-&gt;1099/tcp, 0.0.0.0:7070-&gt;7070/tcp, 0.0.0.0:7575-&gt;7575/tcp, 0.0.0.0:10334-&gt;10334/tcp, 0.0.0.0:40404-&gt;40404/tcp, 8080/tcp   awesome_khorana</programlisting>
</example>
<simpara>You know that the Apache Geode Docker container is running since we ended up at a Gfsh command prompt in
the interactive shell.</simpara>
<simpara>We also mapped ports between the Docker container and the host system, exposing well-known ports used by Apache Geode
server-side cluster processes, such as Locators and CacheServers:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Apache Geode Ports</title>
<?dbhtml table-width="30%"?>
<?dbfo table-width="30%"?>
<?dblatex table-width="30%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="84.9999*"/>
<colspec colname="col_2" colwidth="42.5*"/>
<thead>
<row>
<entry align="left" valign="top">Process</entry>
<entry align="left" valign="top">Port</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>HTTP</simpara></entry>
<entry align="left" valign="top"><simpara>7070</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Locator</simpara></entry>
<entry align="left" valign="top"><simpara>10334</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Manager</simpara></entry>
<entry align="left" valign="top"><simpara>1099</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Server</simpara></entry>
<entry align="left" valign="top"><simpara>40404</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>It is unfortunate that the Apache Geode Docker image gives you only a Gfsh command prompt, leaving you with the task of
provisioning a cluster. It would have been more useful to provide preconfigured Docker images with different Apache Geode
cluster configurations, such as one Locator and one server or two Locators and four servers, and so on. However, we can
start the cluster ourselves.</simpara>
</section>
<section xml:id="geode-docker-cluster">
<title>Start an Apache Geode Cluster in Docker</title>
<simpara>From inside the Apache Geode Docker container, we can start a Locator and a server:</simpara>
<example>
<title>Start Apache Geode Locator &amp; Server</title>
<programlisting language="text" linenumbering="unnumbered">gfsh&gt;start locator --name=LocatorOne --log-level=config --hostname-for-clients=localhost
Starting a Geode Locator in /LocatorOne...
.........
Locator in /LocatorOne on 3b30b9ffc5dc[10334] as LocatorOne is currently online.
Process ID: 167
Uptime: 9 seconds
Geode Version: 1.12.0
Java Version: 1.8.0_212
Log File: /LocatorOne/LocatorOne.log
JVM Arguments: -Dgemfire.enable-cluster-configuration=true -Dgemfire.load-cluster-configuration-from-dir=false -Dgemfire.log-level=config -Dgemfire.launcher.registerSignalHandlers=true -Djava.awt.headless=true -Dsun.rmi.dgc.server.gcInterval=9223372036854775806
Class-Path: /geode/lib/geode-core-1.12.0.jar:/geode/lib/geode-dependencies.jar

Successfully connected to: JMX Manager [host=3b30b9ffc5dc, port=1099]

Cluster configuration service is up and running.


gfsh&gt;start server --name=ServerOne --log-level=config --hostname-for-clients=localhost
Starting a Geode Server in /ServerOne...
.......
Server in /ServerOne on 3b30b9ffc5dc[40404] as ServerOne is currently online.
Process ID: 267
Uptime: 7 seconds
Geode Version: 1.12.0
Java Version: 1.8.0_212
Log File: /ServerOne/ServerOne.log
JVM Arguments: -Dgemfire.default.locators=172.17.0.2[10334] -Dgemfire.start-dev-rest-api=false -Dgemfire.use-cluster-configuration=true -Dgemfire.log-level=config -Dgemfire.launcher.registerSignalHandlers=true -Djava.awt.headless=true -Dsun.rmi.dgc.server.gcInterval=9223372036854775806
Class-Path: /geode/lib/geode-core-1.12.0.jar:/geode/lib/geode-dependencies.jar


gfsh&gt;list members
Member Count : 2

   Name    | Id
---------- | --------------------------------------------------------------
LocatorOne | 172.17.0.2(LocatorOne:167:locator)&lt;ec&gt;&lt;v0&gt;:41000 [Coordinator]
ServerOne  | 172.17.0.2(ServerOne:267)&lt;v1&gt;:41001


gfsh&gt;describe member --name=LocatorOne
Name        : LocatorOne
Id          : 172.17.0.2(LocatorOne:167:locator)&lt;ec&gt;&lt;v0&gt;:41000
Host        : 3b30b9ffc5dc
Regions     :
PID         : 167
Groups      :
Used Heap   : 50M
Max Heap    : 443M
Working Dir : /LocatorOne
Log file    : /LocatorOne/LocatorOne.log
Locators    : 172.17.0.2[10334]


gfsh&gt;describe member --name=ServerOne
Name        : ServerOne
Id          : 172.17.0.2(ServerOne:267)&lt;v1&gt;:41001
Host        : 3b30b9ffc5dc
Regions     :
PID         : 267
Groups      :
Used Heap   : 77M
Max Heap    : 443M
Working Dir : /ServerOne
Log file    : /ServerOne/ServerOne.log
Locators    : 172.17.0.2[10334]

Cache Server Information
Server Bind              :
Server Port              : 40404
Running                  : true

Client Connections : 0</programlisting>
</example>
<simpara>We now have an Apache Geode cluster running with one Locator and one server inside a Docker container. We deliberately
started the cluster with a minimal configuration. For example, we have no Regions in which to store data:</simpara>
<informalexample>
<programlisting language="text" linenumbering="unnumbered">gfsh&gt;list regions
No Regions Found</programlisting>
</informalexample>
<simpara>However, that is OK. Once more, we want to show the full power of SBDG and let the Spring Boot application drive
the configuration of the Apache Geode cluster that runs in the Docker container, as required by the application.</simpara>
<simpara>Let&#8217;s have a quick look at our Spring Boot application.</simpara>
</section>
<section xml:id="geode-docker-application">
<title>Spring Boot, Apache Geode Client Application Explained</title>
<simpara>The Spring Boot, Apache Geode <literal>ClientCache</literal> application we use to connect to our Apache Geode cluster that runs in
the Docker container appears as follows:</simpara>
<example>
<title>Spring Boot, Apache Geode Docker client application</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableClusterAware
@EnableEntityDefinedRegions(basePackageClasses = Customer.class)
@UseMemberName("SpringBootApacheGeodeDockerClientCacheApplication")
public class SpringBootApacheGeodeDockerClientCacheApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringBootApacheGeodeDockerClientCacheApplication.class, args);
	}

	@Bean
	@SuppressWarnings("unused")
	ApplicationRunner runner(GemFireCache cache, CustomerRepository customerRepository) {

		return args -&gt; {

			assertClientCacheAndConfigureMappingPdxSerializer(cache);
			assertThat(customerRepository.count()).isEqualTo(0);

			Customer jonDoe = Customer.newCustomer(1L, "Jon Doe");

			log("Saving Customer [%s]...%n", jonDoe);

			jonDoe = customerRepository.save(jonDoe);

			assertThat(jonDoe).isNotNull();
			assertThat(jonDoe.getId()).isEqualTo(1L);
			assertThat(jonDoe.getName()).isEqualTo("Jon Doe");
			assertThat(customerRepository.count()).isEqualTo(1);

			log("Querying for Customer [SELECT * FROM /Customers WHERE name LIKE '%s']...%n", "%Doe");

			Customer queriedJonDoe = customerRepository.findByNameLike("%Doe");

			assertThat(queriedJonDoe).isEqualTo(jonDoe);

			log("Customer was [%s]%n", queriedJonDoe);
		};
	}

	private void assertClientCacheAndConfigureMappingPdxSerializer(GemFireCache cache) {

		assertThat(cache).isNotNull();
		assertThat(cache.getName())
			.isEqualTo(SpringBootApacheGeodeDockerClientCacheApplication.class.getSimpleName());
		assertThat(cache.getPdxSerializer()).isInstanceOf(MappingPdxSerializer.class);

		MappingPdxSerializer serializer = (MappingPdxSerializer) cache.getPdxSerializer();

		serializer.setIncludeTypeFilters(type -&gt; Optional.ofNullable(type)
			.map(Class::getPackage)
			.map(Package::getName)
			.filter(packageName -&gt; packageName.startsWith(this.getClass().getPackage().getName()))
			.isPresent());
	}

	private void log(String message, Object... args) {
		System.err.printf(message, args);
		System.err.flush();
	}
}</programlisting>
</example>
<simpara>Our <literal>Customer</literal> application domain model object type is defined as:</simpara>
<example>
<title><literal>Customer</literal> class</title>
<programlisting language="java" linenumbering="unnumbered">@Region("Customers")
class Customer {

	@Id
	private Long id;

	private String name;

}</programlisting>
</example>
<simpara>Also, we define a Spring Data CRUD Repository to persist and access <literal>Customers</literal> stored in the <literal>/Customers</literal> Region:</simpara>
<example>
<title><literal>CustomerRepository</literal> interface</title>
<programlisting language="java" linenumbering="unnumbered">interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt; {

	Customer findByNameLike(String name);

}</programlisting>
</example>
<simpara>Our main class is annotated with <literal>@SpringBootApplication</literal>, making it be a proper Spring Boot application.</simpara>
<simpara>We additionally annotate the main class with SBDG&#8217;s <literal>@EnableClusterAware</literal> annotation to automatically detect
the Apache Geode cluster that runs in the Docker container and to push cluster configuration metadata from
the application to the cluster as required by the application.</simpara>
<simpara>Specifically, the application requires that a Region called <quote>Customers</quote>, as defined by the <literal>@Region</literal> mapping
annotation on the <literal>Customer</literal> application domain model class, exists on the servers in the cluster, to store <literal>Customer</literal>
data.</simpara>
<simpara>We use the SDG <literal>@EnableEntityDefinedRegions</literal> annotation to define the matching client <literal>PROXY</literal> <quote>Customers</quote> Region.</simpara>
<simpara>Optionally, we have also annotated our main class with SBDG&#8217;s <literal>@UseMemberName</literal> annotation to give the <literal>ClientCache</literal>
a name, which we assert in the <literal>assertClientCacheAndConfigureMappingPdxSerializer(:ClientCache)</literal> method.</simpara>
<simpara>The primary work performed by this application is done in the Spring Boot <literal>ApplicationRunner</literal> bean definition. We create
a <literal>Customer</literal> instance (<literal>Jon Doe</literal>), save it to the <quote>Customers</quote> Region that is managed by the server in the cluster,
and then query for <literal>Jon Doe</literal> using OQL, asserting that the result is equal to what we expect.</simpara>
<simpara>We log the output from the application&#8217;s operations to see the application in action.</simpara>
</section>
<section xml:id="geode-docker-application-run">
<title>Running the Spring Boot, Apache Geode client application</title>
<simpara>When you run the Spring Boot, Apache Geode client application, you should see output similar to the following:</simpara>
<example>
<title>Application log output</title>
<programlisting language="text" linenumbering="unnumbered">/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/bin/java ...
    org.springframework.geode.docs.example.app.docker.SpringBootApacheGeodeDockerClientCacheApplication

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.3.0.RELEASE)

Saving Customer [Customer(name=Jon Doe)]...
Querying for Customer [SELECT * FROM /Customers WHERE name LIKE '%Doe']...
Customer was [Customer(name=Jon Doe)]

Process finished with exit code 0</programlisting>
</example>
<simpara>When we review the configuration of the cluster, we see that the <literal>/Customers</literal> Region was created when the application
ran:</simpara>
<example>
<title>/Customers Region Configuration</title>
<programlisting language="text" linenumbering="unnumbered">gfsh&gt;list regions
List of regions
---------------
Customers


gfsh&gt;describe region --name=/Customers
Name            : Customers
Data Policy     : partition
Hosting Members : ServerOne

Non-Default Attributes Shared By Hosting Members

 Type  |    Name     | Value
------ | ----------- | ---------
Region | size        | 1
       | data-policy | PARTITION</programlisting>
</example>
<simpara>Our <literal>/Customers</literal> Region contains a value (<literal>Jon Doe</literal>), and we can verify this by running the following OQL Query
with Gfsh:</simpara>
<example>
<title>Query the <literal>/Customers</literal> Region</title>
<programlisting language="text" linenumbering="unnumbered">gfsh&gt;query --query="SELECT customer.name FROM /Customers customer"
Result : true
Limit  : 100
Rows   : 1

Result
-------
Jon Doe</programlisting>
</example>
<simpara>Our application ran successfully.</simpara>
</section>
<section xml:id="geode-docker-application-conclusion">
<title>Conclusion</title>
<simpara>In this chapter, we saw how to connect a Spring Boot, Apache Geode <literal>ClientCache</literal> application to an Apache Geode cluster
that runs in a Docker container.</simpara>
<simpara>Later, we provide more information on how to scale up, or rather scale out, our Apache Geode cluster that runs in Docker.
Additionally, we provide details on how you can use Apache Geode&#8217;s Docker image with Testcontainers when you write
integration tests, which formally became part of the Spring Test for Apache Geode (STDG) project.</simpara>
</section>
</chapter>
<chapter xml:id="geode-samples">
<title>Samples</title>
<blockquote>
<note>
<simpara>You are viewing Samples for Spring Boot for Apache Geode (SBDG) version {version}.</simpara>
</note>
</blockquote>
<simpara>This section contains working examples that show how to use Spring Boot for Apache Geode (SBDG) effectively.</simpara>
<simpara>Some examples focus on specific use cases (such as (HTTP) session state caching), while other examples show how SBDG
works under the hood, to give you a better understanding of what is actually happening and how to debug problems with
your Spring Boot Apache Geode applications.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Example Spring Boot applications using Apache Geode</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Guide</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Source</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><link xl:href="guides/getting-started.html">Getting Started with Spring Boot for Apache Geode</link></simpara></entry>
<entry align="left" valign="top"><simpara>Explains how to get started quickly, easily, and reliably building Apache Geode powered applications with Spring Boot.</simpara></entry>
<entry align="left" valign="top"><simpara>{github-samples-url}/intro/getting-started[Getting Started]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xl:href="guides/boot-configuration.html">Spring Boot Auto-Configuration for Apache Geode</link></simpara></entry>
<entry align="left" valign="top"><simpara>Explains what auto-configuration is provided by SBDG and what the auto-configuration does.</simpara></entry>
<entry align="left" valign="top"><simpara>{github-samples-url}/boot/configuration[Spring Boot Auto-Configuration]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xl:href="guides/boot-actuator.html">Spring Boot Actuator for Apache Geode</link></simpara></entry>
<entry align="left" valign="top"><simpara>Explains how to use Spring Boot Actuator for Apache Geode and how it works.</simpara></entry>
<entry align="left" valign="top"><simpara>{github-samples-url}/boot/actuator[Spring Boot Actuator]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xl:href="guides/boot-security.html">Spring Boot Security for Apache Geode</link></simpara></entry>
<entry align="left" valign="top"><simpara>Explains how to configure auth and TLS with SSL when you use Apache Geode in your Spring Boot applications.</simpara></entry>
<entry align="left" valign="top"><simpara>{github-samples-url}/boot/security[Spring Boot Security]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xl:href="guides/caching-look-aside.html">Look-Aside Caching with Spring&#8217;s Cache Abstraction and Apache Geode</link></simpara></entry>
<entry align="left" valign="top"><simpara>Explains how to enable and use Spring&#8217;s Cache Abstraction with Apache Geode as the caching provider
for look-aside caching.</simpara></entry>
<entry align="left" valign="top"><simpara>{github-samples-url}/caching/look-aside[Look-Aside Caching]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xl:href="guides/caching-inline.html">Inline Caching with Spring&#8217;s Cache Abstraction and Apache Geode</link></simpara></entry>
<entry align="left" valign="top"><simpara>Explains how to enable and use Spring&#8217;s Cache Abstraction with Apache Geode as the caching provider for inline caching.
This sample builds on the look-aside caching sample.</simpara></entry>
<entry align="left" valign="top"><simpara>{github-samples-url}/caching/inline[Inline Caching]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xl:href="guides/caching-inline-async.html">Asynchronous Inline Caching with Spring&#8217;s Cache Abstraction and Apache Geode</link></simpara></entry>
<entry align="left" valign="top"><simpara>Explains how to enable and use Spring&#8217;s Cache Abstraction with Apache Geode as the caching provider for asynchronous
inline caching. This sample builds on the look-aside and inline caching samples.</simpara></entry>
<entry align="left" valign="top"><simpara>{github-samples-url}/caching/inline-async[Asynchronous Inline Caching]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xl:href="guides/caching-near.html">Near Caching with Spring&#8217;s Cache Abstraction and Apache Geode</link></simpara></entry>
<entry align="left" valign="top"><simpara>Explains how to enable and use Spring&#8217;s Cache Abstraction with Apache Geode as the caching provider for near caching.
This sample builds on the look-aside caching sample.</simpara></entry>
<entry align="left" valign="top"><simpara>{github-samples-url}/caching/near[Near Caching]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xl:href="guides/caching-multi-site.html">Multi-Site Caching with Spring&#8217;s Cache Abstraction and Apache Geode</link></simpara></entry>
<entry align="left" valign="top"><simpara>Explains how to enable and use Spring&#8217;s Cache Abstraction with Apache Geode as the caching provider for multi-site
caching. This sample builds on the look-aside caching sample.</simpara></entry>
<entry align="left" valign="top"><simpara>{github-samples-url}/caching/multi-site[Multi-Site Caching]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xl:href="guides/caching-http-session.html">HTTP Session Caching with Spring Session and Apache Geode</link></simpara></entry>
<entry align="left" valign="top"><simpara>Explains how to enable and use Spring Session with Apache Geode to manage HTTP session state.</simpara></entry>
<entry align="left" valign="top"><simpara>{github-samples-url}/caching/http-session[HTTP Session Caching]</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</chapter>
<chapter xml:id="appendix">
<title>Appendix</title>
<simpara>The following appendices provide additional help while developing Spring Boot applications backed by Apache Geode:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><xref linkend="geode-auto-configuration-annotations"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="geode-configuration-metadata"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="geode-auto-configuration-disable"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="geode-gemfire-switch"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="geode-cluster-configuration-bootstrapping"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="geode-testing-support"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="geode-examples"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="references"/></simpara>
</listitem>
</orderedlist>
<section xml:id="geode-auto-configuration-annotations">
<title>Auto-configuration vs. Annotation-based configuration</title>
<simpara>The question most often asked is, <quote>What Spring Data for Apache Geode (SDG) annotations can I use, or must I use, when
developing Apache Geode applications with Spring Boot?</quote></simpara>
<simpara>This section answers this question and more.</simpara>
<simpara>See the complementary sample, <link xl:href="guides/boot-configuration.html">Spring Boot Auto-configuration for Apache Geode</link>,
which shows the auto-configuration provided by Spring Boot for Apache Geode in action.</simpara>
<section xml:id="geode-autoconfiguration-annotations-background">
<title>Background</title>
<simpara>To help answer this question, you must start by reviewing the complete collection of available Spring Data for
Apache Geode (SDG) annotations. These annotations are provided in the
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/package-summary.html"><literal>org.springframework.data.gemfire.config.annotation</literal></link>
package. Most of the essential annotations begin with <literal>@Enable&#8230;&#8203;</literal>, except for the base annotations:
<literal>@ClientCacheApplication</literal>, <literal>@PeerCacheApplication</literal> and <literal>@CacheServerApplication</literal>.</simpara>
<simpara>By extension, Spring Boot for Apache Geode (SBDG) builds on SDG&#8217;s annotation-based configuration model to implement
auto-configuration and apply Spring Boot&#8217;s core concepts, such as <quote>convention over configuration</quote>, letting
Apache Geode applications be built with Spring Boot reliably, quickly, and easily.</simpara>
<simpara>SDG provides this annotation-based configuration model to, first and foremost, give application developers <quote>choice</quote>
when building Spring applications with Apache Geode. SDG makes no assumptions about what application developers are
trying to create and fails fast anytime the configuration is ambiguous, giving users immediate feedback.</simpara>
<simpara>Second, SDG&#8217;s annotations were meant to get application developers up and running quickly and reliably with ease. SDG
accomplishes this by applying sensible defaults so that application developers need not know, or even have to learn, all
the intricate configuration details and tooling provided by Apache Geode to accomplish simple tasks, such as building a
prototype.</simpara>
<simpara>So, SDG is all about <quote>choice</quote> and SBDG is all about <quote>convention</quote>. Together these frameworks provide application
developers with convenience and ease to move quickly and reliably.</simpara>
<simpara>To learn more about the motivation behind SDG&#8217;s annotation-based configuration model, see the
<link xl:href="https://docs.spring.io/spring-data/gemfire/docs/current/reference/html/#bootstrap-annotation-config-introduction">Reference Documentation</link>.</simpara>
</section>
<section xml:id="geode-autoconfiguration-annotations-conventions">
<title>Conventions</title>
<simpara>Currently, SBDG provides auto-configuration for the following features:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ClientCache</literal></simpara>
</listitem>
<listitem>
<simpara>Caching with Spring&#8217;s Cache Abstraction</simpara>
</listitem>
<listitem>
<simpara>Continuous Query</simpara>
</listitem>
<listitem>
<simpara>Function Execution and Implementation</simpara>
</listitem>
<listitem>
<simpara>Logging</simpara>
</listitem>
<listitem>
<simpara>PDX</simpara>
</listitem>
<listitem>
<simpara><literal>GemfireTemplate</literal></simpara>
</listitem>
<listitem>
<simpara>Spring Data Repositories</simpara>
</listitem>
<listitem>
<simpara>Security (Client/server auth and SSL)</simpara>
</listitem>
<listitem>
<simpara>Spring Session</simpara>
</listitem>
</itemizedlist>
<simpara>This means the following SDG annotations are not required to use the features above:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>@ClientCacheApplication</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemfireCaching</literal> (or by using Spring Framework&#8217;s <literal>@EnableCaching</literal> annotation)</simpara>
</listitem>
<listitem>
<simpara><literal>@EnableContinuousQueries</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemfireFunctionExecutions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemfireFunctions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableLogging</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnablePdx</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemfireRepositories</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableSecurity</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableSsl</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemFireHttpSession</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Since SBDG auto-configures these features for you, the above annotations are not strictly required. Typically, you
would only declare one of these annotations when you want to <quote>override</quote> Spring Boot&#8217;s conventions, as expressed in
auto-configuration, and <quote>customize</quote> the behavior of the feature.</simpara>
</section>
<section xml:id="geode-autoconfiguration-annotations-overriding">
<title>Overriding</title>
<simpara>In this section, we cover a few examples to make the behavior when overriding more apparent.</simpara>
<section xml:id="geode-autoconfiguration-annotations-overriding-caches">
<title>Caches</title>
<simpara>By default, SBDG provides you with a <literal>ClientCache</literal> instance. SBDG accomplishes this by annotating an auto-configuration
class with <literal>@ClientCacheApplication</literal> internally.</simpara>
<simpara>By convention, we assume most application developers' are developing Spring Boot applications by using Apache Geode
as <quote>client</quote> applications in Apache Geode&#8217;s client/server topology. This is especially true as users migrate their
applications to a managed cloud environment.</simpara>
<simpara>Still, you can <quote>override</quote> the default settings (convention) and declare your Spring applications to be actual peer
<literal>Cache</literal> members (nodes) of a Apache Geode cluster, instead:</simpara>
<example>
<title>Spring Boot, Apache Geode Peer <literal>Cache</literal> Application</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@CacheServerApplication
class SpringBootApacheGeodePeerCacheServerApplication {  }</programlisting>
</example>
<simpara>By declaring the <literal>@CacheServerApplication</literal> annotation, you effectively override the SBDG default. Therefore, SBDG
does not provide you with a <literal>ClientCache</literal> instance by default, because you have informed SBDG of exactly what you want:
a peer <literal>Cache</literal> instance hosting an embedded <literal>CacheServer</literal> that allows client connections.</simpara>
<simpara>However, you then might ask, <quote>Well, how do I customize the <literal>ClientCache</literal> instance when developing client applications
without explicitly declaring the <literal>@ClientCacheApplication</literal> annotation?</quote></simpara>
<simpara>First, you can <quote>customize</quote> the <literal>ClientCache</literal> instance by explicitly declaring the <literal>@ClientCacheApplication</literal> annotation
in your Spring Boot application configuration and setting specific attributes as needed. However, you should be aware
that, by explicitly declaring this annotation, (or, by default, any of the other auto-configured annotations), you
assume all the responsibility that comes with it, since you have effectively overridden the auto-configuration. One
example of this is security, which we touch on more later.</simpara>
<simpara>The most ideal way to <quote>customize</quote> the configuration of any feature is by way of the well-known and documented
<link linkend="geode-configuration-metadata">properties</link>, specified in Spring Boot <literal>application.properties</literal> (the <quote>convention</quote>),
or by using a <link xl:href="https://docs.spring.io/spring-data/gemfire/docs/current/reference/html/#bootstrap-annotation-config-configurers"><literal>Configurer</literal></link>.</simpara>
<simpara>See the <link linkend="geode-clientcache-applications">Reference Guide</link> for more detail.</simpara>
</section>
<section xml:id="geode-autoconfiguration-annotations-overriding-security">
<title>Security</title>
<simpara>As with the <literal>@ClientCacheApplication</literal> annotation, the <literal>@EnableSecurity</literal> annotation is not strictly required, unless you
want to override and customize the defaults.</simpara>
<simpara>Outside a managed environment, the only security configuration required is specifying a username and password. You do
this by using the well-known and documented SDG username and password properties in Spring Boot <literal>application.properties</literal>:</simpara>
<example>
<title>Required Security Properties in a Non-Manage Envionment</title>
<programlisting language="properties" linenumbering="unnumbered">spring.data.gemfire.security.username=MyUser
spring.data.gemfire.security.password=Secret</programlisting>
</example>
<simpara>You need not explicitly declare the <literal>@EnableSecurity</literal> annotation just to specify security configuration (such as
username and password).</simpara>
<simpara>Inside a managed environment, such as the VMware Tanzu Application Service (TAS) when using VMware Tanzu GemFire, SBDG is able to introspect
the environment and configure security (auth) completely without the need to specify any configuration, usernames
and passwords, or otherwise. This is due, in part, because TAS supplies the security details in the VCAP environment
when the application is deployed to TAS and bound to services (such as VMware Tanzu GemFire).</simpara>
<simpara>So, in short, you need not explicitly declare the <literal>@EnableSecurity</literal> annotation (or <literal>@ClientCacheApplication</literal>).</simpara>
<simpara>However, if you do explicitly declare the <literal>@ClientCacheApplication</literal> or <literal>@EnableSecurity</literal> annotations, you are now
responsible for this configuration, and SBDG&#8217;s auto-configuration no longer applies.</simpara>
<simpara>While explicitly declaring <literal>@EnableSecurity</literal> makes more sense when <quote>overriding</quote> the SBDG security auto-configuration,
explicitly declaring the <literal>@ClientCacheApplication</literal> annotation most likely makes less sense with regard to its impact
on security configuration.</simpara>
<simpara>This is entirely due to the internals of Apache Geode, because, in certain cases (such as security), not even Spring
is able to completely shield you from the nuances of Apache Geode&#8217;s configuration. No framework can.</simpara>
<simpara>You must configure both auth and SSL before the cache instance (whether a <literal>ClientCache</literal> or a peer <literal>Cache</literal>) is created.
This is because security is enabled and configured during the <quote>construction</quote> of the cache. Also,, the cache pulls
the configuration from JVM System properties that must be set before the cache is constructed.</simpara>
<simpara>Structuring the <quote>exact</quote> order of the auto-configuration classes provided by SBDG when the classes are triggered, is no
small feat. Therefore, it should come as no surprise to learn that the security auto-configuration classes in SBDG must
be triggered before the <literal>ClientCache</literal> auto-configuration class, which is why a <literal>ClientCache</literal> instance cannot <quote>auto</quote>
authenticate properly in PCC when the <literal>@ClientCacheApplication</literal> is explicitly declared without some assistance. In other
words you must also explicitly declare the <literal>@EnableSecurity</literal> annotation in this case, since you overrode the
auto-configuration of the cache, and implicitly security, as well.</simpara>
<simpara>Again, this is due to the way security (auth) and SSL metadata must be supplied to Apache Geode on startup.</simpara>
<simpara>See the <link linkend="geode-security">Reference Guide</link> for more details.</simpara>
</section>
</section>
<section xml:id="geode-autoconfiguration-annotations-extension">
<title>Extension</title>
<simpara>Most of the time, many of the other auto-configured annotations for CQ, Functions, PDX, Repositories, and so on need not
ever be declared explicitly.</simpara>
<simpara>Many of these features are enabled automatically by having SBDG or other libraries (such as Spring Session) on
the application classpath or are enabled based on other annotations applied to beans in the Spring <literal>ApplicationContext</literal>.</simpara>
<simpara>We review a few examples in the following sections.</simpara>
<section xml:id="geode-autoconfiguration-annotations-extension-caching">
<title>Caching</title>
<simpara>It is rarely, if ever, necessary to explicitly declare either the Spring Framework&#8217;s <literal>@EnableCaching</literal> or the
SDG-specific <literal>@EnableGemfireCaching</literal> annotation in Spring configuration when you use SBDG. SBDG automatically
enables caching and configures the SDG <literal>GemfireCacheManager</literal> for you.</simpara>
<simpara>You need only focus on which application service components are appropriate for caching:</simpara>
<example>
<title>Service Caching</title>
<programlisting language="java" linenumbering="unnumbered">@Service
class CustomerService {

    @Autowired
    private CustomerRepository customerRepository;

    @Cacheable("CustomersByName")
    public Customer findBy(String name) {
        return customerRepository.findByName(name);
    }
}</programlisting>
</example>
<simpara>You need to create Apache Geode Regions that back the caches declared in your application service components
(<literal>CustomersByName</literal> in the preceding example) by using Spring&#8217;s caching annotations (such as <literal>@Cacheable</literal>),
or alternatively, JSR-107 JCache annotations (such as <literal>@CacheResult</literal>).</simpara>
<simpara>You can do that by defining each Region explicitly or, more conveniently, you can use the following approach:</simpara>
<example>
<title>Configuring Caches (Regions)</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableCachingDefinedRegions
class Application {  }</programlisting>
</example>
<simpara><literal>@EnableCachingDefinedRegions</literal> is optional, provided for convenience, and complementary to caching when used rather than
being necessary.</simpara>
<simpara>See the <link linkend="geode-caching-provider">Reference Guide</link> for more detail.</simpara>
</section>
<section xml:id="geode-autoconfiguration-annotations-extension-cq">
<title>Continuous Query</title>
<simpara>It is rarely, if ever, necessary to explicitly declare the SDG <literal>@EnableContinuousQueries</literal> annotation. Instead, you
should focus on defining your application queries and worry less about the plumbing.</simpara>
<simpara>Consider the following example:</simpara>
<example>
<title>Defining Queries for CQ</title>
<programlisting language="java" linenumbering="unnumbered">@Component
public class TemperatureMonitor extends AbstractTemperatureEventPublisher {

	@ContinuousQuery(name = "BoilingTemperatureMonitor",
		query = "SELECT * FROM /TemperatureReadings WHERE temperature.measurement &gt;= 212.0")
	public void boilingTemperatureReadings(CqEvent event) {
		publish(event, temperatureReading -&gt; new BoilingTemperatureEvent(this, temperatureReading));
	}

	@ContinuousQuery(name = "FreezingTemperatureMonitor",
		query = "SELECT * FROM /TemperatureReadings WHERE temperature.measurement &lt;= 32.0")
	public void freezingTemperatureReadings(CqEvent event) {
		publish(event, temperatureReading -&gt; new FreezingTemperatureEvent(this, temperatureReading));
	}
}</programlisting>
</example>
<simpara>Apache Geode CQ applies only to clients.</simpara>
<simpara>See the <link linkend="geode-continuous-query">Reference Guide</link> for more detail.</simpara>
</section>
<section xml:id="geode-autoconfiguration-annotations-extension-functions">
<title>Functions</title>
<simpara>You rarely, if ever, need to explicitly declare either the <literal>@EnableGemfireFunctionExecutions</literal>
or <literal>@EnableGemfireFunctions</literal> annotations. SBDG provides auto-configuration for both Function implementations
and executions.</simpara>
<simpara>You need to define the implementation:</simpara>
<example>
<title>Function Implementation</title>
<programlisting language="java" linenumbering="unnumbered">@Component
class GeodeFunctions {

    @GemfireFunction
    Object exampleFunction(Object arg) {
        // ...
    }
}</programlisting>
</example>
<simpara>Then you need to define the execution:</simpara>
<example>
<title>Function Execution</title>
<programlisting language="java" linenumbering="unnumbered">@OnRegion(region = "Example")
interface GeodeFunctionExecutions {

    Object exampleFunction(Object arg);

}</programlisting>
</example>
<simpara>SBDG automatically finds, configures, and registers Function implementations (POJOs) in Apache Geode as proper
<literal>Functions</literal> and creates execution proxies for the interfaces, which can then be injected into application service
components to invoke the registered <literal>Functions</literal> without needing to explicitly declare the enabling annotations.
The application Function implementations (POJOs) and executions (interfaces) should exist below
the <literal>@SpringBootApplication</literal> annotated main class.</simpara>
<simpara>See the <link linkend="geode-functions">Reference Guide</link> for more detail.</simpara>
</section>
<section xml:id="geode-autoconfiguration-annotations-extension-pdx">
<title>PDX</title>
<simpara>You rarely, if ever, need to explicitly declare the <literal>@EnablePdx</literal> annotation, since SBDG auto-configures PDX by default.
SBDG also automatically configures the SDG <literal>MappingPdxSerializer</literal> as the default <literal>PdxSerializer</literal>.</simpara>
<simpara>It is easy to customize the PDX configuration by setting the appropriate <link linkend="geode-configuration-metadata">properties</link>
(search for <quote>PDX</quote>) in Spring Boot <literal>application.properties</literal>.</simpara>
<simpara>See the <link linkend="geode-data-serialization">Reference Guide</link> for more detail.</simpara>
</section>
<section xml:id="geode-autoconfiguration-annotations-extension-repositories">
<title>Spring Data Repositories</title>
<simpara>You rarely, if ever, need to explicitly declare the <literal>@EnableGemfireRepositories</literal> annotation, since SBDG auto-configures
Spring Data (SD) Repositories by default.</simpara>
<simpara>You need only define your Repositories:</simpara>
<example>
<title>Customer&#8217;s Repository</title>
<programlisting language="java" linenumbering="unnumbered">interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt; {

    Customer findByName(String name);

}</programlisting>
</example>
<simpara>SBDG finds the Repository interfaces defined in your application, proxies them, and registers them as beans in
the Spring <literal>ApplicationContext</literal>. The Repositories can be injected into other application service components.</simpara>
<simpara>It is sometimes convenient to use the <literal>@EnableEntityDefinedRegions</literal> along with Spring Data Repositories to identify
the entities used by your application and define the Regions used by the Spring Data Repository infrastructure to
persist the entity&#8217;s state. The <literal>@EnableEntityDefinedRegions</literal> annotation is optional, provided for convenience,
and complementary to the <literal>@EnableGemfireRepositories</literal> annotation.</simpara>
<simpara>See the <link linkend="geode-repositories">Reference Guide</link> for more detail.</simpara>
</section>
</section>
<section xml:id="geode-autoconfiguration-annotations-explicit">
<title>Explicit Configuration</title>
<simpara>Most of the other annotations provided in SDG are focused on particular application concerns or enable certain
Apache Geode features, rather than being a necessity, including:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>@EnableAutoRegionLookup</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableBeanFactoryLocator</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableCacheServer(s)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableCachingDefinedRegions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableClusterConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableClusterDefinedRegions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableCompression</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableDiskStore(s)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableEntityDefinedRegions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableEviction</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableExpiration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGatewayReceiver</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGatewaySender(s)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableGemFireAsLastResource</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableHttpService</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableIndexing</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableOffHeap</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableLocator</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableManager</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableMemcachedServer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnablePool(s)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableRedisServer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@EnableStatistics</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@UseGemFireProperties</literal></simpara>
</listitem>
</itemizedlist>
<simpara>None of these annotations are necessary and none are auto-configured by SBDG. They are at your disposal when and if you
need them. This also means that none of these annotations are in conflict with any SBDG auto-configuration.</simpara>
</section>
<section xml:id="geode-autoconfiguration-annotations-summary">
<title>Summary</title>
<simpara>In conclusion, you need to understand where SDG ends and SBDG begins. It all begins with the auto-configuration
provided by SBDG.</simpara>
<simpara>If a feature or function is not covered by SBDG&#8217;s auto-configuration, you are responsible for enabling and configuring
the feature appropriately, as needed by your application (for example, <literal>@EnableRedisServer</literal>).</simpara>
<simpara>In other cases, you might also want to explicitly declare a complimentary annotation
(such as <literal>@EnableEntityDefinedRegions</literal>) for convenience, since SBDG provides no convention or opinion.</simpara>
<simpara>In all remaining cases, it boils down to understanding how Apache Geode works under the hood. While we go to great
lengths to shield you from as many details as possible, it is not feasible or practical to address all matters, such as
cache creation and security.</simpara>
</section>
</section>
<section xml:id="geode-configuration-metadata">
<title>Configuration Metadata Reference</title>
<simpara>The following reference sections cover documented and well-known properties recognized and processed by
Spring Data for Apache Geode (SDG) and Spring Session for Apache Geode (SSDG).</simpara>
<simpara>These properties may be used in Spring Boot <literal>application.properties</literal> or as JVM System properties, to configure different
aspects of or enable individual features of Apache Geode in a Spring application. When combined with the power of
Spring Boot, they give you the ability to quickly create an application that uses Apache Geode.</simpara>
<section xml:id="geode-configuration-metadata-springdata">
<title>Spring Data Based Properties</title>
<simpara>The following properties all have a <literal>spring.data.gemfire.*</literal> prefix. For example, to set the cache <literal>copy-on-read</literal>
property, use <literal>spring.data.gemfire.cache.copy-on-read</literal> in Spring Boot <literal>application.properties</literal>.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the Apache Geode.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SpringBasedCacheClientApplication</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#name--"><literal>ClientCacheApplication.name</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>locators</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Comma-delimited list of Locator endpoints formatted as: <literal>locator1[port1],&#8230;&#8203;,locatorN[portN]</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>[]</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/PeerCacheApplication.html#locators--"><literal>PeerCacheApplication.locators</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>use-bean-factory-locator</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enable the SDG <literal>BeanFactoryLocator</literal> when mixing Spring config with Apache Geode native config (such as <literal>cache.xml</literal>) and you wish to configure Apache Geode objects declared in <literal>cache.xml</literal> with Spring.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#useBeanFactoryLocator--"><literal>ClientCacheApplication.useBeanFactoryLocator</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> <emphasis>GemFireCache</emphasis> properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>cache.copy-on-read</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configure whether a copy of an object returned from <literal>Region.get(key)</literal> is made.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#copyOnRead--"><literal>ClientCacheApplication.copyOnRead</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.critical-heap-percentage</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Percentage of heap at or above which the cache is considered in danger of becoming inoperable.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#criticalHeapPercentage--"><literal>ClientCacheApplication.criticalHeapPercentage</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.critical-off-heap-percentage</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Percentage of off-heap at or above which the cache is considered in danger of becoming inoperable.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#criticalOffHeapPercentage--"><literal>ClientCacheApplication.criticalOffHeapPercentage</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.enable-auto-region-lookup</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to lookup Regions configured in Apache Geode native configuration and declare them as Spring beans.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableAutoRegionLookup.html#enabled--"><literal>EnableAutoRegionLookup.enable</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.eviction-heap-percentage</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Percentage of heap at or above which the eviction should begin on Regions configured for HeapLRU eviction.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#evictionHeapPercentage--"><literal>ClientCacheApplication.evictionHeapPercentage</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.eviction-off-heap-percentage</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Percentage of off-heap at or above which the eviction should begin on Regions configured for HeapLRU eviction.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#evictionOffHeapPercentage--"><literal>ClientCacheApplication.evictionOffHeapPercentage</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.log-level</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configure the log-level of an Apache Geode cache.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>config</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#logLevel--"><literal>ClientCacheApplication.logLevel</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Alias for <literal>spring.data.gemfire.name</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SpringBasedCacheClientApplication</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#name--"><literal>ClientCacheApplication.name</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.compression.bean-name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of a Spring bean that implements <literal>org.apache.geode.compression.Compressor</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableCompression.html#compressorBeanName--"><literal>EnableCompression.compressorBeanName</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.compression.region-names</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Comma-delimited list of Region names for which compression is configured.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>[]</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableCompression.html#RegionNames--">EnableCompression.RegionNames</link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>cache.off-heap.memory-size</simpara></entry>
<entry align="left" valign="top"><simpara>Determines the size of off-heap memory used by Apache Geode in megabytes (m) or gigabytes (g)&#8201;&#8212;&#8201;for example, <literal>120g</literal></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableOffHeap.html#memorySize--"><literal>EnableOffHeap.memorySize</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.off-heap.region-names</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Comma-delimited list of Region names for which off-heap is configured.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>[]</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableOffHeap.html#RegionNames--"><literal>EnableOffHeap.RegionNames</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> <emphasis>ClientCache</emphasis> properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>cache.client.durable-client-id</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used only for clients in a client/server installation. If set, this indicates that the client is durable and identifies the client. The ID is used by servers to reestablish any messaging that was interrupted by client downtime.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#durableClientId--"><literal>ClientCacheApplication.durableClientId</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.client.durable-client-timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used only for clients in a client/server installation. Number of seconds this client can remain disconnected from its server and have the server continue to accumulate durable events for it.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>300</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#durableClientTimeout--"><literal>ClientCacheApplication.durableClientTimeout</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.client.keep-alive</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether the server should keep the durable client&#8217;s queues alive for the timeout period.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#keepAlive--"><literal>ClientCacheApplication.keepAlive</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> peer <emphasis>Cache</emphasis> properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>cache.peer.enable-auto-reconnect</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether a member (a Locator or Server) try to reconnect and reinitialize the cache after it has been forced out of the cluster by a network partition event or has otherwise been shunned by other members.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/PeerCacheApplication.html#enableAutoReconnect--"><literal>PeerCacheApplication.enableAutoReconnect</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.peer.lock-lease</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The length, in seconds, of distributed lock leases obtained by this cache.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>120</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/PeerCacheApplication.html#lockLease--"><literal>PeerCacheApplication.lockLease</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.peer.lock-timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of seconds a cache operation waits to obtain a distributed lock lease.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>60</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/PeerCacheApplication.html#lockTimeout--"><literal>PeerCacheApplication.lockTimeout</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.peer.message-sync-interval</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The frequency (in seconds) at which a message is sent by the primary cache-server to all the secondary cache-server nodes to remove the events that have already been dispatched from the queue.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/PeerCacheApplication.html#messageSyncInterval--"><literal>PeerCacheApplication.messageSyncInterval</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.peer.search-timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of seconds a cache get operation can spend searching for a value.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>300</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/PeerCacheApplication.html#searchTimeout--"><literal>PeerCacheApplication.searchTimeout</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.peer.use-cluster-configuration</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether this cache member node pulls its configuration metadata from the cluster-based cluster configuration service.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/PeerCacheApplication.html#useClusterConfiguration--"><literal>PeerCacheApplication.useClusterConfiguration</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> <emphasis>CacheServer</emphasis> properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.auto-startup</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether the <literal>CacheServer</literal> should be started automatically at runtime.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#autoStartup--"><literal>CacheServerApplication.autoStartup</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.bind-address</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The IP address or hostname on which this cache server listens.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#bindAddress--"><literal>CacheServerApplication.bindAddress</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.hostname-for-clients</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The IP address or hostname that server locators tell to clients to indicate the IP address on which the cache server listens.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#hostnameForClients--"><literal>CacheServerApplication.hostNameForClients</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.load-poll-interval</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The frequency in milliseconds at which to poll the load probe on this cache server.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5000</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#loadPollInterval--"><literal>CacheServerApplication.loadPollInterval</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.max-connections</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum client connections.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>800</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#maxConnections--"><literal>CacheServerApplication.maxConnections</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.max-message-count</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum number of messages that can be in a client queue.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>230000</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#maxMessageCount--"><literal>CacheServerApplication.maxMessageCount</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.max-threads</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum number of threads allowed in this cache server to service client requests.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#maxThreads--"><literal>CacheServerApplication.maxThreads</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.max-time-between-pings</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum amount of time between client pings.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>60000</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#maxTimeBetweenPings--"><literal>CacheServerApplication.maxTimeBetweenPings</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.message-time-to-live</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The time (in seconds) after which a message in the client queue expires.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>180</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#messageTimeToLive--"><literal>CacheServerApplication.messageTimeToLive</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.port</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The port on which this cache server listens for clients.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>40404</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#port--"><literal>CacheServerApplication.port</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.socket-buffer-size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The buffer size of the socket connection to this <literal>CacheServer</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>32768</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#socketBufferSize--"><literal>CacheServerApplication.socketBufferSize</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.subscription-capacity</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The capacity of the client queue.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#subscriptionCapacity--"><literal>CacheServerApplication.subscriptionCapacity</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.subscription-disk-store-name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of the disk store for client subscription queue overflow.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#subscriptionDiskStoreName--"><literal>CacheServerApplication.subscriptionDiskStoreName</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.subscription-eviction-policy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The eviction policy that is executed when the capacity of the client subscription queue is reached.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#subscriptionEvictionPolicy--"><literal>CacheServerApplication.subscriptionEvictionPolicy</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.tcp-no-delay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The outgoing socket connection tcp-no-delay setting.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#tcpNoDelay--"><literal>CacheServerApplication.tcpNoDelay</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><literal>CacheServer</literal> properties can be further targeted at specific <literal>CacheServer</literal> instances by using an optional bean name
of the <literal>CacheServer</literal> bean defined in the Spring <literal>ApplicationContext</literal>. Consider the following example:</simpara>
<informalexample>
<programlisting language="properties" linenumbering="unnumbered">spring.data.gemfire.cache.server.[&lt;cacheServerBeanName&gt;].bind-address=...</programlisting>
</informalexample>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> Cluster properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>cluster.Region.type</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the data management policy used when creating Regions on the servers in the cluster.</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/RegionShortcut.html#PARTITION"><literal>RegionShortcut.PARTITION</literal></link></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableClusterConfiguration.html#serverRegionShortcut--"><literal>EnableClusterConfiguration.serverRegionShortcut</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> <emphasis>DiskStore</emphasis> properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>disk.store.allow-force-compaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to allow <literal>DiskStore.forceCompaction()</literal> to be called on Regions that use a disk store.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableDiskStore.html#allowForceCompaction--"><literal>EnableDiskStore.allowForceCompaction</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>disk.store.auto-compact</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to cause the disk files to be automatically compacted.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableDiskStore.html#autoCompact--"><literal>EnableDiskStore.autoCompact</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>disk.store.compaction-threshold</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The threshold at which an oplog becomes compactible.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>50</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableDiskStore.html#compactionThreshold--"><literal>EnableDiskStore.compactionThreshold</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>disk.store.directory.location</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The system directory where the <literal>DiskStore</literal> (oplog) files are stored.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>[]</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableDiskStore.html#diskDirectories--"><literal>EnableDiskStore.diskDirectories.location</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>disk.store.directory.size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of disk space allowed to store disk store (oplog) files.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>21474883647</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableDiskStore.html#diskDirectories--"><literal>EnableDiskStore.diskDirectories.size</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>disk.store.disk-usage-critical-percentage</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The critical threshold for disk usage as a percentage of the total disk volume.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>99.0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableDiskStore.html#diskUsageCriticalPercentage--"><literal>EnableDiskStore.diskUsageCriticalPercentage</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>disk.store.disk-usage-warning-percentage</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The warning threshold for disk usage as a percentage of the total disk volume.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>90.0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableDiskStore.html#diskUsageWarningPercentage--"><literal>EnableDiskStore.diskUsageWarningPercentage</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>disk.store.max-oplog-size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum size (in megabytes) a single oplog (operation log) can be.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableDiskStore.html#maxOplogSize--"><literal>EnableDiskStore.maxOplogSize</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>disk.store.queue-size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum number of operations that can be asynchronously queued.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableDiskStore.html#queueSize--"><literal>EnableDiskStore.queueSize</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>disk.store.time-interval</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of milliseconds that can elapse before data written asynchronously is flushed to disk.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1000</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableDiskStore.html#timeInterval--"><literal>EnableDiskStore.timeInterval</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>disk.store.write-buffer-size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configures the write buffer size in bytes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>32768</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableDiskStore.html#writeBufferSize--"><literal>EnableDiskStore.writeBufferSize</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><literal>DiskStore</literal> properties can be further targeted at specific <literal>DiskStore</literal> instances by setting the
<link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/DiskStore.html#getName--"><literal>DiskStore.name</literal></link> property.</simpara>
<simpara>For example, you can specify directory location of the files for a specific, named <literal>DiskStore</literal> by using:</simpara>
<informalexample>
<programlisting language="properties" linenumbering="unnumbered">spring.data.gemfire.disk.store.Example.directory.location=/path/to/geode/disk-stores/Example/</programlisting>
</informalexample>
<simpara>The directory location and size of the <literal>DiskStore</literal> files can be further divided into multiple locations and size
using array syntax:</simpara>
<informalexample>
<programlisting language="properties" linenumbering="unnumbered">spring.data.gemfire.disk.store.Example.directory[0].location=/path/to/geode/disk-stores/Example/one
spring.data.gemfire.disk.store.Example.directory[0].size=4096000
spring.data.gemfire.disk.store.Example.directory[1].location=/path/to/geode/disk-stores/Example/two
spring.data.gemfire.disk.store.Example.directory[1].size=8192000</programlisting>
</informalexample>
<simpara>Both the name and array index are optional, and you can use any combination of name and array index. Without a name,
the properties apply to all <literal>DiskStore</literal> instances. Without array indexes, all named <literal>DiskStore</literal> files are stored in
the specified location and limited to the defined size.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> Entity properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>entities.base-packages</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Comma-delimited list of package names indicating the start points for the entity scan.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableEntityDefinedRegions.html#basePackages--"><literal>EnableEntityDefinedRegions.basePackages</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> Locator properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>locator.host</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The IP address or hostname of the system NIC to which the embedded Locator is bound to listen for connections.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableLocator.html#host--"><literal>EnableLocator.host</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>locator.port</simpara></entry>
<entry align="left" valign="top"><simpara>The network port to which the embedded Locator will listen for connections.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10334</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableLocator.html#port--"><literal>EnableLocator.port</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> Logging properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>logging.level</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The log level of an Apache Geode cache. Alias for 'spring.data.gemfire.cache.log-level'.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>config</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableLogging.html#logLevel--"><literal>EnableLogging.logLevel</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>logging.log-disk-space-limit</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of disk space allowed to store log files.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableLogging.html#logDiskSpaceLimit--"><literal>EnableLogging.logDiskSpaceLimit</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>logging.log-file</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pathname of the log file used to log messages.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableLogging.html#logFile--"><literal>EnableLogging.logFile</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>logging.log-file-size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum size of a log file before the log file is rolled.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableLogging.html#logFileSizeLimit--"><literal>EnableLogging.logFileSize</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> Management properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>management.use-http</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to use the HTTP protocol to communicate with an Apache Geode Manager.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableClusterConfiguration.html#useHttp--"><literal>EnableClusterConfiguration.useHttp</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>management.http.host</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The IP address or hostname of the Apache Geode Manager that runs the HTTP service.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableClusterConfiguration.html#host--"><literal>EnableClusterConfiguration.host</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>management.http.port</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The port used by the Apache Geode Manager&#8217;s HTTP service to listen for connections.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>7070</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableClusterConfiguration.html#port--"><literal>EnableClusterConfiguration.port</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> Manager properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>manager.access-file</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The access control list (ACL) file used by the Manager to restrict access to the JMX MBeans by the clients.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableManager.html#accessFile--"><literal>EnableManager.accessFile</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>manager.bind-address</simpara></entry>
<entry align="left" valign="top"><simpara>The IP address or hostname of the system NIC used by the Manager to bind and listen for JMX client connections.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableManager.html#bindAddress--"><literal>EnableManager.bindAddress</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>manager.hostname-for-clients</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The hostname given to JMX clients to ask the Locator for the location of the Manager.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableManager.html#hostnameForClients--"><literal>EnableManager.hostNameForClients</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>manager.password-file</literal></simpara></entry>
<entry align="left" valign="top"><simpara>By default, the JMX Manager lets clients without credentials connect. If this property is set to the name of a file, only clients that connect with credentials that match an entry in this file are allowed.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableManager.html#passwordFile--"><literal>EnableManager.passwordFile</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>manager.port</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The port used by the Manager to listen for JMX client connections.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1099</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableManager.html#port--"><literal>EnableManager.port</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>manager.start</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to start the Manager service at runtime.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableManager.html#start--"><literal>EnableManager.start</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>manager.update-rate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The rate, in milliseconds, at which this member pushes updates to any JMX Managers.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>2000</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableManager.html#updateRate--"><literal>EnableManager.updateRate</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> PDX properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>pdx.disk-store-name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of the <literal>DiskStore</literal> used to store PDX type metadata to disk when PDX is persistent.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePdx.html#diskStoreName--"><literal>EnablePdx.diskStoreName</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pdx.ignore-unread-fields</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether PDX ignores fields that were unread during deserialization.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePdx.html#ignoreUnreadFields--"><literal>EnablePdx.ignoreUnreadFields</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pdx.persistent</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether PDX persists type metadata to disk.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePdx.html#persistent--"><literal>EnablePdx.persistent</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pdx.read-serialized</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether a Region entry is returned as a <literal>PdxInstance</literal> or deserialized back into object form on read.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePdx.html#readSerialized--"><literal>EnablePdx.readSerialized</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pdx.serialize-bean-name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of a custom Spring bean that implements <literal>org.apache.geode.pdx.PdxSerializer</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePdx.html#serializerBeanName--"><literal>EnablePdx.serializerBeanName</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> Pool properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>pool.free-connection-timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The timeout used to acquire a free connection from a Pool.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10000</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#freeConnectionTimeout--"><literal>EnablePool.freeConnectionTimeout</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.idle-timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of time a connection can be idle before expiring (and closing) the connection.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5000</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#idleTimeout--"><literal>EnablePool.idleTimeout</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.load-conditioning-interval</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The interval for how frequently the Pool checks to see if a connection to a given server should be moved to a different server to improve the load balance.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>300000</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#loadConditioningInterval--"><literal>EnablePool.loadConditioningInterval</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.locators</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Comma-delimited list of locator endpoints in the format of <literal>locator1[port1],&#8230;&#8203;,locatorN[portN]</literal></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#locators--"><literal>EnablePool.locators</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.max-connections</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum number of client to server connections that a Pool will create.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#maxConnections--">EnablePool.maxConnections</link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.min-connections</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The minimum number of client to server connections that a Pool maintains.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#minConnections--"><literal>EnablePool.minConnections</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.multi-user-authentication</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether the created Pool can be used by multiple authenticated users.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#multiUserAuthentication--"><literal>EnablePool.multiUserAuthentication</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.ping-interval</literal></simpara></entry>
<entry align="left" valign="top"><simpara>How often to ping servers to verify that they are still alive.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10000</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#pingInterval--"><literal>EnablePool.pingInterval</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.pr-single-hop-enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to perform single-hop data access operations between the client and servers. When <literal>true</literal>, the client is aware of the location of partitions on servers that host Regions with <literal>DataPolicy.PARTITION</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#prSingleHopEnabled--"><literal>EnablePool.prSingleHopEnabled</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.read-timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of milliseconds to wait for a response from a server before timing out the operation and trying another server (if any are available).</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10000</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#readTimeout--"><literal>EnablePool.readTimeout</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.ready-for-events</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to signal the server that the client is prepared and ready to receive events.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/ClientCacheApplication.html#readyForEvents--"><literal>ClientCacheApplication.readyForEvents</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.retry-attempts</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of times to retry a request after timeout/exception.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#retryAttempts--"><literal>EnablePool.retryAttempts</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.server-group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The group that all servers to which a Pool connects must belong.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#serverGroup--"><literal>EnablePool.serverGroup</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.servers</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Comma-delimited list of <literal>CacheServer</literal> endpoints in the format of <literal>server1[port1],&#8230;&#8203;,serverN[portN]</literal></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#servers--"><literal>EnablePool.servers</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.socket-buffer-size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The socket buffer size for each connection made in all Pools.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>32768</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#socketBufferSize--"><literal>EnablePool.socketBufferSize</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.statistic-interval</literal></simpara></entry>
<entry align="left" valign="top"><simpara>How often to send client statistics to the server.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#statisticInterval--"><literal>EnablePool.statisticInterval</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>pool.subscription-ack-interval</simpara></entry>
<entry align="left" valign="top"><simpara>The interval in milliseconds to wait before sending acknowledgements to the <literal>CacheServer</literal> for events received from the server subscriptions.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>100</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#subscriptionAckInterval--"><literal>EnablePool.subscriptionAckInterval</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.subscription-enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether the created Pool has server-to-client subscriptions enabled.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#subscriptionEnabled--"><literal>EnablePool.subscriptionEnabled</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.subscription-message-tracking-timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>messageTrackingTimeout</literal> attribute, which is the time-to-live period, in milliseconds, for subscription events the client has received from the server.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>900000</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#subscriptionMessageTrackingTimeout--"><literal>EnablePool.subscriptionMessageTrackingTimeout</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.subscription-redundancy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The redundancy level for all Pools server-to-client subscriptions.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#subscriptionRedundancy--"><literal>EnablePool.subsriptionRedundancy</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pool.thread-local-connections</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The thread local connections policy for all Pools.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnablePool.html#threadLocalConnections--"><literal>EnablePool.threadLocalConnections</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> Security properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>security.username</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of the user used to authenticate with the servers.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSecurity.html#securityUsername--"><literal>EnableSecurity.securityUsername</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.password</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The user password used to authenticate with the servers.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSecurity.html#securityPassword--"><literal>EnableSecurity.securityPassword</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.properties-file</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The system pathname to a properties file that contains security credentials.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableAuth.html#securityPropertiesFile--"><literal>EnableAuth.propertiesFile</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.client.accessor</literal></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableAuth.html#clientAccessor--"><literal>EnableAuth.clientAccessor</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.client.accessor-post-processor</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The callback that should be invoked in the post-operation phase, which is when the operation has completed on the server but before the result is sent to the client.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableAuth.html#clientAccessorPostProcessor--"><literal>EnableAuth.clientAccessorPostProcessor</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.client.authentication-initializer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Static creation method that returns an <literal>AuthInitialize</literal> object, which obtains credentials for peers in a cluster.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSecurity.html#clientAuthenticationInitializer--"><literal>EnableSecurity.clientAuthentiationInitializer</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.client.authenticator</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Static creation method that returns an <literal>Authenticator</literal> object used by a cluster member (Locator or Server) to verify the credentials of a connecting client.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableAuth.html#clientAuthenticator--"><literal>EnableAuth.clientAuthenticator</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.client.diffie-hellman-algorithm</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used for authentication. For secure transmission of sensitive credentials (such as passwords), you can encrypt the credentials by using the Diffie-Hellman key-exchange algorithm. You can do so by setting the <literal>security-client-dhalgo</literal> system property on the clients to the name of a valid, symmetric key cipher supported by the JDK.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableAuth.html#clientDiffieHellmanAlgorithm--"><literal>EnableAuth.clientDiffieHellmanAlgorithm</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.log.file</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pathname to a log file used for security log messages.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableAuth.html#securityLogFile--"><literal>EnableAuth.securityLogFile</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.log.level</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The log level for security log messages.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableAuth.html#securityLogLevel--"><literal>EnableAuth.securityLogLevel</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.manager.class-name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of a class that implements <literal>org.apache.geode.security.SecurityManager</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSecurity.html#securityManagerClassName--"><literal>EnableSecurity.securityManagerClassName</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.peer.authentication-initializer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Static creation method that returns an <literal>AuthInitialize</literal> object, which obtains credentials for peers in a cluster.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSecurity.html#peerAuthenticationInitializer--"><literal>EnableSecurity.peerAuthenticationInitializer</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.peer.authenticator</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Static creation method that returns an <literal>Authenticator</literal> object, which is used by a peer to verify the credentials of a connecting node.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableAuth.html#peerAuthenticator--"><literal>EnableAuth.peerAuthenticator</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>security.peer.verify-member-timeout</simpara></entry>
<entry align="left" valign="top"><simpara>The timeout in milliseconds used by a peer to verify membership of an unknown authenticated peer requesting a secure connection.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableAuth.html#peerVerifyMemberTimeout--"><literal>EnableAuth.peerVerifyMemberTimeout</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.post-processor.class-name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of a class that implements the <literal>org.apache.geode.security.PostProcessor</literal> interface that can be used to change the returned results of Region get operations.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSecurity.html#securityPostProcessorClassName--"><literal>EnableSecurity.securityPostProcessorClassName</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.shiro.ini-resource-path</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Apache Geode System property that refers to the location of an Apache Shiro INI file that configures the Apache Shiro Security Framework in order to secure Apache Geode.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSecurity.html#shiroIniResourcePath--"><literal>EnableSecurity.shiroIniResourcePath</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> SSL properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.certificate.alias.cluster</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The alias to the stored SSL certificate used by the cluster to secure communications.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#componentCertificateAliases--"><literal>EnableSsl.componentCertificateAliases</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.certificate.alias.default-alias</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The default alias to the stored SSL certificate used to secure communications across the entire Apache Geode system.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#defaultCertificateAlias--"><literal>EnableSsl.defaultCertificateAlias</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.certificate.alias.gateway</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The alias to the stored SSL certificate used by the WAN Gateway Senders/Receivers to secure communications.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#componentCertificateAliases--"><literal>EnableSsl.componentCertificateAliases</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.certificate.alias.jmx</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The alias to the stored SSL certificate used by the Manager&#8217;s JMX-based JVM MBeanServer and JMX clients to secure communications.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#componentCertificateAliases--"><literal>EnableSsl.componentCertificateAliases</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.certificate.alias.locator</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The alias to the stored SSL certificate used by the Locator to secure communications.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#componentCertificateAliases--"><literal>EnableSsl.componentCertificateAliases</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.certificate.alias.server</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The alias to the stored SSL certificate used by clients and servers to secure communications.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#componentCertificateAliases--"><literal>EnableSsl.componentCertificateAliases</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.certificate.alias.web</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The alias to the stored SSL certificate used by the embedded HTTP server to secure communications (HTTPS).</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#componentCertificateAliases--"><literal>EnableSsl.componentCertificateAliases</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.ciphers</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Comma-separated list of SSL ciphers or <literal>any</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#ciphers--"><literal>EnableSsl.ciphers</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.components</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Comma-delimited list of Apache Geode components (for example, WAN) to be configured for SSL communication.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#components--"><literal>EnableSsl.components</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.keystore</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The system pathname to the Java KeyStore file storing certificates for SSL.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#keystore--"><literal>EnableSsl.keystore</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.keystore.password</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The password used to access the Java KeyStore file.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#keystorePassword--"><literal>EnableSsl.keystorePassword</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.keystore.type</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The password used to access the Java KeyStore file (for example, JKS).</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#keystoreType--"><literal>EnableSsl.keystoreType</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.protocols</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Comma-separated list of SSL protocols or <literal>any</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#protocols--"><literal>EnableSsl.protocols</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.require-authentication</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether two-way authentication is required.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#requireAuthentication--"><literal>EnableSsl.requireAuthentication</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.truststore</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The system pathname to the trust store (Java KeyStore file) that stores certificates for SSL.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#truststore--"><literal>EnableSsl.truststore</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.truststore.password</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The password used to access the trust store (Java KeyStore file).</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#truststorePassword--"><literal>EnableSsl.truststorePassword</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.truststore.type</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The password used to access the trust store (Java KeyStore file&#8201;&#8212;&#8201;for example, JKS).</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#truststoreType--"><literal>EnableSsl.truststoreType</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security.ssl.web-require-authentication</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether two-way HTTP authentication is required.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableSsl.html#webRequireAuthentication--"><literal>EnableSsl.webRequireAuthentication</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.data.gemfire.*</literal> Service properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>service.http.bind-address</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The IP address or hostname of the system NIC used by the embedded HTTP server to bind and listen for HTTP(S) connections.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableHttpService.html#bindAddress--"><literal>EnableHttpService.bindAddress</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>service.http.port</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The port used by the embedded HTTP server to listen for HTTP(S) connections.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>7070</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableHttpService.html#port--"><literal>EnableHttpService.port</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>service.http.ssl-require-authentication</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether two-way HTTP authentication is required.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableHttpService.html#sslRequireAuthentication--"><literal>EnableHttpService.sslRequireAuthentication</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>service.http.dev-rest-api-start</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to start the Developer REST API web service. A full installation of Apache Geode is required, and you must set the <literal>$GEODE</literal> environment variable.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableHttpService.html#startDeveloperRestApi--"><literal>EnableHttpService.startDeveloperRestApi</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>service.memcached.port</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The port of the embedded Memcached server (service).</simpara></entry>
<entry align="left" valign="top"><simpara><literal>11211</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableMemcachedServer.html#port--"><literal>EnableMemcachedServer.port</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>service.memcached.protocol</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The protocol used by the embedded Memcached server (service).</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ASCII</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableMemcachedServer.html#protocol--"><literal>EnableMemcachedServer.protocol</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>service.redis.bind-address</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The IP address or hostname of the system NIC used by the embedded Redis server to bind and listen for connections.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableRedisServer.html#bindAddress--"><literal>EnableRedis.bindAddress</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>service.redis.port</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The port used by the embedded Redis server to listen for connections.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6479</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/EnableRedisServer.html#port--"><literal>EnableRedisServer.port</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="geode-configuration-metadata-springsession">
<title>Spring Session Based Properties</title>
<simpara>The following properties all have a <literal>spring.session.data.gemfire.*</literal> prefix. For example, to set the session Region name,
set <literal>spring.session.data.gemfire.session.region.name</literal> in Spring Boot <literal>application.properties</literal>.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>spring.session.data.gemfire.*</literal> properties</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="95.625*"/>
<colspec colname="col_2" colwidth="95.625*"/>
<colspec colname="col_3" colwidth="95.625*"/>
<colspec colname="col_4" colwidth="95.625*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">From</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>cache.client.pool.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the pool used to send data access operations between the client and servers.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>gemfirePool</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/api/org/springframework/session/data/gemfire/config/annotation/web/http/EnableGemFireHttpSession.html#poolName--"><literal>EnableGemFireHttpSession.poolName</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.client.Region.shortcut</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>DataPolicy</literal> used by the client Region to manage (HTTP) session state.</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/client/ClientRegionShortcut.html#PROXY"><literal>ClientRegionShortcut.PROXY</literal></link></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/api/org/springframework/session/data/gemfire/config/annotation/web/http/EnableGemFireHttpSession.html#clientRegionShortcut--"><literal>EnableGemFireHttpSession.clientRegionShortcut</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache.server.Region.shortcut</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>DataPolicy</literal> used by the server Region to manage (HTTP) session state.</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/RegionShortcut.html#PARTITION"><literal>RegionShortcut.PARTITION</literal></link></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/api/org/springframework/session/data/gemfire/config/annotation/web/http/EnableGemFireHttpSession.html#serverRegionShortcut--"><literal>EnableGemFireHttpSession.serverRegionShortcut</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>session.attributes.indexable</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The names of session attributes for which an Index is created.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>[]</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/api/org/springframework/session/data/gemfire/config/annotation/web/http/EnableGemFireHttpSession.html#indexableSessionAttributes--"><literal>EnableGemFireHttpSession.indexableSessionAttributes</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>session.expiration.max-inactive-interval-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configures the number of seconds in which a session can remain inactive before it expires.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1800</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/api/org/springframework/session/data/gemfire/config/annotation/web/http/EnableGemFireHttpSession.html#maxInactiveIntervalSeconds--"><literal>EnableGemFireHttpSession.maxInactiveIntervalSeconds</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>session.Region.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of the (client/server) Region used to manage (HTTP) session state.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ClusteredSpringSessions</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/api/org/springframework/session/data/gemfire/config/annotation/web/http/EnableGemFireHttpSession.html#RegionName--"><literal>EnableGemFireHttpSession.RegionName</literal></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>session.serializer.bean-name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of a Spring bean that implements <literal>org.springframework.session.data.gemfire.serialization.SessionSerializer</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/api/org/springframework/session/data/gemfire/config/annotation/web/http/EnableGemFireHttpSession.html#sessionSerializerBeanName--"><literal>EnableGemFireHttpSession.sessionSerializerBeanName</literal></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="geode-configuration-metadata-apachegeode">
<title>Apache Geode Properties</title>
<simpara>While we do not recommend using Apache Geode properties directly in your Spring applications, SBDG does not prevent you
from doing so. See the <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/reference/topics/gemfire_properties.html">complete reference to the Apache Geode specific properties</link>.</simpara>
<warning>
<simpara>Apache Geode is very strict about the properties that may be specified in a <literal>gemfire.properties</literal> file.
You cannot mix Spring properties with <literal>gemfire.*</literal> properties in an Apache Geode <literal>gemfire.properties</literal> file.</simpara>
</warning>
</section>
</section>
<section xml:id="geode-auto-configuration-disable">
<title>Disabling Auto-configuration</title>
<simpara>If you would like to disable the auto-configuration of any feature provided by Spring Boot for Apache Geode, you
can specify the auto-configuration class in the <literal>exclude</literal> attribute of the <literal>@SpringBootApplication</literal> annotation:</simpara>
<example>
<title>Disable Auto-configuration of PDX</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication(exclude = PdxSerializationAutoConfiguration.class)
public class MySpringBootApplication {

  public static void main(String[] args) {
    SpringApplication.run(MySpringBootApplication.class, args);
  }
}</programlisting>
</example>
<simpara>You can disable more than one auto-configuration class at a time by specifying each class in the <literal>exclude</literal> attribute
using array syntax:</simpara>
<example>
<title>Disable Auto-configuration of PDX &amp; SSL</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication(exclude = { PdxSerializationAutoConfiguration.class, SslAutoConfiguration.class })
public class MySpringBootApplication {

  public static void main(String[] args) {
    SpringApplication.run(MySpringBootApplication.class, args);
  }
}</programlisting>
</example>
<section xml:id="geode-auto-configuration-disable-classes">
<title>Complete Set of Auto-configuration Classes</title>
<simpara>The current set of auto-configuration classes in Spring Boot for Apache Geode includes:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>CacheNameAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>CachingProviderAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ClientCacheAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ClientSecurityAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ContinuousQueryAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>FunctionExecutionAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>GemFirePropertiesAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>LoggingAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>PdxSerializationAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>PeerSecurityAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>RegionTemplateAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>RepositoriesAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>SpringSessionAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>SpringSessionPropertiesAutoConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>SslAutoConfiguration</literal></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="geode-gemfire-switch">
<title>Switching from Apache Geode to VMware Tanzu GemFire or VMware Tanzu GemFire for VMs</title>
<simpara>Spring Boot for Apache Geode (SBDG) stopped providing support for VMware Tanzu GemFire after SBDG 1.3. SBDG 1.3 was
the last version to support both Apache Geode and VMware Tanzu GemFire. If you need support for VMware Tanzu GemFire
in Spring Boot, then you will need to downgrade to SBDG 1.3.</simpara>
<warning>
<simpara>This section is now deprecated. Spring Boot for Apache Geode (SBDG) no longer provides the
<literal>spring-gemfire-starter</literal> or related starter modules. As of SBDG 1.4, SBDG is based on Apache Geode 1.13. Standalone
GemFire bits based on Apache Geode are no longer being released by VMware, Inc. after GemFire 9.10. GemFire 9.10
was based on Apache Geode 1.12, and SBDG can no longer properly support standalone GemFire bits (version &#8656; 9.10).</simpara>
</warning>
<note>
<simpara>What was Pivotal GemFire has now been rebranded as <link xl:href="https://pivotal.io/pivotal-gemfire">VMware Tanzu GemFire</link>
and what was Pivotal Cloud Cache (PCC) running on Pivotal CloudFoundry (PCF) has been rebranded as
<link xl:href="https://pivotal.io/pivotal-cloud-cache">VMware Tanzu GemFire for VMs</link> and <link xl:href="https://pivotal.io/platform">VMware Tanzu Application Service (TAS) (TAS)</link>,
respectively.</simpara>
</note>
</section>
<section xml:id="geode-cluster-configuration-bootstrapping">
<title>Running an Apache Geode cluster with Spring Boot from your IDE</title>
<simpara>As described in <xref linkend="geode-clientcache-applications"/>, you can configure and run a small Apache Geode cluster from inside
your IDE using Spring Boot. This is extremely helpful during development because it enables you to manually run, test,
and debug your applications quickly and easily.</simpara>
<simpara>Spring Boot for Apache Geode includes such a class:</simpara>
<example>
<title>Spring Boot application class used to configure and bootstrap an Apache Geode server</title>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@CacheServerApplication(name = "SpringBootApacheGeodeCacheServerApplication")
@SuppressWarnings("unused")
public class SpringBootApacheGeodeCacheServerApplication {

	public static void main(String[] args) {

		new SpringApplicationBuilder(SpringBootApacheGeodeCacheServerApplication.class)
			.web(WebApplicationType.NONE)
			.build()
			.run(args);
	}

	@Configuration
	@UseLocators
	@Profile("clustered")
	static class ClusteredConfiguration { }

	@Configuration
	@EnableLocator
	@EnableManager(start = true)
	@Profile("!clustered")
	static class LonerConfiguration { }

}</programlisting>
</example>
<simpara>This class is a proper Spring Boot application that you can use to configure and bootstrap multiple Apache Geode servers
and join them together to form a small cluster. You only need to modify the runtime configuration of this class
to startup multiple servers.</simpara>
<simpara>Initially, you will need to start a single (primary) server with an embedded Locator and Manager.</simpara>
<simpara>The Locator enables members in the cluster to locate one another and lets new members join the cluster as a peer.
The Locator also lets clients connect to the servers in the cluster. When the cache client&#8217;s connection pool
is configured to use Locators, the pool of connections can intelligently route data requests directly to the server
hosting the data (a.k.a. single-hop access), especially when the data is partitioned/sharded across multiple servers
in the cluster. Locator-based connection pools include support for load balancing connections and handling automatic
fail-over in the event of failed connections, among other things.</simpara>
<simpara>The Manager lets you connect to this server using Gfsh (Apache Geode&#8217;s
<link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}/tools_modules/gfsh/chapter_overview.html">command-line shell tool</link>).</simpara>
<simpara>To start your primary server, create a run configuration in your IDE for the <literal>SpringBootApacheGeodeCacheServerApplication</literal>
class using the following, recommended JRE command-line options:</simpara>
<example>
<title>Server 1 run profile configuration</title>
<programlisting language="txt" linenumbering="unnumbered">-server -ea -Dspring.profiles.active=</programlisting>
</example>
<simpara>Run the class. You should see output similar to the following:</simpara>
<example>
<title>Server 1 output on startup</title>
<programlisting language="txt" linenumbering="unnumbered">/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/bin/java -server -ea -Dspring.profiles.active= "-javaagent:/Applications/IntelliJ IDEA 17 CE.app/Contents/lib/idea_rt.jar=62866:/Applications/IntelliJ IDEA 17 CE.app/Contents/bin" -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/lib/tools.jar:/Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build/classes/main:/Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build/resources/main:/Users/jblum/pivdev/spring-boot-data-geode/spring-geode-autoconfigure/build/classes/main:/Users/jblum/pivdev/spring-boot-data-geode/spring-geode-autoconfigure/build/resources/main:/Users/jblum/pivdev/spring-boot-data-geode/spring-geode/build/classes/main:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-starter/2.0.3.RELEASE/ffaa050dbd36b0441645598f1a7ddaf67fd5e678/spring-boot-starter-2.0.3.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-autoconfigure/2.0.3.RELEASE/11bc4cc96b08fabad2b3186755818fa0b32d83f/spring-boot-autoconfigure-2.0.3.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot/2.0.3.RELEASE/b874870d915adbc3dd932e19077d3d45c8e54aa0/spring-boot-2.0.3.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/javax.annotation/javax.annotation-api/1.3.2/934c04d3cfef185a8008e7bf34331b79730a9d43/javax.annotation-api-1.3.2.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-geode/2.0.8.RELEASE/9e0a3cd2805306d355c77537aea07c281fc581b/spring-data-geode-2.0.8.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework/spring-context-support/5.0.7.RELEASE/e8ee4902d9d8bfbb21bc5e8f30cfbb4324adb4f3/spring-context-support-5.0.7.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework/spring-context/5.0.7.RELEASE/243a23f8968de8754d8199d669780d683ab177bd/spring-context-5.0.7.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework/spring-tx/5.0.7.RELEASE/4ca59b21c61162adb146ad1b40c30b60d8dc42b8/spring-tx-5.0.7.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework/spring-web/5.0.7.RELEASE/2e04c6c2922fbfa06b5948be14a5782db168b6ec/spring-web-5.0.7.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-commons/2.0.8.RELEASE/5c19af63b5acb0eab39066684e813d5ecd9d03b7/spring-data-commons-2.0.8.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework/spring-aop/5.0.7.RELEASE/fdd0b6aa3c9c7a188c3bfbf6dfd8d40e843be9ef/spring-aop-5.0.7.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework/spring-beans/5.0.7.RELEASE/c1196cb3e56da83e3c3a02ef323699f4b05feedc/spring-beans-5.0.7.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework/spring-expression/5.0.7.RELEASE/ca01fb473f53dd0ee3c85663b26d5dc325602057/spring-expression-5.0.7.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework/spring-core/5.0.7.RELEASE/54b731178d81e66eca9623df772ff32718208137/spring-core-5.0.7.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.19/2d998d3d674b172a588e54ab619854d073f555b5/snakeyaml-1.19.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework/spring-jcl/5.0.7.RELEASE/699016ddf454c2c167d9f84ae5777eccadf54728/spring-jcl-5.0.7.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.geode/geode-lucene/1.2.1/3d22a050bd4eb64bd8c82a74677f45c070f102d5/geode-lucene-1.2.1.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.geode/geode-core/1.2.1/fe853317e33dd2a1c291f29cee3c4be549f75a69/geode-core-1.2.1.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.geode/geode-cq/1.2.1/69873d6b956ba13b55c894a13e72106fb552e840/geode-cq-1.2.1.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.geode/geode-wan/1.2.1/df0dd8516e1af17790185255ff21a54b56d94344/geode-wan-1.2.1.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/antlr/antlr/2.7.7/83cd2cd674a217ade95a4bb83a8a14f351f48bd0/antlr-2.7.7.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.shiro/shiro-spring/1.3.2/281a6b565f6cf3aebd31ddb004632008d7106f2d/shiro-spring-1.3.2.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaver/1.8.13/ad94df2a28d658a40dc27bbaff6a1ce5fbf04e9b/aspectjweaver-1.8.13.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.9.6/cfa4f316351a91bfd95cb0644c6a2c95f52db1fc/jackson-databind-2.9.6.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-annotations/2.9.0/7c10d545325e3a6e72e06381afe469fd40eb701/jackson-annotations-2.9.0.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.shiro/shiro-web/1.3.2/725be023e1c65a0fd70c01b8c0c13a2936c23315/shiro-web-1.3.2.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.shiro/shiro-core/1.3.2/b5dede9d890f335998a8ebf479809fe365b927fc/shiro-core-1.3.2.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.slf4j/slf4j-api/1.7.25/da76ca59f6a57ee3102f8f9bd9cee742973efa8a/slf4j-api-1.7.25.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/com.github.stephenc.findbugs/findbugs-annotations/1.3.9-1/a6b11447635d80757d64b355bed3c00786d86801/findbugs-annotations-1.3.9-1.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.jgroups/jgroups/3.6.10.Final/fc0ff5a8a9de27ab62939956f705c2909bf86bc2/jgroups-3.6.10.Final.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/commons-io/commons-io/2.5/2852e6e05fbb95076fc091f6d1780f1f8fe35e0f/commons-io-2.5.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/commons-lang/commons-lang/2.6/ce1edb914c94ebc388f086c6827e8bdeec71ac2/commons-lang-2.6.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/it.unimi.dsi/fastutil/7.1.0/9835253257524c1be7ab50c057aa2d418fb72082/fastutil-7.1.0.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/javax.resource/javax.resource-api/1.7/ae40e0864eb1e92c48bf82a2a3399cbbf523fb79/javax.resource-api-1.7.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/net.java.dev.jna/jna/4.5.1/65bd0cacc9c79a21c6ed8e9f588577cd3c2f85b9/jna-4.5.1.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/net.sf.jopt-simple/jopt-simple/5.0.3/cdd846cfc4e0f7eefafc02c0f5dce32b9303aa2a/jopt-simple-5.0.3.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.logging.log4j/log4j-core/2.10.0/c90b597163cd28ab6d9687edd53db601b6ea75a1/log4j-core-2.10.0.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.logging.log4j/log4j-api/2.10.0/fec5797a55b786184a537abd39c3fa1449d752d6/log4j-api-2.10.0.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/commons-beanutils/commons-beanutils/1.9.3/c845703de334ddc6b4b3cd26835458cb1cba1f3d/commons-beanutils-1.9.3.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/io.github.lukehutch/fast-classpath-scanner/2.0.11/ae34a7a5e6de8ad1f86e12f6f7ae1869fcfe9987/fast-classpath-scanner-2.0.11.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.geode/geode-common/1.2.1/9db253081d33f424f6e3ce0cde4b306e23e3420b/geode-common-1.2.1.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.geode/geode-json/1.2.1/bdb4c262e4ce6bb3b22e0f511cfb133a65fa0c04/geode-json-1.2.1.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.lucene/lucene-analyzers-common/6.4.1/c6f0f593503080204e9d33189cdc59320f55db37/lucene-analyzers-common-6.4.1.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.lucene/lucene-queryparser/6.4.1/1fc5795a072770a2c47dce11a3c85a80f3437af6/lucene-queryparser-6.4.1.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.lucene/lucene-queries/6.4.1/6de41d984c16185a244b52c4d069b00f5b2b120f/lucene-queries-6.4.1.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.apache.lucene/lucene-core/6.4.1/2a18924b9e0ed86b318902cb475a0b9ca4d7be5b/lucene-core-6.4.1.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-core/2.9.6/4e393793c37c77e042ccc7be5a914ae39251b365/jackson-core-2.9.6.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/javax.transaction/javax.transaction-api/1.2/d81aff979d603edd90dcd8db2abc1f4ce6479e3e/javax.transaction-api-1.2.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/commons-logging/commons-logging/1.2/4bfc12adfe4842bf07b657f0369c4cb522955686/commons-logging-1.2.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/commons-collections/commons-collections/3.2.2/8ad72fe39fa8c91eaaf12aadb21e0c3661fe26d5/commons-collections-3.2.2.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/org.springframework.shell/spring-shell/1.2.0.RELEASE/d94047721f292bd5334b5654e8600cef4b845049/spring-shell-1.2.0.RELEASE.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/17.0/9c6ef172e8de35fd8d4d8783e4821e57cdef7445/guava-17.0.jar:/Users/jblum/.gradle/caches/modules-2/files-2.1/jline/jline/2.12/ce9062c6a125e0f9ad766032573c041ae8ecc986/jline-2.12.jar org.springframework.geode.docs.example.app.server.SpringBootApacheGeodeCacheServerApplication
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See https://www.slf4j.org/codes.html#StaticLoggerBinder for further details.

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.3.RELEASE)

[info 2018/06/24 21:42:28.183 PDT &lt;main&gt; tid=0x1] Starting SpringBootApacheGeodeCacheServerApplication on jblum-mbpro-2.local with PID 41795 (/Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build/classes/main started by jblum in /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build)

[info 2018/06/24 21:42:28.186 PDT &lt;main&gt; tid=0x1] No active profile set, falling back to default profiles: default

[info 2018/06/24 21:42:28.278 PDT &lt;main&gt; tid=0x1] Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@6fa51cd4: startup date [Sun Jun 24 21:42:28 PDT 2018]; root of context hierarchy

[warn 2018/06/24 21:42:28.962 PDT &lt;main&gt; tid=0x1] @Bean method PdxConfiguration.pdxDiskStoreAwareBeanFactoryPostProcessor is non-static and returns an object assignable to Spring's BeanFactoryPostProcessor interface. This will result in a failure to process annotations such as @Autowired, @Resource and @PostConstruct within the method's declaring @Configuration class. Add the 'static' modifier to this method to avoid these container lifecycle issues; see @Bean javadoc for complete details.

[info 2018/06/24 21:42:30.036 PDT &lt;main&gt; tid=0x1]
---------------------------------------------------------------------------

  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with this
  work for additional information regarding copyright ownership.

  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with the
  License.  You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
  License for the specific language governing permissions and limitations
  under the License.

---------------------------------------------------------------------------
Build-Date: 2017-09-16 07:20:46 -0700
Build-Id: abaker 0
Build-Java-Version: 1.8.0_121
Build-Platform: Mac OS X 10.12.3 x86_64
Product-Name: Apache Geode
Product-Version: 1.2.1
Source-Date: 2017-09-08 11:57:38 -0700
Source-Repository: release/1.2.1
Source-Revision: 0b881b515eb1dcea974f0f5c1b40da03d42af9cf
Native version: native code unavailable
Running on: /10.0.0.121, 8 cpu(s), x86_64 Mac OS X 10.10.5
Communications version: 65
Process ID: 41795
User: jblum
Current dir: /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build
Home dir: /Users/jblum
Command Line Parameters:
  -ea
  -Dspring.profiles.active=
  -javaagent:/Applications/IntelliJ IDEA 17 CE.app/Contents/lib/idea_rt.jar=62866:/Applications/IntelliJ IDEA 17 CE.app/Contents/bin
  -Dfile.encoding=UTF-8
Class Path:
  /Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/charsets.jar
  ...
Library Path:
  /Users/jblum/Library/Java/Extensions
  /Library/Java/Extensions
  /Network/Library/Java/Extensions
  /System/Library/Java/Extensions
  /usr/lib/java
  .
System Properties:
    PID = 41795
  ...
[info 2018/06/24 21:42:30.045 PDT &lt;main&gt; tid=0x1] Startup Configuration:
 ### GemFire Properties defined with api ###
disable-auto-reconnect=true
jmx-manager=true
jmx-manager-port=1099
jmx-manager-start=true
jmx-manager-update-rate=2000
log-level=config
mcast-port=0
name=SpringBootApacheGeodeCacheServerApplication
start-locator=localhost[10334]
use-cluster-configuration=false
### GemFire Properties using default values ###
ack-severe-alert-threshold=0
...

[info 2018/06/24 21:42:30.090 PDT &lt;main&gt; tid=0x1] Starting peer location for Distribution Locator on localhost/127.0.0.1

[info 2018/06/24 21:42:30.093 PDT &lt;main&gt; tid=0x1] Starting Distribution Locator on localhost/127.0.0.1

[info 2018/06/24 21:42:30.094 PDT &lt;main&gt; tid=0x1] Locator was created at Sun Jun 24 21:42:30 PDT 2018

[info 2018/06/24 21:42:30.094 PDT &lt;main&gt; tid=0x1] Listening on port 10334 bound on address localhost/127.0.0.1

...

[info 2018/06/24 21:42:30.685 PDT &lt;main&gt; tid=0x1] Initializing region _monitoringRegion_10.0.0.121&lt;v0&gt;1024

[info 2018/06/24 21:42:30.688 PDT &lt;main&gt; tid=0x1] Initialization of region _monitoringRegion_10.0.0.121&lt;v0&gt;1024 completed

...

[info 2018/06/24 21:42:31.570 PDT &lt;main&gt; tid=0x1] CacheServer Configuration:   port=40404 max-connections=800 max-threads=0 notify-by-subscription=true socket-buffer-size=32768 maximum-time-between-pings=60000 maximum-message-count=230000 message-time-to-live=180 eviction-policy=none capacity=1 overflow directory=. groups=[] loadProbe=ConnectionCountProbe loadPollInterval=5000 tcpNoDelay=true

[info 2018/06/24 21:42:31.588 PDT &lt;main&gt; tid=0x1] Started SpringBootApacheGeodeCacheServerApplication in 3.77 seconds (JVM running for 5.429)</programlisting>
</example>
<simpara>You can now connect to this server by using Gfsh:</simpara>
<example>
<title>Connect with Gfsh</title>
<programlisting language="txt" linenumbering="unnumbered">$ echo $GEMFIRE
/Users/jblum/pivdev/apache-geode-1.2.1
jblum-mbpro-2:lab jblum$
jblum-mbpro-2:lab jblum$ gfsh
    _________________________     __
   / _____/ ______/ ______/ /____/ /
  / /  __/ /___  /_____  / _____  /
 / /__/ / ____/  _____/ / /    / /
/______/_/      /______/_/    /_/    1.2.1

Monitor and Manage Apache Geode

gfsh&gt;connect
Connecting to Locator at [host=localhost, port=10334] ..
Connecting to Manager at [host=10.0.0.121, port=1099] ..
Successfully connected to: [host=10.0.0.121, port=1099]


gfsh&gt;list members
                   Name                     | Id
------------------------------------------- | --------------------------------------------------------------------------
SpringBootApacheGeodeCacheServerApplication | 10.0.0.121(SpringBootApacheGeodeCacheServerApplication:41795)&lt;ec&gt;&lt;v0&gt;:1024


gfsh&gt;describe member --name=SpringBootApacheGeodeCacheServerApplication
Name        : SpringBootApacheGeodeCacheServerApplication
Id          : 10.0.0.121(SpringBootApacheGeodeCacheServerApplication:41795)&lt;ec&gt;&lt;v0&gt;:1024
Host        : 10.0.0.121
Regions     :
PID         : 41795
Groups      :
Used Heap   : 184M
Max Heap    : 3641M
Working Dir : /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build
Log file    : /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build
Locators    : localhost[10334]

Cache Server Information
Server Bind              :
Server Port              : 40404
Running                  : true
Client Connections       : 0</programlisting>
</example>
<simpara>Now you can run additional servers to scale-out your cluster.</simpara>
<simpara>To do so, you must vary the name of the members you add to your cluster as peers. Apache Geode requires members in a
cluster to be named and for the names of each member in the cluster to be unique.</simpara>
<simpara>Additionally, since we are running multiple instances of our <literal>SpringBootApacheGeodeCacheServerApplication</literal> class,
which also embeds a <literal>CacheServer</literal> component enabling cache clients to connect. Therefore, you must vary the ports
used by the embedded services.</simpara>
<simpara>Fortunately, you do not need to run another embedded Locator or Manager (you need only one of each in this case).
Therefore, you can switch profiles from non-clustered to using the Spring "clustered" profile, which includes different
configuration (the <literal>ClusterConfiguration</literal> class) to connect another server as a peer member in the cluster,
which currently has only one member, as shown in Gfsh with the <literal>list members</literal> command (shown earlier).</simpara>
<simpara>To add another server, set the member name and <literal>CacheServer</literal> port to different values with the following
run configuration:</simpara>
<example>
<title>Run profile configuration for server 2</title>
<programlisting language="txt" linenumbering="unnumbered">-server -ea -Dspring.profiles.active=clustered -Dspring.data.gemfire.name=ServerTwo -Dspring.data.gemfire.cache.server.port=41414</programlisting>
</example>
<simpara>Notice that we explicitly activated the "clustered" Spring profile, which enables the configuration provided in
the nested <literal>ClusteredConfiguration</literal> class while disabling the configuration provided in the <literal>LonerConfiguration</literal> class.</simpara>
<simpara>The <literal>ClusteredConfiguration</literal> class is also annotated with <literal>@UseLocators</literal>, which sets the Apache Geode <literal>locators</literal>
property to "localhost[10334]".  By default, it assumes that the Locator runs on localhost, listening on the default
Locator port of 10334. You can adjust your <literal>locators</literal> connection endpoint if your Locators run elsewhere in your network
by using the <literal>locators</literal> attribute of the <literal>@UseLocators</literal> annotation.</simpara>
<tip>
<simpara>In production environments, it is common to run multiple Locators in separate processes. Running multiple Locators
provides redundancy in case a Locator fails. If all Locators in your cluster fail, then your cluster will continue to
run, but no other members will be able to join the cluster, which is important when scaling out the cluster. Clients
also will not be able to connect. Restart the Locators if this happens.</simpara>
</tip>
<simpara>Also, we set the <literal>spring.data.gemfire.name</literal> property to <literal>ServerTwo</literal>, adjusting the name of our member when it joins
the cluster as a peer.</simpara>
<simpara>Finally, we set the <literal>spring.data.gemfire.cache.server.port</literal> property to <literal>41414</literal> to vary the <literal>CacheServer</literal> port used by
<literal>ServerTwo</literal>.  The default <literal>CacheServer</literal> port is <literal>40404</literal>. If we had not set this property before starting <literal>ServerTwo</literal>,
we would have encounter a <literal>java.net.BindException</literal>.</simpara>
<tip>
<simpara>Both <literal>spring.data.gemfire.name</literal> and <literal>spring.data.gemfire.cache.server.port</literal> are well-known properties used by SDG
to dynamically configure Apache Geode with a Spring Boot <literal>application.properties</literal> file or by using Java System
properties. You can find these properties in the annotation Javadoc in SDG&#8217;s annotation-based configuration model.
For example, see the Javadoc for the
<link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api/org/springframework/data/gemfire/config/annotation/CacheServerApplication.html#port--"><literal>spring.data.gemfire.cache.server.port</literal> property</link>.
Most SDG annotations include corresponding properties that can be defined in Spring Boot <literal>application.properties</literal>,
which is explained in detail in the <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html/#bootstrap-annotation-config-properties">documentation</link>.</simpara>
</tip>
<simpara>After starting our second server, <literal>ServerTwo</literal>, we should see output similar to the following at the command-line
and in Gfsh when we again <literal>list members</literal> and <literal>describe member</literal>:</simpara>
<example>
<title>Gfsh output after starting server 2</title>
<programlisting language="txt" linenumbering="unnumbered">gfsh&gt;list members
                   Name                     | Id
------------------------------------------- | --------------------------------------------------------------------------
SpringBootApacheGeodeCacheServerApplication | 10.0.0.121(SpringBootApacheGeodeCacheServerApplication:41795)&lt;ec&gt;&lt;v0&gt;:1024
ServerTwo                                   | 10.0.0.121(ServerTwo:41933)&lt;v1&gt;:1025


gfsh&gt;describe member --name=ServerTwo
Name        : ServerTwo
Id          : 10.0.0.121(ServerTwo:41933)&lt;v1&gt;:1025
Host        : 10.0.0.121
Regions     :
PID         : 41933
Groups      :
Used Heap   : 165M
Max Heap    : 3641M
Working Dir : /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build
Log file    : /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build
Locators    : localhost[10334]

Cache Server Information
Server Bind              :
Server Port              : 41414
Running                  : true
Client Connections       : 0</programlisting>
</example>
<simpara>When we list the members of the cluster, we see <literal>ServerTwo</literal>, and when we <literal>describe</literal> <literal>ServerTwo</literal>, we see that its
<literal>CacheServer</literal> port is appropriately set to <literal>41414</literal>.</simpara>
<simpara>We can add one more server, <literal>ServerThree</literal>, by using the following run configuration:</simpara>
<example>
<title>Add server three to our cluster</title>
<programlisting language="txt" linenumbering="unnumbered">-server -ea -Dspring.profiles.active=clustered -Dspring.data.gemfire.name=ServerThree -Dspring.data.gemfire.cache.server.port=42424</programlisting>
</example>
<simpara>We again see similar output at the command-line and in Gfsh:</simpara>
<example>
<title>Gfsh output after starting server 3</title>
<programlisting language="txt" linenumbering="unnumbered">gfsh&gt;list members
                   Name                     | Id
------------------------------------------- | --------------------------------------------------------------------------
SpringBootApacheGeodeCacheServerApplication | 10.0.0.121(SpringBootApacheGeodeCacheServerApplication:41795)&lt;ec&gt;&lt;v0&gt;:1024
ServerTwo                                   | 10.0.0.121(ServerTwo:41933)&lt;v1&gt;:1025
ServerThree                                 | 10.0.0.121(ServerThree:41965)&lt;v2&gt;:1026


gfsh&gt;describe member --name=ServerThree
Name        : ServerThree
Id          : 10.0.0.121(ServerThree:41965)&lt;v2&gt;:1026
Host        : 10.0.0.121
Regions     :
PID         : 41965
Groups      :
Used Heap   : 180M
Max Heap    : 3641M
Working Dir : /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build
Log file    : /Users/jblum/pivdev/spring-boot-data-geode/spring-geode-docs/build
Locators    : localhost[10334]

Cache Server Information
Server Bind              :
Server Port              : 42424
Running                  : true
Client Connections       : 0</programlisting>
</example>
<simpara>Congratulations. You have just started a small Apache Geode cluster with 3 members by using Spring Boot from inside
your IDE.</simpara>
<simpara>Now you can build and run a Spring Boot, Apache Geode <literal>ClientCache</literal> application that connects to this cluster. To do so,
include and use Spring Boot for Apache Geode.</simpara>
</section>
<section xml:id="geode-testing-support">
<title>Testing</title>
<simpara><link xl:href="https://github.com/spring-projects/spring-test-data-geode">Spring Test for Apache Geode</link> (STDG) is a relatively new project
to help you write both unit and integration tests when you use Apache Geode in a Spring context. In fact, the entire
{github-url}/tree/master/spring-geode-autoconfigure/src/test/java/org/springframework/geode/boot/autoconfigure[test suite]
in Spring Boot for Apache Geode is based on this project.</simpara>
<simpara>All Spring projects that integrate with Apache Geode will use this new test framework for all their testing needs,
making this new test framework for Apache Geode a proven and reliable solution for all your Apache Geode application
testing needs when using Spring as well.</simpara>
<simpara>In future versions, this reference guide will include an entire chapter on testing along with samples. In the meantime,
look to the STDG <link xl:href="https://github.com/spring-projects/spring-test-data-geode#stdg-in-a-nutshell">README</link>.</simpara>
</section>
<section xml:id="geode-examples">
<title>Examples</title>
<simpara>The definitive source of truth on how to best use Spring Boot for Apache Geode is to refer to
the <link linkend="geode-samples">samples</link>.</simpara>
<simpara>See also the <link xl:href="https://github.com/jxblum/temperature-service">Temperature Service</link>, Spring Boot application that implements
a temperature sensor and monitoring, Internet of Things (IOT) example. The example uses SBDG to showcase Apache Geode CQ,
function implementations and executions, and positions Apache Geode as a caching provider in Spring&#8217;s Cache Abstraction.
It is a working, sophisticated, and complete example, and we highly recommend it as a good starting point for real-world
use cases.</simpara>
<simpara>See the <link xl:href="https://github.com/jxblum/contacts-application/tree/master/boot-example">Boot example</link> from the contact
application reference implementation (RI) for Spring Data for Apache Geode (SDG) as yet another example.</simpara>
</section>
<section xml:id="references">
<title>References</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Spring Framework <link xl:href="https://docs.spring.io/spring/docs/current/spring-framework-reference">Reference Guide</link> | <link xl:href="https://docs.spring.io/spring/docs/current/javadoc-api">Javadoc</link></simpara>
</listitem>
<listitem>
<simpara>Spring Boot <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html">Reference Guide</link> | <link xl:href="https://docs.spring.io/spring-boot/docs/current/api">Javadoc</link></simpara>
</listitem>
<listitem>
<simpara>Spring Data Commons <link xl:href="https://docs.spring.io/spring-data/commons/docs/current/reference/html">Reference Guide</link> | <link xl:href="https://docs.spring.io/spring-data/commons/docs/current/api">Javadoc</link></simpara>
</listitem>
<listitem>
<simpara>Spring Data for Apache Geode <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/reference/html">Reference Guide</link> | <link xl:href="https://docs.spring.io/spring-data/geode/docs/current/api">Javadoc</link></simpara>
</listitem>
<listitem>
<simpara>Spring Session for Apache Geode <link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/reference/html5">Reference Guide</link> | <link xl:href="https://docs.spring.io/autorepo/docs/spring-session-data-geode-build/{spring-session-data-geode-version}/api">Javadoc</link></simpara>
</listitem>
<listitem>
<simpara>Spring Test for Apache Geode <link xl:href="https://github.com/spring-projects/spring-test-data-geode#spring-test-framework-for-apache-geode&#8212;&#8203;vmware-tanzu-gemfire">README</link></simpara>
</listitem>
<listitem>
<simpara>Apache Geode <link xl:href="https://geode.apache.org/docs/guide/{apache-geode-doc-version}">User Guide</link> | <link xl:href="https://geode.apache.org/releases/latest/javadoc">Javadoc</link></simpara>
</listitem>
</orderedlist>
</section>
</chapter>
</book>